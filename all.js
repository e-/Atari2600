var Pacman = [216,120,162,255,154,232,138,149,0,232,208,251,169,6,133,132,10,133,236,202,134,130,134,203,32,244,251,169,203,133,204,74,133,182,169,237,133,206,169,15,133,208,162,4,149,192,202,208,251,133,2,169,240,133,35,169,128,133,36,162,6,202,208,253,133,20,133,19,133,2,133,42,133,2,133,43,134,231,134,152,76,214,247,169,0,228,217,48,9,164,220,48,5,177,223,136,132,220,133,2,133,28,96,32,83,240,169,0,232,228,216,48,9,164,219,48,5,177,221,136,132,219,133,2,133,27,96,133,2,169,32,133,4,162,0,168,165,128,41,8,208,3,162,9,234,202,16,253,133,18,132,34,132,5,162,1,169,1,24,117,176,160,2,56,200,233,15,176,251,73,255,233,6,10,10,10,10,133,2,136,16,253,149,16,149,32,202,16,223,133,2,133,42,160,1,162,7,173,132,2,208,251,133,2,132,1,133,43,165,240,133,9,132,202,136,132,135,134,201,232,169,49,133,10,165,241,133,8,32,106,240,160,255,132,13,132,14,169,127,133,15,76,19,243,169,0,228,217,48,9,164,220,48,5,177,223,136,132,220,133,2,133,28,164,202,136,240,106,164,135,185,136,0,41,15,168,185,71,253,133,212,32,106,240,169,0,133,29,164,135,185,136,0,74,74,74,74,41,7,168,185,63,253,133,211,32,83,240,164,135,185,136,0,16,4,169,80,208,2,169,16,133,210,185,140,0,41,7,168,185,99,253,133,215,32,106,240,164,135,185,140,0,74,74,74,133,213,41,7,168,185,91,253,133,214,32,83,240,165,213,74,74,74,41,3,168,185,87,253,133,213,76,244,241,164,135,185,144,0,41,7,168,185,123,253,133,212,32,106,240,169,0,133,29,165,225,133,31,164,135,185,144,0,74,74,74,41,15,168,185,107,253,133,211,32,83,240,164,135,185,144,0,16,4,169,80,208,2,169,16,133,210,185,148,0,41,7,168,185,99,253,133,215,32,106,240,164,135,185,148,0,74,74,74,133,213,41,7,168,185,131,253,133,214,32,83,240,165,225,133,30,165,213,74,74,74,168,185,71,253,133,213,76,244,241,165,214,133,14,234,234,165,215,133,15,169,0,76,70,242,32,106,240,165,201,201,4,208,12,169,64,5,212,133,212,169,32,5,213,133,213,169,0,228,217,48,9,164,220,48,5,177,223,136,132,220,133,2,133,28,165,210,133,13,160,48,132,10,165,211,133,14,165,212,133,15,232,165,213,133,13,228,216,48,176,165,214,133,14,164,219,48,174,165,215,133,15,177,221,136,132,219,133,2,133,27,165,210,133,13,165,211,133,14,165,212,133,15,234,234,165,213,133,13,228,217,48,24,165,214,133,14,164,220,48,22,165,215,133,15,177,223,136,132,220,133,2,133,28,76,135,242,165,214,133,14,234,234,165,215,133,15,169,0,76,113,242,164,202,185,10,254,133,13,185,12,254,133,14,169,49,133,10,165,227,133,15,165,201,24,105,255,16,3,76,96,243,133,201,169,0,232,228,216,48,9,164,219,48,5,177,221,136,132,219,133,2,133,27,160,0,132,30,132,226,165,201,168,41,1,133,202,200,152,74,133,135,32,103,240,160,1,165,128,41,8,208,2,160,3,165,201,240,5,201,6,208,12,136,165,154,57,108,254,240,4,169,2,133,226,32,83,240,169,0,133,31,32,106,240,165,226,133,29,32,83,240,32,106,240,164,202,185,65,255,133,13,185,15,254,133,14,185,17,254,133,15,32,83,240,165,231,164,201,192,3,240,2,169,0,133,225,32,106,240,164,202,185,13,254,164,201,192,4,208,2,169,64,133,227,32,83,240,169,0,232,228,216,48,9,164,219,48,5,177,221,136,132,219,133,2,133,27,164,202,133,27,185,10,254,133,13,185,12,254,133,14,165,227,133,15,76,244,240,169,0,232,228,216,48,9,164,219,48,5,177,221,136,132,219,133,2,133,27,32,103,240,32,103,240,32,103,240,169,255,133,13,133,14,169,127,133,15,169,76,141,150,2,32,83,240,32,106,240,32,83,240,169,3,160,0,133,2,132,13,132,14,132,15,132,12,133,4,133,5,133,37,133,38,32,131,244,165,130,133,7,133,6,162,7,133,2,202,208,253,234,133,16,133,17,169,240,133,32,133,2,133,42,134,9,160,4,165,245,133,210,32,238,243,165,230,10,16,9,160,5,165,244,133,210,32,238,243,169,0,133,37,133,38,133,4,133,5,76,142,244,162,8,169,0,133,225,240,44,185,204,0,74,74,74,74,170,240,2,230,225,165,225,208,2,162,10,189,246,254,166,226,149,213,202,202,224,4,208,4,169,0,240,5,138,208,6,165,210,133,2,133,9,134,226,185,204,0,41,15,170,240,2,230,225,165,225,208,2,162,10,189,246,254,166,226,149,213,202,202,134,226,136,136,16,179,165,225,208,4,169,172,133,213,169,254,162,9,149,213,202,202,16,250,169,6,133,225,164,225,169,0,133,27,133,27,133,2,177,221,133,28,177,219,133,27,177,217,133,226,177,215,170,177,213,168,165,226,133,28,134,27,132,28,132,27,198,225,16,214,169,0,133,27,133,28,133,27,133,28,96,168,165,230,16,2,160,3,166,152,32,104,252,169,0,133,2,133,9,160,3,165,230,16,2,160,0,166,172,32,104,252,162,6,165,244,133,7,165,245,133,6,133,2,169,2,133,10,165,210,133,13,165,211,133,14,165,212,133,15,234,234,234,165,213,133,13,165,214,133,14,165,215,133,15,202,208,220,133,2,134,10,134,8,134,13,134,14,134,15,166,130,208,9,32,173,251,165,229,16,5,198,229,76,195,247,165,228,240,96,165,128,106,144,91,198,228,208,87,36,154,165,154,16,16,80,10,41,191,133,154,169,32,133,228,16,69,41,124,133,154,165,231,41,64,240,51,69,231,133,231,32,33,252,36,230,80,13,165,172,240,9,32,159,251,165,230,73,128,133,230,165,152,5,172,240,10,198,152,169,8,5,231,133,231,208,19,133,231,169,95,133,130,133,182,76,195,247,165,231,16,4,41,127,133,231,165,231,16,20,165,153,168,136,162,4,149,192,148,196,202,148,196,148,192,202,208,244,240,129,165,49,37,51,41,64,240,22,160,6,32,69,252,160,1,32,67,255,165,231,73,2,133,231,169,18,133,236,208,66,170,165,182,201,5,240,5,201,65,208,55,232,165,177,201,4,240,6,201,148,208,44,232,232,189,108,254,168,37,154,240,34,152,73,255,37,154,9,192,133,154,160,160,165,231,41,32,240,2,160,80,132,228,160,5,32,69,252,160,2,32,67,255,76,170,246,165,128,41,4,208,69,165,55,16,65,165,128,41,3,170,165,154,16,37,181,188,41,8,208,50,181,188,9,8,149,188,165,154,41,3,168,32,69,252,192,3,240,2,230,154,160,3,32,67,255,169,159,133,229,208,19,181,188,41,8,208,13,169,192,5,231,133,231,169,63,133,228,76,186,247,173,128,2,164,230,48,4,74,74,74,74,73,255,41,15,133,237,240,4,169,0,133,129,165,187,41,32,240,43,165,237,74,144,29,165,187,48,18,41,16,208,17,169,63,69,182,41,63,133,182,169,192,69,187,133,187,76,186,247,169,128,208,245,74,144,246,165,187,48,224,16,240,165,133,208,64,164,135,185,19,254,166,177,224,76,240,8,166,187,16,4,200,25,19,254,74,144,42,74,170,165,201,42,168,185,121,254,168,138,41,7,170,189,106,254,170,57,136,0,240,19,138,73,255,57,136,0,153,136,0,160,4,32,69,252,160,0,32,67,255,162,15,165,154,41,60,21,136,202,16,251,170,208,22,165,152,201,9,240,2,230,152,165,153,201,14,240,2,230,153,32,12,252,76,186,247,162,0,165,237,133,210,208,3,76,138,247,164,187,16,80,74,74,41,3,240,66,74,165,133,208,61,165,134,240,4,144,45,176,16,164,135,144,22,165,238,201,249,240,43,136,185,19,254,48,37,169,1,5,187,133,187,160,1,208,113,165,201,201,3,208,4,192,56,240,17,200,200,185,19,254,48,10,169,254,37,187,133,187,160,0,240,86,165,210,41,243,240,95,133,210,165,210,41,3,240,78,74,165,134,208,73,165,177,201,76,208,29,165,182,240,15,201,70,208,21,165,210,74,74,144,15,32,38,253,208,105,165,210,74,144,5,32,50,253,208,95,165,210,74,165,133,240,4,144,21,176,10,164,135,185,19,254,144,8,42,16,17,160,3,76,123,247,42,42,16,8,160,2,32,229,249,76,186,247,165,210,41,252,133,210,76,221,246,32,147,247,32,238,249,76,186,247,165,133,5,134,240,1,96,181,187,42,176,14,16,6,32,112,251,76,184,247,32,135,251,76,184,247,16,6,32,54,251,76,184,247,32,92,251,104,104,165,187,106,144,4,169,8,133,12,162,0,134,25,134,26,32,85,255,162,1,32,148,255,173,132,2,208,251,169,3,133,2,133,1,133,0,133,44,165,128,74,74,74,168,74,41,3,170,189,171,253,133,221,165,231,42,16,12,165,228,74,74,41,15,170,189,250,253,208,14,152,41,3,170,189,194,253,166,231,16,3,173,194,253,133,223,133,2,230,128,208,39,230,129,240,31,198,236,208,23,160,18,165,231,73,2,133,231,41,2,240,9,160,3,165,231,41,32,240,1,136,132,236,165,130,240,4,230,130,240,252,133,2,169,253,133,222,133,224,165,182,24,105,11,133,217,162,7,134,219,202,134,220,162,255,169,8,45,130,2,208,2,162,15,138,166,130,240,2,73,8,133,239,169,7,133,240,169,8,133,241,165,175,133,244,169,41,141,150,2,133,2,162,0,134,0,165,155,133,245,165,130,240,4,165,60,16,6,173,130,2,106,176,49,169,255,133,203,32,125,252,133,172,133,130,169,8,133,231,169,11,166,132,224,8,16,2,169,9,133,192,32,244,251,165,230,41,127,133,230,10,16,82,32,159,251,32,244,251,230,172,208,72,106,176,69,165,131,208,55,230,132,169,96,133,182,169,16,133,231,165,230,73,64,133,230,32,125,252,133,25,133,26,133,232,169,1,133,130,133,128,165,132,201,18,208,2,169,2,133,132,74,56,233,2,41,7,208,2,169,8,133,204,133,205,230,131,165,131,41,31,208,6,240,191,160,0,132,131,169,223,37,231,133,231,169,128,166,230,48,1,74,162,32,45,130,2,208,2,162,0,138,5,231,133,231,169,6,133,243,165,128,41,3,170,168,165,154,16,7,160,4,41,64,208,1,200,132,242,232,181,187,41,8,240,6,169,198,133,221,208,4,165,229,48,13,165,231,48,9,32,170,249,32,170,249,32,170,249,181,177,133,176,181,182,24,105,11,133,216,181,187,41,32,240,5,160,0,32,139,252,165,187,41,32,240,7,160,1,162,0,32,139,252,169,255,133,211,169,43,133,210,162,5,165,239,48,4,169,54,133,210,180,240,177,210,69,130,37,239,149,240,202,16,243,165,243,133,7,165,242,133,6,76,127,240,181,187,41,8,240,34,181,182,201,30,208,28,181,177,201,88,208,4,160,1,208,37,201,76,208,14,165,154,48,28,181,187,41,247,149,187,160,0,240,19,181,187,41,32,208,12,32,173,251,32,38,250,181,187,41,32,240,10,96,181,187,41,63,25,99,254,149,187,181,192,10,10,10,10,24,117,192,149,192,144,233,160,0,181,187,41,239,149,187,42,16,3,136,48,1,200,152,176,13,117,177,201,2,240,6,201,150,240,2,149,177,96,24,117,182,48,6,201,71,240,2,149,182,96,165,134,5,133,208,184,181,187,41,16,208,178,165,130,240,3,76,185,250,181,187,41,8,240,10,169,88,133,211,169,31,133,210,208,80,181,177,201,76,208,20,165,203,41,15,208,14,181,182,208,3,76,50,253,201,70,208,3,76,38,253,165,177,133,211,165,182,133,210,165,154,16,19,165,177,24,105,96,73,255,133,211,165,182,24,105,177,73,255,76,153,250,214,196,208,19,165,153,74,168,185,111,254,149,196,138,74,74,144,37,246,196,76,185,250,181,177,197,211,240,11,144,6,32,112,251,76,170,250,32,135,251,181,182,197,210,144,6,32,54,251,76,185,250,32,92,251,181,187,42,176,4,48,32,16,16,16,42,32,224,251,208,3,32,54,251,32,25,251,32,54,251,32,224,251,208,3,32,135,251,32,252,250,32,135,251,32,224,251,208,3,32,112,251,32,252,250,32,112,251,32,224,251,208,3,32,92,251,32,25,251,32,92,251,32,224,251,32,5,251,104,104,96,208,9,32,54,251,32,92,251,104,104,96,32,92,251,32,54,251,104,104,96,32,224,251,32,34,251,104,104,96,208,9,32,112,251,32,135,251,104,104,96,32,135,251,32,112,251,104,104,96,165,201,240,33,164,135,185,19,254,42,16,25,160,3,138,240,9,181,187,41,192,217,103,254,240,11,181,187,41,63,25,99,254,149,187,104,104,96,165,201,201,7,240,249,164,135,185,19,254,42,42,16,240,160,2,76,68,251,164,135,165,201,201,3,208,4,192,62,240,223,136,185,19,254,48,217,160,1,76,68,251,164,135,165,201,201,3,208,4,192,56,240,200,200,200,185,19,254,48,193,160,0,76,68,251,162,19,181,136,180,156,149,156,148,136,202,16,245,96,160,0,181,182,240,8,200,56,233,10,240,2,16,248,132,201,133,133,181,177,41,3,133,134,165,201,74,8,181,177,74,74,40,144,3,24,105,40,133,135,10,10,102,201,5,201,38,201,133,238,96,165,203,10,69,203,10,10,38,203,165,203,41,7,168,185,106,254,37,203,96,169,9,133,175,169,10,133,155,169,3,133,152,165,132,56,233,2,41,6,24,105,4,133,153,162,15,169,255,149,136,202,16,251,169,127,133,142,169,254,133,138,169,60,133,154,165,231,9,128,133,231,169,60,133,228,162,4,169,76,149,177,160,30,148,182,160,0,148,187,202,16,243,169,60,133,182,169,128,133,187,96,134,225,162,0,165,230,16,1,232,248,24,181,204,121,6,255,149,204,181,206,121,12,255,149,206,181,208,105,0,149,208,216,166,225,96,138,240,2,169,64,153,210,0,189,27,255,153,211,0,189,236,254,153,212,0,96,169,0,162,5,149,204,202,16,251,133,152,133,172,96,181,187,41,16,208,24,214,182,208,103,181,187,48,4,169,0,240,2,169,91,149,182,181,187,9,16,149,187,208,83,181,187,42,176,82,16,55,246,182,181,182,201,11,208,18,169,0,149,182,169,11,153,216,0,181,187,41,15,9,128,149,187,96,201,6,16,19,153,219,0,170,24,189,13,255,190,25,255,117,221,149,221,169,8,208,2,181,182,153,216,0,96,246,182,169,91,213,182,208,242,181,187,41,15,9,96,149,187,185,37,255,149,182,169,112,208,227,48,22,214,182,169,81,213,182,208,215,169,70,149,182,181,187,41,15,9,192,149,187,208,228,214,182,16,150,181,187,41,15,9,160,149,187,208,209,181,187,41,15,9,48,149,187,169,81,208,10,181,187,41,15,9,240,149,187,169,11,149,182,96,8,10,40,42,136,138,168,170,0,64,16,80,4,68,20,84,1,65,17,81,5,69,21,85,0,128,32,160,1,5,17,21,65,69,81,85,128,160,136,168,130,162,138,170,0,2,8,10,32,34,40,42,128,130,136,138,160,162,168,170,8,136,40,168,9,137,41,169,128,129,132,133,144,145,148,149,170,255,255,255,153,221,126,60,85,255,255,255,153,187,126,60,170,255,255,255,187,153,126,60,85,255,255,255,221,153,126,60,139,147,155,163,56,124,254,254,254,108,56,124,254,224,254,108,56,126,224,192,224,108,56,175,181,187,181,0,0,0,0,231,165,231,0,60,126,195,195,231,102,36,24,60,126,231,231,195,195,60,126,231,195,0,0,0,255,126,0,0,0,0,0,20,8,20,0,0,34,20,0,20,34,0,65,0,65,0,34,243,238,232,232,227,227,220,220,213,213,206,206,206,175,175,175,16,16,8,0,8,201,57,201,207,128,32,1,0,69,0,41,0,13,96,17,0,21,32,0,128,96,25,0,29,3,0,103,0,128,32,11,0,0,111,0,19,32,23,64,27,0,63,0,128,128,64,1,0,37,0,73,0,128,96,13,0,17,64,21,0,121,0,29,0,0,3,96,7,0,75,0,15,0,115,0,128,64,23,32,27,0,95,0,128,16,80,144,208,64,0,192,128,64,32,16,8,4,2,1,2,3,5,7,8,10,12,8,12,3,7,11,15,2,6,10,14,1,5,9,13,0,4,121,133,181,165,181,133,121,23,21,21,119,85,85,119,65,65,65,65,65,65,64,73,73,73,201,73,73,190,85,85,85,217,85,85,153,60,102,102,102,102,102,60,102,102,124,96,98,60,102,102,60,102,102,60,70,6,62,102,102,60,70,6,12,6,70,60,12,12,126,76,44,28,12,24,24,8,4,2,98,126,96,96,60,6,70,124,70,6,124,96,96,126,24,24,24,24,120,56,0,0,0,0,0,0,0,1,5,21,85,172,228,216,196,203,222,178,210,184,190,235,165,158,151,144,137,32,64,128,96,1,5,0,0,0,1,0,0,1,6,5,4,3,2,1,0,2,0,0,128,160,168,170,170,170,170,170,16,64,8,10,12,14,252,236,220,204,122,90,251,132,247,68,196,14,14,14,14,9,4,15,0,7,4,10,144,240,185,233,255,37,232,208,10,185,110,254,133,232,185,237,255,133,233,96,165,232,74,144,13,169,4,133,211,165,233,41,31,168,73,15,176,27,74,144,4,169,13,208,17,74,144,3,76,106,255,74,144,28,160,9,132,211,165,233,208,3,168,133,211,214,233,208,5,169,0,133,232,96,149,25,165,211,149,21,148,23,96,169,8,36,231,80,12,165,228,133,25,74,133,23,169,4,133,21,96,240,43,165,228,208,6,169,247,37,231,133,231,74,74,74,41,7,170,224,4,16,44,189,241,255,133,23,189,245,255,133,24,169,4,133,21,133,22,169,8,133,25,133,26,96,165,154,10,16,16,169,4,133,211,165,128,74,41,15,168,73,15,74,76,139,255,96,7,3,1,0,9,24,16,48,8,4,12,4,20,24,20,24,0,0,0,0,240,0,0,0];

var ROM = "";

(function(){
	var length = Pacman.length;
	var pt = [];

	for(var i=0;i<length;i++){
		pt.push(String.fromCharCode(Pacman[i]));
	}

	ROM = pt.join("");
})();

DEBUG_MODE_ON = false;

///*
// * JSConstants.java
// *
// * Created on August 11, 2007, 5:45 PM
// *
// * To change this template, choose Tools | Template Manager
// * and open the template in the editor.
// */
//
//package jstella.core;
//
///**
// *
// * @author J.L. Allen
// */
//public class JSConstants {
//    
//    
//    //Centralized constants for use in GUI elements
//    public final static double JSTELLA_VERSION_NUMBER=0.80;
//    public final static String JSTELLA_VERSION="" + JSTELLA_VERSION_NUMBER + " (beta)"; 
//    public final static String JSTELLA_LONGTITLE="JStella - Atari 2600 Emulator";
//    public final static String JSTELLA_BYLINE="By Bradford Mott and the Stella/JStella teams";
//    public final static String JSTELLA_HTTP="http://jstella.sourceforge.net";
//    
//    
//    //Sep 7 2007 (JLA) : I think the following are concerned with the page size as far as PageAccess is concerned...but does the CPU consider a page size to be 256 bytes?             
    var LOG_MEMSIZE=13;
    var LOG_PAGESIZE=6; 
    var ADDRESS_MASK=((1<<LOG_MEMSIZE)-1);
    var PAGE_MASK=((1 << LOG_PAGESIZE) - 1);
    var PAGE_SIZE=(1 << LOG_PAGESIZE);
    var PAGE_SHIFT=LOG_PAGESIZE;
    var PAGE_COUNT=(1 << (LOG_MEMSIZE - LOG_PAGESIZE));
//  
//    private final static String DIRECTORY_RESOURCES="/jstella/resources/";
//    public final static String RESOURCE_IMAGE_TEST_PATTERN=DIRECTORY_RESOURCES + "testpattern.gif";
//    
//    
    var RESISTANCE_MAX = 0x7FFFFFFF;
		var RESISTANCE_MIN = 0x00000000;
//  
    	var Jack = {  LEFT: 1, RIGHT:2 };
			var DigitalPin = { One:1, Two:2, Three:3, Four:4, Six:5 };
			var AnalogPin =  { Five:11, Nine:12  };
//   
    var TELEVISION_MODE_OFF=0;
    var TELEVISION_MODE_GAME=1;
    var TELEVISION_MODE_TEST_PATTERN=2;
		var TELEVISION_MODE_SNOW=3;
//    
//    
  var CLOCKS_PER_CPU_CYCLE=3;
//    
    var CLOCKS_PER_LINE_BLANK=68;
    var CLOCKS_PER_LINE_VISIBLE=160;
    var CLOCKS_PER_LINE_TOTAL=CLOCKS_PER_LINE_BLANK + CLOCKS_PER_LINE_VISIBLE; //228 clocks/line
//      
    	var  LINES_PER_FRAME_TOTAL=262;
//    
//    protected final static int CLOCKS_PER_FRAME=CLOCKS_PER_LINE_TOTAL * LINES_PER_FRAME_TOTAL; //59,736 clocks/frame
//    protected final static int CPU_CYCLES_PER_FRAME=CLOCKS_PER_FRAME / CLOCKS_PER_CPU_CYCLE; //19,912 cycles/frame
//    
	var  CLOCKS_PER_PLAYFIELD_BIT=4;
//  
    var TIA_POKE_REGISTER_COUNT=45; 
//    
    var FRAME_Y_MAX=300;
    var FRAME_Y_MIN=100;
//    
//    
//    
    var BIT0=0x01;
    var BIT1=0x02;
    var BIT2=0x04;
		var BIT3=0x08;
    var BIT4=0x10;
    var BIT5=0x20;
    var BIT6=0x40;
    var BIT7=0x80;
//    
//    public final static double PIXEL_WIDTH_HEIGHT_RATIO=1.6;
//    
//    
//    
//    
//    
////#############################################################################
////###################  TIA/RIOT Registers   ###################################
////#############################################################################   
//   
//    //Comments were cut-and-pasted from DASM
//    
//    
//// ==================== TIA POKE REGISTERS ===========================
var VSYNC   = 0x00;   // 0000 00x0   Vertical Sync Set-Clear
var VBLANK	= 0x01;   // xx00 00x0   Vertical Blank Set-Clear
var WSYNC	= 0x02;   // ---- ----   Wait for Horizontal Blank
var RSYNC	= 0x03;   // ---- ----   Reset Horizontal Sync Counter
var NUSIZ0	= 0x04;   //  00xx 0xxx   Number-Size player/missle 0
var NUSIZ1	= 0x05;   //  00xx 0xxx   Number-Size player/missle 1
var COLUP0	= 0x06;   //  xxxx xxx0   Color-Luminance Player 0
var COLUP1  = 0x07;   //  //  xxxx xxx0   Color-Luminance Player 1
var COLUPF  = 0x08;   //  //  xxxx xxx0   Color-Luminance Playfield
var COLUBK  = 0x09;   //  //  xxxx xxx0   Color-Luminance Background
var CTRLPF  = 0x0A;   //  00xx 0xxx   Control Playfield, Ball, Collisions
var REFP0   = 0x0B;   //  0000 x000   Reflection Player 0
var REFP1   = 0x0C;   //  0000 x000   Reflection Player 1
var PF0     = 0x0D;   //  xxxx 0000   Playfield Register Byte 0
var PF1     = 0x0E;   //  xxxx xxxx   Playfield Register Byte 1
var PF2     = 0x0F;   //  xxxx xxxx   Playfield Register Byte 2
var RESP0   = 0x10;   // ---- ----   Reset Player 0
var RESP1   = 0x11;   //---- ----   Reset Player 1
var RESM0   = 0x12;   //---- ----   Reset Missle 0
var RESM1   = 0x13;   //---- ----   Reset Missle 1
var RESBL   = 0x14;   //---- ----   Reset Ball
var AUDC0   = 0x15;   //  0000 xxxx   Audio Control 0
var AUDC1   = 0x16;   //  0000 xxxx   Audio Control 1
var AUDF0   = 0x17;   // 000x xxxx   Audio Frequency 0
var AUDF1   = 0x18;   //000x xxxx   Audio Frequency 1
var AUDV0   = 0x19;   //  0000 xxxx   Audio Volume 0
var AUDV1   = 0x1A;   //  0000 xxxx   Audio Volume 1
var GRP0    = 0x1B;   //  xxxx xxxx   Graphics Register Player 0
var GRP1    = 0x1C;   //  xxxx xxxx   Graphics Register Player 1
var ENAM0   = 0x1D;   //  0000 00x0   Graphics Enable Missle 0
var ENAM1   = 0x1E;   //  0000 00x0   Graphics Enable Missle 1
var ENABL   = 0x1F;   //  0000 00x0   Graphics Enable Ball
var HMP0    = 0x20;   //  xxxx 0000   Horizontal Motion Player 0
var HMP1    = 0x21;   //  xxxx 0000   Horizontal Motion Player 1
var HMM0    = 0x22;   //  xxxx 0000   Horizontal Motion Missle 0
var HMM1    = 0x23;   //  xxxx 0000   Horizontal Motion Missle 1
var HMBL    = 0x24;   //  xxxx 0000   Horizontal Motion Ball
var VDELP0  = 0x25;   //0000 000x   Vertical Delay Player 0
var VDELP1  = 0x26;   // 0000 000x   Vertical Delay Player 1
var VDELBL  = 0x27;   // 0000 000x   Vertical Delay Ball
var RESMP0  = 0x28;   // 0000 00x0   Reset Missle 0 to Player 0
var RESMP1  = 0x29;   //0000 00x0   Reset Missle 1 to Player 1
var HMOVE   = 0x2A;   // ---- ----   Apply Horizontal Motion
var HMCLR   = 0x2B;   //---- ----   Clear Horizontal Move Registers
var CXCLR   = 0x2C;   //---- ----   Clear Collision Latches
//    
//    
//// =========================== TIA Peek Registers =========================================
var CXM0P = 0x00; //       xx00 0000       Read Collision  M0-P1   M0-P0
var CXM1P = 0x01; //       xx00 0000                       M1-P0   M1-P1
var CXP0FB = 0x02; //       xx00 0000                       P0-PF   P0-BL
var CXP1FB = 0x03; //      xx00 0000                       P1-PF   P1-BL
var CXM0FB = 0x04; //       xx00 0000                       M0-PF   M0-BL
var CXM1FB = 0x05; //       xx00 0000                       M1-PF   M1-BL
var CXBLPF = 0x06; //       x000 0000                       BL-PF   -----
var CXPPMM = 0x07; //       xx00 0000                       P0-P1   M0-M1
var INPT0 = 0x08; //       x000 0000       Read Pot Port 0
var INPT1 = 0x09; //      x000 0000       Read Pot Port 1
var INPT2 = 0x0A; //       x000 0000       Read Pot Port 2
var INPT3 = 0x0B; //       x000 0000       Read Pot Port 3
var INPT4 = 0x0C; //		x000 0000       Read Input (Trigger) 0
var INPT5 = 0x0D; //		x000 0000       Read Input (Trigger) 1
//
// // ==================== RIOT Registers =============================
//
var SWCHA =  0x280;  //      Port A data register for joysticks: Bits 4-7 for player 1.  Bits 0-3 for player 2.
//
var SWACNT =  0x281;  //      Port A data direction register (DDR)
var SWCHB =  0x282;  //		Port B data (console switches)
var SWBCNT =  0x283;  //      Port B DDR
var INTIM =  0x284;  //		Timer output
//
var TIMINT  = 0x285;  //	
//
var TIM1T =  0x294;  //	set 1 clock interval
var TIM8T =  0x295;  //      set 8 clock interval
var TIM64T =  0x296;  //      set 64 clock interval
var T1024T =  0x297;  //      set 1024 clock interval
//
//
//
//
//
//
//
//
//
////========================== Other ===================================
//
//
//
//  //These go with myEnabledObjects etc variable in JSTIA
var BIT_P0 = 0x01;         // Bit for Player 0
var BIT_M0 = 0x02;         // Bit for Missile 0
var BIT_P1 = 0x04;         // Bit for Player 1
var BIT_M1 = 0x08;         // Bit for Missile 1
var BIT_BL = 0x10;         // Bit for Ball
var BIT_PF = 0x20;         // Bit for Playfield
var BIT_SCORE = 0x40;        // Bit for Playfield score mode
var  BIT_PRIORITY = 0x080;     // Bit for Playfield priority
//
//
//  
//
//
//
//
//    
//    
//    
//    
//  
//// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		var POKE_DELAY_TABLE = [
    0,  1,  0,  0,  8,  8,  0,  0,  0,  0,  0,  1,  1, -1, -1, -1,
    0,  0,  8,  8,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	];
//
//// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//    
//    
//// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    var HMOVE_BLANK_ENABLE_CYCLES= [
        true,  true,  true,  true,  true,  true,  true,  true,  true,  true,   // 00
        true,  true,  true,  true,  true,  true,  true,  true,  true,  true,   // 10
        true,  false, false, false, false, false, false, false, false, false,  // 20
        false, false, false, false, false, false, false, false, false, false,  // 30
        false, false, false, false, false, false, false, false, false, false,  // 40
        false, false, false, false, false, false, false, false, false, false,  // 50
        false, false, false, false, false, false, false, false, false, false,  // 60
        false, false, false, false, false, true                                // 70
    ];
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    var COMPLETE_MOTION_TABLE = [
        [ 0, -1, -2, -3, -4, -5, -6, -7,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 0, -1, -2, -3, -4, -5, -6, -7,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 0, -1, -2, -3, -4, -5, -6, -7,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 0, -1, -2, -3, -4, -5, -6, -7,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 0, -1, -2, -3, -4, -5, -6, -6,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 0, -1, -2, -3, -4, -5, -5, -5,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 0, -1, -2, -3, -4, -5, -5, -5,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 0, -1, -2, -3, -4, -4, -4, -4,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 0, -1, -2, -3, -3, -3, -3, -3,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 0, -1, -2, -2, -2, -2, -2, -2,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 0, -1, -2, -2, -2, -2, -2, -2,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 0, -1, -1, -1, -1, -1, -1, -1,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 0,  0,  0,  0,  0,  0,  0,  0,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 1,  1,  1,  1,  1,  1,  1,  1,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 1,  1,  1,  1,  1,  1,  1,  1,  8,  7,  6,  5,  4,  3,  2,  1], // HBLANK
        [ 2,  2,  2,  2,  2,  2,  2,  2,  8,  7,  6,  5,  4,  3,  2,  2], // HBLANK
        [ 3,  3,  3,  3,  3,  3,  3,  3,  8,  7,  6,  5,  4,  3,  3,  3], // HBLANK
        [ 4,  4,  4,  4,  4,  4,  4,  4,  8,  7,  6,  5,  4,  4,  4,  4], // HBLANK
        [ 4,  4,  4,  4,  4,  4,  4,  4,  8,  7,  6,  5,  4,  4,  4,  4], // HBLANK
        [ 5,  5,  5,  5,  5,  5,  5,  5,  8,  7,  6,  5,  5,  5,  5,  5], // HBLANK
        [ 6,  6,  6,  6,  6,  6,  6,  6,  8,  7,  6,  6,  6,  6,  6,  6], // HBLANK
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0,  0, -1,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0,  0, -1, -2,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0, -1, -2, -3,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0,  0, -1, -2, -3,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0,  0, -1, -2, -3, -4,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0,  0, -1, -2, -3, -4, -5,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0, -1, -2, -3, -4, -5, -6,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0,  0, -1, -2, -3, -4, -5, -6,  0,  0,  0,  0,  0,  0,  0,  0],
        [ 0, -1, -2, -3, -4, -5, -6, -7,  0,  0,  0,  0,  0,  0,  0,  0],
        [-1, -2, -3, -4, -5, -6, -7, -8,  0,  0,  0,  0,  0,  0,  0,  0],
        [-2, -3, -4, -5, -6, -7, -8, -9,  0,  0,  0,  0,  0,  0,  0, -1],
        [-2, -3, -4, -5, -6, -7, -8, -9,  0,  0,  0,  0,  0,  0,  0, -1],
        [-3, -4, -5, -6, -7, -8, -9,-10,  0,  0,  0,  0,  0,  0, -1, -2],
        [-4, -5, -6, -7, -8, -9,-10,-11,  0,  0,  0,  0,  0, -1, -2, -3],
        [-5, -6, -7, -8, -9,-10,-11,-12,  0,  0,  0,  0, -1, -2, -3, -4],
        [-5, -6, -7, -8, -9,-10,-11,-12,  0,  0,  0,  0, -1, -2, -3, -4],
        [-6, -7, -8, -9,-10,-11,-12,-13,  0,  0,  0, -1, -2, -3, -4, -5],
        [-7, -8, -9,-10,-11,-12,-13,-14,  0,  0, -1, -2, -3, -4, -5, -6],
        [-8, -9,-10,-11,-12,-13,-14,-15,  0, -1, -2, -3, -4, -5, -6, -7],
        [-8, -9,-10,-11,-12,-13,-14,-15,  0, -1, -2, -3, -4, -5, -6, -7],
        [ 0, -1, -2, -3, -4, -5, -6, -7,  8,  7,  6,  5,  4,  3,  2,  1]  // HBLANK
    ];
//    
//    
//    
//    
    var PALETTE_NTSC = [
        0x000000, 0, 0x4a4a4a, 0, 0x6f6f6f, 0, 0x8e8e8e, 0,
        0xaaaaaa, 0, 0xc0c0c0, 0, 0xd6d6d6, 0, 0xececec, 0,
        0x484800, 0, 0x69690f, 0, 0x86861d, 0, 0xa2a22a, 0,
        0xbbbb35, 0, 0xd2d240, 0, 0xe8e84a, 0, 0xfcfc54, 0,
        0x7c2c00, 0, 0x904811, 0, 0xa26221, 0, 0xb47a30, 0,
        0xc3903d, 0, 0xd2a44a, 0, 0xdfb755, 0, 0xecc860, 0,
        0x901c00, 0, 0xa33915, 0, 0xb55328, 0, 0xc66c3a, 0,
        0xd5824a, 0, 0xe39759, 0, 0xf0aa67, 0, 0xfcbc74, 0,
        0x940000, 0, 0xa71a1a, 0, 0xb83232, 0, 0xc84848, 0,
        0xd65c5c, 0, 0xe46f6f, 0, 0xf08080, 0, 0xfc9090, 0,
        0x840064, 0, 0x97197a, 0, 0xa8308f, 0, 0xb846a2, 0,
        0xc659b3, 0, 0xd46cc3, 0, 0xe07cd2, 0, 0xec8ce0, 0,
        0x500084, 0, 0x68199a, 0, 0x7d30ad, 0, 0x9246c0, 0,
        0xa459d0, 0, 0xb56ce0, 0, 0xc57cee, 0, 0xd48cfc, 0,
        0x140090, 0, 0x331aa3, 0, 0x4e32b5, 0, 0x6848c6, 0,
        0x7f5cd5, 0, 0x956fe3, 0, 0xa980f0, 0, 0xbc90fc, 0,
        0x000094, 0, 0x181aa7, 0, 0x2d32b8, 0, 0x4248c8, 0,
        0x545cd6, 0, 0x656fe4, 0, 0x7580f0, 0, 0x8490fc, 0,
        0x001c88, 0, 0x183b9d, 0, 0x2d57b0, 0, 0x4272c2, 0,
        0x548ad2, 0, 0x65a0e1, 0, 0x75b5ef, 0, 0x84c8fc, 0,
        0x003064, 0, 0x185080, 0, 0x2d6d98, 0, 0x4288b0, 0,
        0x54a0c5, 0, 0x65b7d9, 0, 0x75cceb, 0, 0x84e0fc, 0,
        0x004030, 0, 0x18624e, 0, 0x2d8169, 0, 0x429e82, 0,
        0x54b899, 0, 0x65d1ae, 0, 0x75e7c2, 0, 0x84fcd4, 0,
        0x004400, 0, 0x1a661a, 0, 0x328432, 0, 0x48a048, 0,
        0x5cba5c, 0, 0x6fd26f, 0, 0x80e880, 0, 0x90fc90, 0,
        0x143c00, 0, 0x355f18, 0, 0x527e2d, 0, 0x6e9c42, 0,
        0x87b754, 0, 0x9ed065, 0, 0xb4e775, 0, 0xc8fc84, 0,
        0x303800, 0, 0x505916, 0, 0x6d762b, 0, 0x88923e, 0,
        0xa0ab4f, 0, 0xb7c25f, 0, 0xccd86e, 0, 0xe0ec7c, 0,
        0x482c00, 0, 0x694d14, 0, 0x866a26, 0, 0xa28638, 0,
        0xbb9f47, 0, 0xd2b656, 0, 0xe8cc63, 0, 0xfce070, 0
    ];
    
    var PALETTE_PAL = [
        0x000000, 0, 0x2b2b2b, 0, 0x525252, 0, 0x767676, 0,
        0x979797, 0, 0xb6b6b6, 0, 0xd2d2d2, 0, 0xececec, 0,
        0x000000, 0, 0x2b2b2b, 0, 0x525252, 0, 0x767676, 0,
        0x979797, 0, 0xb6b6b6, 0, 0xd2d2d2, 0, 0xececec, 0,
        0x805800, 0, 0x96711a, 0, 0xab8732, 0, 0xbe9c48, 0,
        0xcfaf5c, 0, 0xdfc06f, 0, 0xeed180, 0, 0xfce090, 0,
        0x445c00, 0, 0x5e791a, 0, 0x769332, 0, 0x8cac48, 0,
        0xa0c25c, 0, 0xb3d76f, 0, 0xc4ea80, 0, 0xd4fc90, 0,
        0x703400, 0, 0x89511a, 0, 0xa06b32, 0, 0xb68448, 0,
        0xc99a5c, 0, 0xdcaf6f, 0, 0xecc280, 0, 0xfcd490, 0,
        0x006414, 0, 0x1a8035, 0, 0x329852, 0, 0x48b06e, 0,
        0x5cc587, 0, 0x6fd99e, 0, 0x80ebb4, 0, 0x90fcc8, 0,
        0x700014, 0, 0x891a35, 0, 0xa03252, 0, 0xb6486e, 0,
        0xc95c87, 0, 0xdc6f9e, 0, 0xec80b4, 0, 0xfc90c8, 0,
        0x005c5c, 0, 0x1a7676, 0, 0x328e8e, 0, 0x48a4a4, 0,
        0x5cb8b8, 0, 0x6fcbcb, 0, 0x80dcdc, 0, 0x90ecec, 0,
        0x70005c, 0, 0x841a74, 0, 0x963289, 0, 0xa8489e, 0,
        0xb75cb0, 0, 0xc66fc1, 0, 0xd380d1, 0, 0xe090e0, 0,
        0x003c70, 0, 0x195a89, 0, 0x2f75a0, 0, 0x448eb6, 0,
        0x57a5c9, 0, 0x68badc, 0, 0x79ceec, 0, 0x88e0fc, 0,
        0x580070, 0, 0x6e1a89, 0, 0x8332a0, 0, 0x9648b6, 0,
        0xa75cc9, 0, 0xb76fdc, 0, 0xc680ec, 0, 0xd490fc, 0,
        0x002070, 0, 0x193f89, 0, 0x2f5aa0, 0, 0x4474b6, 0,
        0x578bc9, 0, 0x68a1dc, 0, 0x79b5ec, 0, 0x88c8fc, 0,
        0x340080, 0, 0x4a1a96, 0, 0x5f32ab, 0, 0x7248be, 0,
        0x835ccf, 0, 0x936fdf, 0, 0xa280ee, 0, 0xb090fc, 0,
        0x000088, 0, 0x1a1a9d, 0, 0x3232b0, 0, 0x4848c2, 0,
        0x5c5cd2, 0, 0x6f6fe1, 0, 0x8080ef, 0, 0x9090fc, 0,
        0x000000, 0, 0x2b2b2b, 0, 0x525252, 0, 0x767676, 0,
        0x979797, 0, 0xb6b6b6, 0, 0xd2d2d2, 0, 0xececec, 0,
        0x000000, 0, 0x2b2b2b, 0, 0x525252, 0, 0x767676, 0,
        0x979797, 0, 0xb6b6b6, 0, 0xd2d2d2, 0, 0xececec, 0
    ];
//    
//// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//    public final static int[] PALETTE_NTSC_11 = {
//        0x000000, 0, 0x393939, 0, 0x797979, 0, 0xababab, 0,
//        0xcdcdcd, 0, 0xe6e6e6, 0, 0xf2f2f2, 0, 0xffffff, 0,
//        0x391701, 0, 0x833008, 0, 0xc85f24, 0, 0xff911d, 0,
//        0xffc51d, 0, 0xffd84c, 0, 0xfff456, 0, 0xffff98, 0,
//        0x451904, 0, 0x9f241e, 0, 0xc85122, 0, 0xff811e, 0,
//        0xff982c, 0, 0xffc545, 0, 0xffc66d, 0, 0xffe4a1, 0,
//        0x4a1704, 0, 0xb21d17, 0, 0xdf251c, 0, 0xfa5255, 0,
//        0xff706e, 0, 0xff8f8f, 0, 0xffabad, 0, 0xffc7ce, 0,
//        0x050568, 0, 0x712272, 0, 0xa532a6, 0, 0xcd3ecf, 0,
//        0xea51eb, 0, 0xfe6dff, 0, 0xff87fb, 0, 0xffa4ff, 0,
//        0x280479, 0, 0x590f90, 0, 0x8839aa, 0, 0xc04adc, 0,
//        0xe05eff, 0, 0xf27cff, 0, 0xff98ff, 0, 0xfeabff, 0,
//        0x35088a, 0, 0x500cd0, 0, 0x7945d0, 0, 0xa251d9, 0,
//        0xbe60ff, 0, 0xcc77ff, 0, 0xd790ff, 0, 0xdfaaff, 0,
//        0x051e81, 0, 0x082fca, 0, 0x444cde, 0, 0x5a68ff, 0,
//        0x7183ff, 0, 0x90a0ff, 0, 0x9fb2ff, 0, 0xc0cbff, 0,
//        0x0c048b, 0, 0x382db5, 0, 0x584fda, 0, 0x6b64ff, 0,
//        0x8a84ff, 0, 0x9998ff, 0, 0xb1aeff, 0, 0xc0c2ff, 0,
//        0x1d295a, 0, 0x1d4892, 0, 0x1c71c6, 0, 0x489bd9, 0,
//        0x55b6ff, 0, 0x8cd8ff, 0, 0x9bdfff, 0, 0xc3e9ff, 0,
//        0x2f4302, 0, 0x446103, 0, 0x3e9421, 0, 0x57ab3b, 0,
//        0x61d070, 0, 0x72f584, 0, 0x87ff97, 0, 0xadffb6, 0,
//        0x0a4108, 0, 0x10680d, 0, 0x169212, 0, 0x1cb917, 0,
//        0x21d91b, 0, 0x6ef040, 0, 0x83ff5b, 0, 0xb2ff9a, 0,
//        0x04410b, 0, 0x066611, 0, 0x088817, 0, 0x0baf1d, 0,
//        0x86d922, 0, 0x99f927, 0, 0xb7ff5b, 0, 0xdcff81, 0,
//        0x02350f, 0, 0x0c4a1c, 0, 0x4f7420, 0, 0x649228, 0,
//        0xa1b034, 0, 0xb2d241, 0, 0xd6e149, 0, 0xf2ff53, 0,
//        0x263001, 0, 0x234005, 0, 0x806931, 0, 0xaf993a, 0,
//        0xd5b543, 0, 0xe1cb38, 0, 0xe3e534, 0, 0xfbff7d, 0,
//        0x401a02, 0, 0x702408, 0, 0xab511f, 0, 0xbf7730, 0,
//        0xe19344, 0, 0xf9ad58, 0, 0xffc160, 0, 0xffcb83, 0
//    };
//    
//// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//    public final static   int[] PALETTE_PAL_11 = {
//        0x000000, 0, 0x242424, 0, 0x484848, 0, 0x6d6d6d, 0,
//        0x919191, 0, 0xb6b6b6, 0, 0xdadada, 0, 0xffffff, 0,
//        0x000000, 0, 0x242424, 0, 0x484848, 0, 0x6d6d6d, 0,
//        0x919191, 0, 0xb6b6b6, 0, 0xdadada, 0, 0xffffff, 0,
//        0x4a3700, 0, 0x705813, 0, 0x8c732a, 0, 0xa68d46, 0,
//        0xbea767, 0, 0xd4c18b, 0, 0xeadcb3, 0, 0xfff6de, 0,
//        0x284a00, 0, 0x44700f, 0, 0x5c8c21, 0, 0x74a638, 0,
//        0x8cbe51, 0, 0xa6d46e, 0, 0xc0ea8e, 0, 0xdbffb0, 0,
//        0x4a1300, 0, 0x70280f, 0, 0x8c3d21, 0, 0xa65438, 0,
//        0xbe6d51, 0, 0xd4886e, 0, 0xeaa58e, 0, 0xffc4b0, 0,
//        0x004a22, 0, 0x0f703b, 0, 0x218c52, 0, 0x38a66a, 0,
//        0x51be83, 0, 0x6ed49d, 0, 0x8eeab8, 0, 0xb0ffd4, 0,
//        0x4a0028, 0, 0x700f44, 0, 0x8c215c, 0, 0xa63874, 0,
//        0xbe518c, 0, 0xd46ea6, 0, 0xea8ec0, 0, 0xffb0db, 0,
//        0x00404a, 0, 0x0f6370, 0, 0x217e8c, 0, 0x3897a6, 0,
//        0x51afbe, 0, 0x6ec7d4, 0, 0x8edeea, 0, 0xb0f4ff, 0,
//        0x43002c, 0, 0x650f4b, 0, 0x7e2165, 0, 0x953880, 0,
//        0xa6519a, 0, 0xbf6eb7, 0, 0xd38ed3, 0, 0xe5b0f1, 0,
//        0x001d4a, 0, 0x0f3870, 0, 0x21538c, 0, 0x386ea6, 0,
//        0x518dbe, 0, 0x6ea8d4, 0, 0x8ec8ea, 0, 0xb0e9ff, 0,
//        0x37004a, 0, 0x570f70, 0, 0x70218c, 0, 0x8938a6, 0,
//        0xa151be, 0, 0xba6ed4, 0, 0xd28eea, 0, 0xeab0ff, 0,
//        0x00184a, 0, 0x0f2e70, 0, 0x21448c, 0, 0x385ba6, 0,
//        0x5174be, 0, 0x6e8fd4, 0, 0x8eabea, 0, 0xb0c9ff, 0,
//        0x13004a, 0, 0x280f70, 0, 0x3d218c, 0, 0x5438a6, 0,
//        0x6d51be, 0, 0x886ed4, 0, 0xa58eea, 0, 0xc4b0ff, 0,
//        0x00014a, 0, 0x0f1170, 0, 0x21248c, 0, 0x383aa6, 0,
//        0x5153be, 0, 0x6e70d4, 0, 0x8e8fea, 0, 0xb0b2ff, 0,
//        0x000000, 0, 0x242424, 0, 0x484848, 0, 0x6d6d6d, 0,
//        0x919191, 0, 0xb6b6b6, 0, 0xdadada, 0, 0xffffff, 0,
//        0x000000, 0, 0x242424, 0, 0x484848, 0, 0x6d6d6d, 0,
//        0x919191, 0, 0xb6b6b6, 0, 0xdadada, 0, 0xffffff, 0
//    };
//    
//// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//    public final static   int[] PALETTE_NTSC_Z26 = {
//        0x000000, 0, 0x505050, 0, 0x646464, 0, 0x787878, 0,
//        0x8c8c8c, 0, 0xa0a0a0, 0, 0xb4b4b4, 0, 0xc8c8c8, 0,
//        0x445400, 0, 0x586800, 0, 0x6c7c00, 0, 0x809000, 0,
//        0x94a414, 0, 0xa8b828, 0, 0xbccc3c, 0, 0xd0e050, 0,
//        0x673900, 0, 0x7b4d00, 0, 0x8f6100, 0, 0xa37513, 0,
//        0xb78927, 0, 0xcb9d3b, 0, 0xdfb14f, 0, 0xf3c563, 0,
//        0x7b2504, 0, 0x8f3918, 0, 0xa34d2c, 0, 0xb76140, 0,
//        0xcb7554, 0, 0xdf8968, 0, 0xf39d7c, 0, 0xffb190, 0,
//        0x7d122c, 0, 0x912640, 0, 0xa53a54, 0, 0xb94e68, 0,
//        0xcd627c, 0, 0xe17690, 0, 0xf58aa4, 0, 0xff9eb8, 0,
//        0x730871, 0, 0x871c85, 0, 0x9b3099, 0, 0xaf44ad, 0,
//        0xc358c1, 0, 0xd76cd5, 0, 0xeb80e9, 0, 0xff94fd, 0,
//        0x5d0b92, 0, 0x711fa6, 0, 0x8533ba, 0, 0x9947ce, 0,
//        0xad5be2, 0, 0xc16ff6, 0, 0xd583ff, 0, 0xe997ff, 0,
//        0x401599, 0, 0x5429ad, 0, 0x683dc1, 0, 0x7c51d5, 0,
//        0x9065e9, 0, 0xa479fd, 0, 0xb88dff, 0, 0xcca1ff, 0,
//        0x252593, 0, 0x3939a7, 0, 0x4d4dbb, 0, 0x6161cf, 0,
//        0x7575e3, 0, 0x8989f7, 0, 0x9d9dff, 0, 0xb1b1ff, 0,
//        0x0f3480, 0, 0x234894, 0, 0x375ca8, 0, 0x4b70bc, 0,
//        0x5f84d0, 0, 0x7398e4, 0, 0x87acf8, 0, 0x9bc0ff, 0,
//        0x04425a, 0, 0x18566e, 0, 0x2c6a82, 0, 0x407e96, 0,
//        0x5492aa, 0, 0x68a6be, 0, 0x7cbad2, 0, 0x90cee6, 0,
//        0x044f30, 0, 0x186344, 0, 0x2c7758, 0, 0x408b6c, 0,
//        0x549f80, 0, 0x68b394, 0, 0x7cc7a8, 0, 0x90dbbc, 0,
//        0x0f550a, 0, 0x23691e, 0, 0x377d32, 0, 0x4b9146, 0,
//        0x5fa55a, 0, 0x73b96e, 0, 0x87cd82, 0, 0x9be196, 0,
//        0x1f5100, 0, 0x336505, 0, 0x477919, 0, 0x5b8d2d, 0,
//        0x6fa141, 0, 0x83b555, 0, 0x97c969, 0, 0xabdd7d, 0,
//        0x344600, 0, 0x485a00, 0, 0x5c6e14, 0, 0x708228, 0,
//        0x84963c, 0, 0x98aa50, 0, 0xacbe64, 0, 0xc0d278, 0,
//        0x463e00, 0, 0x5a5205, 0, 0x6e6619, 0, 0x827a2d, 0,
//        0x968e41, 0, 0xaaa255, 0, 0xbeb669, 0, 0xd2ca7d, 0
//    };
//    
//// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//    public final static  int[] PALETTE_PAL_Z26 = {
//        0x000000, 0, 0x4c4c4c, 0, 0x606060, 0, 0x747474, 0,
//        0x888888, 0, 0x9c9c9c, 0, 0xb0b0b0, 0, 0xc4c4c4, 0,
//        0x000000, 0, 0x4c4c4c, 0, 0x606060, 0, 0x747474, 0,
//        0x888888, 0, 0x9c9c9c, 0, 0xb0b0b0, 0, 0xc4c4c4, 0,
//        0x533a00, 0, 0x674e00, 0, 0x7b6203, 0, 0x8f7617, 0,
//        0xa38a2b, 0, 0xb79e3f, 0, 0xcbb253, 0, 0xdfc667, 0,
//        0x1b5800, 0, 0x2f6c00, 0, 0x438001, 0, 0x579415, 0,
//        0x6ba829, 0, 0x7fbc3d, 0, 0x93d051, 0, 0xa7e465, 0,
//        0x6a2900, 0, 0x7e3d12, 0, 0x925126, 0, 0xa6653a, 0,
//        0xba794e, 0, 0xce8d62, 0, 0xe2a176, 0, 0xf6b58a, 0,
//        0x075b00, 0, 0x1b6f11, 0, 0x2f8325, 0, 0x439739, 0,
//        0x57ab4d, 0, 0x6bbf61, 0, 0x7fd375, 0, 0x93e789, 0,
//        0x741b2f, 0, 0x882f43, 0, 0x9c4357, 0, 0xb0576b, 0,
//        0xc46b7f, 0, 0xd87f93, 0, 0xec93a7, 0, 0xffa7bb, 0,
//        0x00572e, 0, 0x106b42, 0, 0x247f56, 0, 0x38936a, 0,
//        0x4ca77e, 0, 0x60bb92, 0, 0x74cfa6, 0, 0x88e3ba, 0,
//        0x6d165f, 0, 0x812a73, 0, 0x953e87, 0, 0xa9529b, 0,
//        0xbd66af, 0, 0xd17ac3, 0, 0xe58ed7, 0, 0xf9a2eb, 0,
//        0x014c5e, 0, 0x156072, 0, 0x297486, 0, 0x3d889a, 0,
//        0x519cae, 0, 0x65b0c2, 0, 0x79c4d6, 0, 0x8dd8ea, 0,
//        0x5f1588, 0, 0x73299c, 0, 0x873db0, 0, 0x9b51c4, 0,
//        0xaf65d8, 0, 0xc379ec, 0, 0xd78dff, 0, 0xeba1ff, 0,
//        0x123b87, 0, 0x264f9b, 0, 0x3a63af, 0, 0x4e77c3, 0,
//        0x628bd7, 0, 0x769feb, 0, 0x8ab3ff, 0, 0x9ec7ff, 0,
//        0x451e9d, 0, 0x5932b1, 0, 0x6d46c5, 0, 0x815ad9, 0,
//        0x956eed, 0, 0xa982ff, 0, 0xbd96ff, 0, 0xd1aaff, 0,
//        0x2a2b9e, 0, 0x3e3fb2, 0, 0x5253c6, 0, 0x6667da, 0,
//        0x7a7bee, 0, 0x8e8fff, 0, 0xa2a3ff, 0, 0xb6b7ff, 0,
//        0x000000, 0, 0x4c4c4c, 0, 0x606060, 0, 0x747474, 0,
//        0x888888, 0, 0x9c9c9c, 0, 0xb0b0b0, 0, 0xc4c4c4, 0,
//        0x000000, 0, 0x4c4c4c, 0, 0x606060, 0, 0x747474, 0,
//        0x888888, 0, 0x9c9c9c, 0, 0xb0b0b0, 0, 0xc4c4c4, 0
//    };
//    
//    
//    
//    
//    
//    
//    
//    
//    
//    
//    
//    
//    
//    
//    
//    
//// ========================== TIA Tables ==================================    
//  //These are the mask tables, and they are used in computing what to draw.  They are filled
//    //by the corresponding compute...() methods, which are called exactly once (statically)
//    //in the static init method.  Consult the compute method to determine what
//    //each of the array dimensions means
    var BALL_MASK_TABLE=new Array(4);
		for(var i=0;i<4;i++)BALL_MASK_TABLE[i] = array2d(4,320);
    var COLLISION_TABLE=new Array(64);
    var DISABLED_MASK_TABLE= new Array(640);
    var MISSILE_MASK_TABLE=array2d(4, 8);
		for(var i=0;i<4;i++)for(var j=0;j<8;j++)MISSILE_MASK_TABLE[i][j]=array2d(4, 320);
	//	new boolean[4][8][4][320];
 	  var PLAYER_MASK_TABLE=array2d(4, 2);
		//console.log(PLAYER_MASK_TABLE);
		for(var i=0;i<4;i++)for(var j=0;j<2;j++)PLAYER_MASK_TABLE[i][j] = array2d(8,320);
		//new int[4][2][8][320];
	    var  PLAYER_POSITION_RESET_WHEN_TABLE=[];
			for(var i =0;i<8;i++)PLAYER_POSITION_RESET_WHEN_TABLE[i] = array2d(160,160);

    var PLAYER_REFLECT_TABLE=new Array(256);
    var PLAYFIELD_TABLE=array2d(2, 256);
    var PRIORITY_ENCODER=array2d(2, 256);
    
    
    
    
    
        for(var i = 0; i < 640; ++i) { DISABLED_MASK_TABLE[i] = 0;}
     /*   
        computeBallMaskTable();
        computeCollisionTable();
        computeMissileMaskTable();
        computePlayerMaskTable();
        computePlayerPositionResetWhenTable();
        computePlayerReflectTable();
        computePlayfieldMaskTable();
        computePriorityEncoder();
       // debugDumpArray(PLAYFIELD_TABLE);
    }//end : STATIC INIT    
    
    
    
    
    
    
    
    
    
   */ 
    
    
    
    
    
    
    
    
    
    /** Creates a new instance of JSConstants */
    
     /**
     * (A method that allowed me to type less when converting C++ to Java. It makes for
     * more readable code as well. -JLA)
     * @param aValue an integer
     * @return the boolean equivalent (in C++) of the integer
     */
    this.bool = function(aValue) {
        if (aValue==0) return false;
        else return true;
    }
    
    
      //======================== STATIC COMPUTE METHODS ==========================
//    private static void computePriorityEncoder() {
        for(var x = 0; x < 2; ++x) {
            for(var enabled = 0; enabled < 256; ++enabled) {
                if((enabled & BIT_PRIORITY)!=0) {
                    var color = 0;
                    
                    if((enabled & (BIT_P1 | BIT_M1)) != 0)
                        color = 3;
                    if((enabled & (BIT_P0 | BIT_M0)) != 0)
                        color = 2;
                    if((enabled & BIT_BL) != 0)
                        color = 1;
                    if((enabled & BIT_PF) != 0)
                        color = 1;  // NOTE: Playfield has priority so BIT_SCORE isn't used
                    
                    PRIORITY_ENCODER[x][enabled] = color;
                } else {
                    var color = 0;
                    
                    if((enabled & BIT_BL) != 0)
                        color = 1;
                    if((enabled & BIT_PF) != 0)
                        color = (((enabled & BIT_SCORE)!=0)? ((x == 0) ? 2 : 3) : 1) & 0xFF;
                    if((enabled & (BIT_P1 | BIT_M1)) != 0)
                        color = ((color != 2) ? 3 : 2) & 0xFF;
                    if((enabled & (BIT_P0 | BIT_M0)) != 0)
                        color = 2;
                    
                    PRIORITY_ENCODER[x][enabled] = color;
                }//end : else
            }//end : for enabled loop
        }//end : for x loop
  //  }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//    private static void computeBallMaskTable() {
        // First, calculate masks for alignment 0
        for(var size = 0; size < 4; ++size) {
            var x=0;
            // Set all of the masks to false to start with
            for(x = 0; x < CLOCKS_PER_LINE_VISIBLE; ++x)  { BALL_MASK_TABLE[0][size][x] = false;  }
            
            // Set the necessary fields true
            for(x = 0; x < CLOCKS_PER_LINE_VISIBLE + 8; ++x) {
                if((x >= 0) && (x < (1 << size))) {
                    BALL_MASK_TABLE[0][size][x % CLOCKS_PER_LINE_VISIBLE] = true;
                }//end : x within specified range
            }//end : for x loop
            // Copy fields into the wrap-around area of the mask
            for(x = 0; x < CLOCKS_PER_LINE_VISIBLE; ++x) { BALL_MASK_TABLE[0][size][x + CLOCKS_PER_LINE_VISIBLE] = BALL_MASK_TABLE[0][size][x];    }
            
        }//end : for size loop
        
        // Now, copy data for alignments of 1, 2 and 3
        for(var align = 1; align < 4; ++align) {
            for(var size = 0; size < 4; ++size) {
                for(var x = 0; x < 320; ++x) {
                    BALL_MASK_TABLE[align][size][x] =
                            BALL_MASK_TABLE[0][size][(x + 320 - align) % 320];
                }//end : for x loop
            }//end : for size loop
        }//end : for align loop
    //}//::
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//    private static  void computeCollisionTable() {
        for(var i = 0; i < 64; ++i) {
            COLLISION_TABLE[i] = 0;
            
            if(bool(i & BIT_M0) && bool(i & BIT_P1))    // M0-P1
                COLLISION_TABLE[i] |= 0x0001;
            
            if(bool(i & BIT_M0) && bool(i & BIT_P0))    // M0-P0
                COLLISION_TABLE[i] |= 0x0002;
            
            if(bool(i & BIT_M1) && bool(i & BIT_P0))    // M1-P0
                COLLISION_TABLE[i] |= 0x0004;
            
            if(bool(i & BIT_M1) && bool(i & BIT_P1))    // M1-P1
                COLLISION_TABLE[i] |= 0x0008;
            
            if(bool(i & BIT_P0) && bool(i & BIT_PF))    // P0-PF
                COLLISION_TABLE[i] |= 0x0010;
            
            if(bool(i & BIT_P0) && bool(i & BIT_BL))    // P0-BL
                COLLISION_TABLE[i] |= 0x0020;
            
            if(bool(i & BIT_P1) && bool(i & BIT_PF))    // P1-PF
                COLLISION_TABLE[i] |= 0x0040;
            
            if(bool(i & BIT_P1) && bool(i & BIT_BL))    // P1-BL
                COLLISION_TABLE[i] |= 0x0080;
            
            if(bool(i & BIT_M0) && bool(i & BIT_PF))    // M0-PF
                COLLISION_TABLE[i] |= 0x0100;
            
            if(bool(i & BIT_M0) && bool(i & BIT_BL))    // M0-BL
                COLLISION_TABLE[i] |= 0x0200;
            
            if(bool(i & BIT_M1) && bool(i & BIT_PF))    // M1-PF
                COLLISION_TABLE[i] |= 0x0400;
            
            if(bool(i & BIT_M1) && bool(i & BIT_BL))    // M1-BL
                COLLISION_TABLE[i] |= 0x0800;
            
            if(bool(i & BIT_BL) && bool(i & BIT_PF))    // BL-PF
                COLLISION_TABLE[i] |= 0x1000;
            
            if(bool(i & BIT_P0) && bool(i & BIT_P1))    // P0-P1
                COLLISION_TABLE[i] |= 0x2000;
            
            if(bool(i & BIT_M0) && bool(i & BIT_M1))    // M0-M1
                COLLISION_TABLE[i] |= 0x4000;
        }//end : for i loop
//    }//::
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //  private static  void computeMissileMaskTable() {
        // First, calculate masks for alignment 0
        var x, size, number;
        
        // Clear the missile table to start with
        for(number = 0; number < 8; ++number)
            for(size = 0; size < 4; ++size)
                for(x = 0; x < CLOCKS_PER_LINE_VISIBLE; ++x)
                    MISSILE_MASK_TABLE[0][number][size][x] = false;
        
        for(number = 0; number < 8; ++number) {
            for(size = 0; size < 4; ++size) {
                for(x = 0; x < CLOCKS_PER_LINE_VISIBLE + 72; ++x) {
                    // Only one copy of the missile
                    if((number == 0x00) || (number == 0x05) || (number == 0x07)) {
                        if((x >= 0) && (x < (1 << size)))
                            MISSILE_MASK_TABLE[0][number][size][x % CLOCKS_PER_LINE_VISIBLE] = true;
                    }
                    // Two copies - close
                    else if(number == 0x01) {
                        if((x >= 0) && (x < (1 << size)))
                            MISSILE_MASK_TABLE[0][number][size][x % CLOCKS_PER_LINE_VISIBLE] = true;
                        else if(((x - 16) >= 0) && ((x - 16) < (1 << size)))
                            MISSILE_MASK_TABLE[0][number][size][x % CLOCKS_PER_LINE_VISIBLE] = true;
                    }
                    // Two copies - medium
                    else if(number == 0x02) {
                        if((x >= 0) && (x < (1 << size)))
                            MISSILE_MASK_TABLE[0][number][size][x % CLOCKS_PER_LINE_VISIBLE] = true;
                        else if(((x - 32) >= 0) && ((x - 32) < (1 << size)))
                            MISSILE_MASK_TABLE[0][number][size][x % CLOCKS_PER_LINE_VISIBLE] = true;
                    }
                    // Three copies - close
                    else if(number == 0x03) {
                        if((x >= 0) && (x < (1 << size)))
                            MISSILE_MASK_TABLE[0][number][size][x % CLOCKS_PER_LINE_VISIBLE] = true;
                        else if(((x - 16) >= 0) && ((x - 16) < (1 << size)))
                            MISSILE_MASK_TABLE[0][number][size][x % CLOCKS_PER_LINE_VISIBLE] = true;
                        else if(((x - 32) >= 0) && ((x - 32) < (1 << size)))
                            MISSILE_MASK_TABLE[0][number][size][x % CLOCKS_PER_LINE_VISIBLE] = true;
                    }
                    // Two copies - wide
                    else if(number == 0x04) {
                        if((x >= 0) && (x < (1 << size)))
                            MISSILE_MASK_TABLE[0][number][size][x % CLOCKS_PER_LINE_VISIBLE] = true;
                        else if(((x - 64) >= 0) && ((x - 64) < (1 << size)))
                            MISSILE_MASK_TABLE[0][number][size][x % CLOCKS_PER_LINE_VISIBLE] = true;
                    }
                    // Three copies - medium
                    else if(number == 0x06) {
                        if((x >= 0) && (x < (1 << size)))
                            MISSILE_MASK_TABLE[0][number][size][x % CLOCKS_PER_LINE_VISIBLE] = true;
                        else if(((x - 32) >= 0) && ((x - 32) < (1 << size)))
                            MISSILE_MASK_TABLE[0][number][size][x % CLOCKS_PER_LINE_VISIBLE] = true;
                        else if(((x - 64) >= 0) && ((x - 64) < (1 << size)))
                            MISSILE_MASK_TABLE[0][number][size][x % CLOCKS_PER_LINE_VISIBLE] = true;
                    }
                }
                
                // Copy data into wrap-around area
                for(x = 0; x < CLOCKS_PER_LINE_VISIBLE; ++x)
                    MISSILE_MASK_TABLE[0][number][size][x + CLOCKS_PER_LINE_VISIBLE] =
                            MISSILE_MASK_TABLE[0][number][size][x];
            }
        }
        
        // Now, copy data for alignments of 1, 2 and 3
        for(var align = 1; align < 4; ++align) {
            for(number = 0; number < 8; ++number) {
                for(size = 0; size < 4; ++size) {
                    for(x = 0; x < 320; ++x) {
                        MISSILE_MASK_TABLE[align][number][size][x] =
                                MISSILE_MASK_TABLE[0][number][size][(x + 320 - align) % 320];
                    }//end : for x loop
                }//end : for size loop
            }//end : for number loop
        }//end : for align loop
//    }//::
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //  private static void computePlayerMaskTable() {
        // First, calculate masks for alignment 0
        var x, enable, mode;
        
        // Set the player mask table to all zeros
        for(enable = 0; enable < 2; ++enable)
            for(mode = 0; mode < 8; ++mode)
                for(x = 0; x < CLOCKS_PER_LINE_VISIBLE; ++x)
                    PLAYER_MASK_TABLE[0][enable][mode][x] = 0x00;
        
        // Now, compute the player mask table
        for(enable = 0; enable < 2; ++enable) {
            for(mode = 0; mode < 8; ++mode) {
                for(x = 0; x < CLOCKS_PER_LINE_VISIBLE + 72; ++x) {
                    if(mode == 0x00) {
                        if((enable == 0) && (x >= 0) && (x < 8))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = (0x80 >> x) ;
                    } else if(mode == 0x01) {
                        if((enable == 0) && (x >= 0) && (x < 8))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = 0x80 >> x;
                        else if(((x - 16) >= 0) && ((x - 16) < 8))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = 0x80 >> (x - 16);
                    } else if(mode == 0x02) {
                        if((enable == 0) && (x >= 0) && (x < 8))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = 0x80 >> x;
                        else if(((x - 32) >= 0) && ((x - 32) < 8))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = 0x80 >> (x - 32);
                    } else if(mode == 0x03) {
                        if((enable == 0) && (x >= 0) && (x < 8))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = 0x80 >> x;
                        else if(((x - 16) >= 0) && ((x - 16) < 8))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = 0x80 >> (x - 16);
                        else if(((x - 32) >= 0) && ((x - 32) < 8))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = 0x80 >> (x - 32);
                    } else if(mode == 0x04) {
                        if((enable == 0) && (x >= 0) && (x < 8))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = 0x80 >> x;
                        else if(((x - 64) >= 0) && ((x - 64) < 8))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = 0x80 >> (x - 64);
                    } else if(mode == 0x05) {
                        // For some reason in double size mode the player's output
                        // is delayed by one pixel thus we use > instead of >=
                        if((enable == 0) && (x > 0) && (x <= 16))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = 0x80 >> ((x - 1)/2);
                    } else if(mode == 0x06) {
                        if((enable == 0) && (x >= 0) && (x < 8))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = 0x80 >> x;
                        else if(((x - 32) >= 0) && ((x - 32) < 8))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = 0x80 >> (x - 32);
                        else if(((x - 64) >= 0) && ((x - 64) < 8))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = 0x80 >> (x - 64);
                    } else if(mode == 0x07) {
                        // For some reason in quad size mode the player's output
                        // is delayed by one pixel thus we use > instead of >=
                        if((enable == 0) && (x > 0) && (x <= 32))
                            PLAYER_MASK_TABLE[0][enable][mode][x % CLOCKS_PER_LINE_VISIBLE] = 0x80 >> ((x - 1)/4);
                    }
                }
                
                // Copy data into wrap-around area
                for(x = 0; x < CLOCKS_PER_LINE_VISIBLE; ++x) {
                    PLAYER_MASK_TABLE[0][enable][mode][x + CLOCKS_PER_LINE_VISIBLE] =
                            PLAYER_MASK_TABLE[0][enable][mode][x];
                }
            }
        }
        
        // Now, copy data for alignments of 1, 2 and 3
        for(var align = 1; align < 4; ++align) {
            for(enable = 0; enable < 2; ++enable) {
                for(mode = 0; mode < 8; ++mode) {
                    for(x = 0; x < 320; ++x) {
                        PLAYER_MASK_TABLE[align][enable][mode][x] =
                                PLAYER_MASK_TABLE[0][enable][mode][(x + 320 - align) % 320];
                    }
                }
            }
        }
//    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //  private static void computePlayerPositionResetWhenTable() {
        var mode, oldx, newx;
        
        // Loop through all player modes, all old player positions, and all new
        // player positions and determine where the new position is located:
        // 1 means the new position is within the display of an old copy of the
        // player, -1 means the new position is within the delay portion of an
        // old copy of the player, and 0 means it's neither of these two
        for(mode = 0; mode < 8; ++mode) {
            for(oldx = 0; oldx < CLOCKS_PER_LINE_VISIBLE; ++oldx) {
                // Set everything to 0 for non-delay/non-display section
                for(newx = 0; newx < CLOCKS_PER_LINE_VISIBLE; ++newx) {
                    PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx] = 0;
                }
                
                // Now, we'll set the entries for non-delay/non-display section
                for(newx = 0; newx < CLOCKS_PER_LINE_VISIBLE + 72 + 5; ++newx) {
                    if(mode == 0x00) {
                        if((newx >= oldx) && (newx < (oldx + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        
                        if((newx >= oldx + 4) && (newx < (oldx + 4 + 8)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                    } else if(mode == 0x01) {
                        if((newx >= oldx) && (newx < (oldx + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        else if((newx >= (oldx + 16)) && (newx < (oldx + 16 + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        
                        if((newx >= oldx + 4) && (newx < (oldx + 4 + 8)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                        else if((newx >= oldx + 16 + 4) && (newx < (oldx + 16 + 4 + 8)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                    } else if(mode == 0x02) {
                        if((newx >= oldx) && (newx < (oldx + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        else if((newx >= (oldx + 32)) && (newx < (oldx + 32 + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        
                        if((newx >= oldx + 4) && (newx < (oldx + 4 + 8)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                        else if((newx >= oldx + 32 + 4) && (newx < (oldx + 32 + 4 + 8)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                    } else if(mode == 0x03) {
                        if((newx >= oldx) && (newx < (oldx + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        else if((newx >= (oldx + 16)) && (newx < (oldx + 16 + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        else if((newx >= (oldx + 32)) && (newx < (oldx + 32 + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        
                        if((newx >= oldx + 4) && (newx < (oldx + 4 + 8)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                        else if((newx >= oldx + 16 + 4) && (newx < (oldx + 16 + 4 + 8)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                        else if((newx >= oldx + 32 + 4) && (newx < (oldx + 32 + 4 + 8)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                    } else if(mode == 0x04) {
                        if((newx >= oldx) && (newx < (oldx + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        else if((newx >= (oldx + 64)) && (newx < (oldx + 64 + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        
                        if((newx >= oldx + 4) && (newx < (oldx + 4 + 8)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                        else if((newx >= oldx + 64 + 4) && (newx < (oldx + 64 + 4 + 8)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                    } else if(mode == 0x05) {
                        if((newx >= oldx) && (newx < (oldx + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        
                        if((newx >= oldx + 4) && (newx < (oldx + 4 + 16)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                    } else if(mode == 0x06) {
                        if((newx >= oldx) && (newx < (oldx + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        else if((newx >= (oldx + 32)) && (newx < (oldx + 32 + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        else if((newx >= (oldx + 64)) && (newx < (oldx + 64 + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        
                        if((newx >= oldx + 4) && (newx < (oldx + 4 + 8)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                        else if((newx >= oldx + 32 + 4) && (newx < (oldx + 32 + 4 + 8)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                        else if((newx >= oldx + 64 + 4) && (newx < (oldx + 64 + 4 + 8)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                    } else if(mode == 0x07) {
                        if((newx >= oldx) && (newx < (oldx + 4)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = -1;
                        
                        if((newx >= oldx + 4) && (newx < (oldx + 4 + 32)))
                            PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx % CLOCKS_PER_LINE_VISIBLE] = 1;
                    }
                }
                
                // Let's do a sanity check on our table entries
                var s1 = 0, s2 = 0;
                for(newx = 0; newx < CLOCKS_PER_LINE_VISIBLE; ++newx) {
                    if(PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx] == -1)
                        ++s1;
                    if(PLAYER_POSITION_RESET_WHEN_TABLE[mode][oldx][newx] == 1)
                        ++s2;
                }
                assert((s1 % 4 == 0) && (s2 % 8 == 0));
            }
        }
//    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // private static   void computePlayerReflectTable() {
        for(var i = 0; i < 256; ++i) {
            var r = 0;
            
            for(var t = 1; t <= 128; t *= 2) {
                r = ((r << 1) | (bool(i & t) ? 0x01 : 0x00)&0xFF);
            }
            
            PLAYER_REFLECT_TABLE[i] = r;
        }
//    }
    
    
  /*  private static void debugDumpArray(int[][] aArray)
    {
       int zYCount=aArray[0].length;
       int zXCount=aArray.length;
       for (int i_x=0; i_x<zXCount; i_x++)
       {
           for (int i_y=0; i_y<zYCount; i_y++)
           {
               System.out.println("[" + i_x + "][" + i_y + "] = " + Integer.toBinaryString(aArray[i_x][i_y]));
           }
       }
    }*/
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//    private static  void computePlayfieldMaskTable() {
        var x;
        
        // Compute playfield mask table for non-reflected mode
        for(x = 0; x < CLOCKS_PER_LINE_VISIBLE; ++x) {
            if(x < 16)
                PLAYFIELD_TABLE[0][x] = 0x00001 << (x / CLOCKS_PER_PLAYFIELD_BIT); //0-15
            else if(x < 48)
                PLAYFIELD_TABLE[0][x] = 0x00800 >> ((x - 16) / CLOCKS_PER_PLAYFIELD_BIT); //16-47
            else if(x < 80)
                PLAYFIELD_TABLE[0][x] = 0x01000 << ((x - 48) / CLOCKS_PER_PLAYFIELD_BIT); //48-79 
            else if(x < 96)
                PLAYFIELD_TABLE[0][x] = 0x00001 << ((x - 80) / CLOCKS_PER_PLAYFIELD_BIT); //80-95
            else if(x < 128)
                PLAYFIELD_TABLE[0][x] = 0x00800 >> ((x - 96) / CLOCKS_PER_PLAYFIELD_BIT); //96-127
            else if(x < 160)
                PLAYFIELD_TABLE[0][x] = 0x01000 << ((x - 128) / CLOCKS_PER_PLAYFIELD_BIT); //128-159
        }
        
        // Compute playfield mask table for reflected mode
        for(x = 0; x < 160; ++x) {
            if(x < 16)
                PLAYFIELD_TABLE[1][x] = 0x00001 << (x / CLOCKS_PER_PLAYFIELD_BIT);
            else if(x < 48)
                PLAYFIELD_TABLE[1][x] = 0x00800 >> ((x - 16) / CLOCKS_PER_PLAYFIELD_BIT);
            else if(x < 80)
                PLAYFIELD_TABLE[1][x] = 0x01000 << ((x - 48) / CLOCKS_PER_PLAYFIELD_BIT);
            else if(x < 112)
                PLAYFIELD_TABLE[1][x] = 0x80000 >> ((x - 80) / CLOCKS_PER_PLAYFIELD_BIT);
            else if(x < 144)
                PLAYFIELD_TABLE[1][x] = 0x00010 << ((x - 112) / CLOCKS_PER_PLAYFIELD_BIT);
            else if(x < 160)
                PLAYFIELD_TABLE[1][x] = 0x00008 >> ((x - 144) / CLOCKS_PER_PLAYFIELD_BIT);
        }
    //}
    
    
    
    
//    
////#############################################################################
////###################  ENUMs                ###################################
////#############################################################################
//    
		
		function csm(a, b){
			return {
				getIndex : function(){
					return a;
				},
				getBitMask : function(){
					return b;
				}
			};
		}

		ConsoleSwitch = {
			SWITCH_RESET : csm(0, BIT0),
			SWITCH_SELECT : csm(1, BIT1),
			SWITCH_BW : csm(2, BIT3),
			SWITCH_DIFFICULTY_P0 :  csm(3, BIT6),
			SWITCH_DIFFICULTY_P1  : csm(4, BIT7)
		};
		/*
       SWITCH_RESET(0, BIT0), 
       SWITCH_SELECT(1, BIT1),
       SWITCH_BW(2, BIT3),
       SWITCH_DIFFICULTY_P0(3, BIT6),
       SWITCH_DIFFICULTY_P1(4, BIT7);
       
      private final int myIndex;
      private final int myBitMask;
      private ConsoleSwitch(int aIndex, int aBitMask) 
      {  myIndex=aIndex;
         myBitMask=aBitMask;}
      public int getIndex() {return myIndex; }   
      public int getBitMask() {return myBitMask;}
    };*/
//    
//    
//  
		function dfm(a, b){
			return {
				getDisplayRate : function(){return a;}
				,getDisplayPalette : function(){return b;}
			};
		}

    DisplayFormat  = {
			NTSC : dfm(60, PALETTE_NTSC),
			PAL : dfm(50, PALETTE_PAL),
			PAL60 : dfm(60, PALETTE_PAL)
		};
/*
      NTSC(60, PALETTE_NTSC),
      PAL(50, PALETTE_PAL),
      PAL60 (60, PALETTE_PAL);
      
      private final int myDisplayRate;
      private final int[] myDisplayPalette;
      private DisplayFormat(int aDisplayRate, int[] aDisplayPalette) 
      { 
          myDisplayRate=aDisplayRate; 
          myDisplayPalette=aDisplayPalette;
      }
      public int getDisplayRate() { return myDisplayRate; }
      public int[] getDisplayPalette() { return myDisplayPalette; }
        
    };*/
  //   public final static String PROP_DISPLAY_PAL="PAL";   
  //  public final static String PROP_DISPLAY_PAL60="PAL60";
   // public final static String PROP_DISPLAY_NTSC="NTSC";
//    
//    
//    
//    
//    
//    
//    
//    
//    
//    
//    
//    
//}

function Cartridge() /* implements IfcDevice */
{
    this.serialVersionUID = "7979700597113264401L";
    //  AUTODETECT="AUTO-DETECT";
    
    this.TYPE_2K="2K";
    this.TYPE_4K="4K";
    this.TYPE_F8="F8";
    this.TYPE_F8SWAPPED="F8 swapped";
    this.TYPE_F8SC="F8SC";
    this.TYPE_FASC="FASC";
    this.TYPE_F6="F6";
    this.TYPE_F6SC="F6SC";
    this.TYPE_F4="F4";
    this.TYPE_FE="FE";
    this.TYPE_DPC="DPC";
    this.TYPE_E0="E0";
    this.TYPE_E7="E7";
    this.TYPE_3F="3F";
    this.TYPE_F4SC="F4SC";
    
    
    this.mySystem=null;
    this.myBankLocked=false;
    this.myMD5="";
 
    this.lockBank = function()
		{ 
			myBankLocked = true;  
		};
    this.unlockBank = function() 
		{ 
			myBankLocked = false; 
		};
		
		//unlockBank(); /* Constructor */

    this.getMD5 = function(){ return this. myMD5; };
    this.setMD5 = function(aMD5){ this.myMD5=aMD5; };
    
    this.myConsole=null;
    this.setConsole = function(aConsole) { myConsole=aConsole; };
    
  	this.systemCyclesReset = function() {    };
    
    
    /**
     * Converts a byte array to an int array.  ROMs are stored as bytes, but JStella
     * works with them as ints.  So conversion must occur after loading the data from
     * a disk, etc.
     * @param aByteArray a byte array
     * @return an int array
     */
    this.toIntArray = function(aByteArray) {
        var zReturn= []; 
				var length = aByteArray.length;
        for (var i=0; i<length; i++) {
            zReturn[i]=(aByteArray[i]) & 0xFF;  //The 0xFF mask makes sure that the new int is positive unsigned version
        }
        return zReturn;
    };
    
    this.toByteArray = function(aIntArray) {
        var zReturn= [];
				var length = aIntArray.length;
        for (var i=0; i<length; i++) {
            zReturn[i]=aIntArray[i];
        }
        return zReturn;
    }
    
    
    this.calculateMD5 = function(aData) { /* byte array */
//				return MD5(aDatai);
				return "6e372f076fb9586aff416144f5cfe1cb";
        var zReturn="";
				/* TODO DODO md5 hashing */
/*            java.security.MessageDigest zMD=java.security.MessageDigest.getInstance("MD5");
            zMD.update(aData);
            byte[] zSum=zMD.digest();
            java.math.BigInteger zBig=new java.math.BigInteger(1, zSum);
            zReturn=zBig.toString(16);
        }//end : try*/
        return zReturn;
    };
    
    
    
   this.arrayCompare = function(aArray, aIndexA, aIndexB, aCompCount) {
        var zReturn=true;
        
        for (var i=0; i<aCompCount; i++) {
            if (aArray[aIndexA + i]!=aArray[aIndexB+i]) {
                zReturn=false;
                break;
            }//end : not equal
        }//end : for loop
        return zReturn;
    }
    
    /**
     * Checks to see if an MD5 matches a previously compiled list of MD5s and cartridge
     * types.  The list in this method only contains those that the autodetection method
     * (detectTypeByImage) is incapable of identifying correctly.
     * @param aMD5 MD5 to check
     * @return the cartridge type if there is a match; null if no match was found
     */
    this.detectTypeByMD5 = function(aMD5) {
        var zReturn=null;
        aMD5=aMD5.toLowerCase().trim();
        
        if (aMD5 === "bc24440b59092559a1ec26055fd1270e") zReturn=TYPE_F8SWAPPED;
        else if (aMD5 === "75ee371ccfc4f43e7d9b8f24e1266b55") zReturn=TYPE_F8SWAPPED;
        else if (aMD5 === "6dda84fb8e442ecf34241ac0d1d91d69") zReturn=TYPE_F6SC;

        return zReturn;
    }
    
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.searchForBytes = function(image, signature, sigsize, minhits) {
        var count = 0;
        var imagesize=image.length;
        for(var i = 0; i < imagesize - sigsize; /*++i*/ i++) {
            var matches = 0;
            for(var j = 0; j < sigsize; /*++j*/j++) {
                if(image[i+j] == signature[j])
                    ++matches;
                else
                    break;
            }
            if(matches == sigsize) {
                ++count;
                i += sigsize;  // skip past this signature 'window' entirely
            }
            if(count >= minhits)
                break;
        }
        
        return (count >= minhits);
    };
    
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.isProbablySC = function(image, size) {
        // We assume a Superchip cart contains the same bytes for its entire
        // RAM area; obviously this test will fail if it doesn't
        // The RAM area will be the first 256 bytes of each 4K bank
        var banks = Math.floor(size / 4096);
        for(var i = 0; i < banks; ++i) {
            var first = image[i*4096];
            for(var j = 0; j < 256; ++j) {
                if(image[(i*4096)+j] != first)
                    return false;
            }
        }
        return true;
    };
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   	this.isProbably3F = function(image, size) {
        // 3F cart bankswitching is triggered by storing the bank number
        // in address 3F using 'STA $3F'
        // We expect it will be present at least 2 times, since there are
        // at least two banks
        var intsignature= [ 0x85, 0x3F ]  // STA $3F
        var signature=this.toDataUByte(intsignature);
        return this.searchForBytes(image, signature, 2, 2);
    };
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.isProbably3E = function(image, size) {
        // 3E cart bankswitching is triggered by storing the bank number
        // in address 3E using 'STA $3E', commonly followed by an
        // immediate mode LDA
        var intsignature = [ 0x85, 0x3E, 0xA9, 0x00 ];  // STA $3E; LDA #$00
        var signature=this.toDataUByte(intsignature);
        return this.searchForBytes(image, signature, 4, 1);
    };
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.isProbablyE0 = function(image, size) {
        // E0 cart bankswitching is triggered by accessing addresses
        // $FE0 to $FF9 using absolute non-indexed addressing
        // To eliminate false positives (and speed up processing), we
        // search for only certain known signatures
        // Thanks to "stella@casperkitty.com" for this advice
        // These signatures are attributed to the MESS project
        var intsignature = [ /*[6][3]*/
            [ 0x8D, 0xE0, 0x1F ],  // STA $1FE0
            [ 0x8D, 0xE0, 0x5F ],  // STA $5FE0
            [ 0x8D, 0xE9, 0xFF ],  // STA $FFE9
            [ 0xAD, 0xE9, 0xFF ],  // LDA $FFE9
            [ 0xAD, 0xED, 0xFF ],  // LDA $FFED
            [ 0xAD, 0xF3, 0xBF ]   // LDA $BFF3
        ];
        var signature=toDataUByte(intsignature);
        for(var i = 0; i < 6; ++i) {
            if(searchForBytes(image, signature[i], 3, 1))
                return true;
        }
        return false;
    };
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.isProbablyE7 = function(image, size) {
        // E7 carts map their second 1K block of RAM at addresses
        // $800 to $8FF.  However, since this occurs in the upper 2K address
        // space, and the last 2K in the cart always points to the last 2K of the
        // ROM image, the RAM area should fall in addresses $3800 to $38FF
        // Similar to the Superchip cart, we assume this RAM block contains
        // the same bytes for its entire area
        // Also, we want to distinguish between ROMs that have large blocks
        // of the same amount of (probably unused) data by making sure that
        // something differs in the previous 32 or next 32 bytes
        var first = image[0x3800];
        for(var i = 0x3800; i < 0x3A00; ++i) {
            if(first != image[i])
                return false;
        }
        
        // OK, now scan the surrounding 32 byte blocks
        var count1 = 0, count2 = 0;
        for(var i = 0x3800 - 32; i < 0x3800; ++i) {
            if(first != image[i])
                ++count1;
        }
        for(var i = 0x3A00; i < 0x3A00 + 32; ++i) {
            if(first != image[i])
                ++count2;
        }
        
        return (count1 > 0 || count2 > 0);
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.isProbablyUA = function(image, size) {
        // UA cart bankswitching switches to bank 1 by accessing address 0x240
        // using 'STA $240'
        var intsignature = [ 0x8D, 0x40, 0x02 ];  // STA $240
        var signature=toDataUByte(intsignature);
        return searchForBytes(image, signature, 3, 1);
    };
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.isProbablyCV = function(image, size) {
        // CV RAM access occurs at addresses $f3ff and $f400
        // These signatures are attributed to the MESS project
        var intsignature /*[2][3]*/ = [
            [ 0x9D, 0xFF, 0xF3 ],  // STA $F3FF
            [ 0x99, 0x00, 0xF4 ]   // STA $F400
        ];
        var signature=toDataUByte(intsignature);
        if(searchForBytes(image, signature[0], 3, 1))
            return true;
        else
            return searchForBytes(image, signature[1], 3, 1);
    };
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.isProbablyFE = function(image, size) {
        // FE bankswitching is very weird, but always seems to include a
        // 'JSR $xxxx'
        // These signatures are attributed to the MESS project
        var intsignature/*[4][5]*/ = [
            [ 0x20, 0x00, 0xD0, 0xC6, 0xC5 ],  // JSR $D000; DEC $C5
            [ 0x20, 0xC3, 0xF8, 0xA5, 0x82 ],  // JSR $F8C3; LDA $82
            [ 0xD0, 0xFB, 0x20, 0x73, 0xFE ],  // BNE $FB; JSR $FE73
            [ 0x20, 0x00, 0xF0, 0x84, 0xD6 ]   // JSR $F000; STY $D6
        ];
        var signature=toDataUByte(intsignature);
        for(var i = 0; i < 4; ++i) {
            if(searchForBytes(image, signature[i], 5, 1))
                return true;
        }
        return false;
    };
    
    
    
    
   // ============== Subclass convenience methods =====================
    
    this.copyImage = function(aSourceImage)
    {
        var zReturn = [];
				var length = aSourceImage.length;
        for (var i=0; i<length; i++)
        {
            zReturn[i]=aSourceImage[i];
        }//end : for i loop
        return zReturn;
    };
    
    this.randomizeRAM = function(aRAM)
    {
       	var length = aRAM.length;
        for(var i = 0; i < length; i++) {
            aRAM[i] = Math.floor(Math.random() * 256) & 0xFF;
        }//end : for i loop
    };
    
   
    this.addIndirectAccess = function(aStartAddress, aEndAddress)
    {
        
        for(var zAddress = (aStartAddress & ~PAGE_MASK); zAddress < (aEndAddress & ~PAGE_MASK); zAddress += PAGE_SIZE)
        {
            mySystem.setPageAccess(zAddress >> PAGE_SHIFT, PageAccess.createIndirectAccess(this));
        } 
    };
    
    this.addDirectPeekAccess = function(aStartAddress, aEndAddress, aMemory, aBaseAddressMask, aBaseAddressOffset)
    {
        for(var zAddress = (aStartAddress & ~PAGE_MASK); zAddress < (aEndAddress & ~PAGE_MASK); zAddress += PAGE_SIZE)
        {
            mySystem.setPageAccess(zAddress >> PAGE_SHIFT, PageAccess.createDirectPeekAccess(this, aMemory, aBaseAddressOffset + (zAddress & aBaseAddressMask)));
        }    
    };
    
    this.addDirectPeekAccess = function(aStartAddress, aEndAddress, aMemory, aBaseAddressMask)
     {
         addDirectPeekAccess(aStartAddress, aEndAddress, aMemory, aBaseAddressMask, 0);
     };
    
    this.addDirectPokeAccess = function(aStartAddress, aEndAddress, aMemory, aBaseAddressMask, aBaseAddressOffset)
    {
        for(var zAddress = (aStartAddress & ~PAGE_MASK); zAddress < (aEndAddress & ~PAGE_MASK); zAddress += PAGE_SIZE)
        {
            mySystem.setPageAccess(zAddress >> PAGE_SHIFT, PageAccess.createDirectPokeAccess(this, aMemory, aBaseAddressOffset + (zAddress & aBaseAddressMask)));
        } 
    }
    
    this.addDirectPokeAccess = function(aStartAddress, aEndAddress,aMemory, aBaseAddressMask)
     {
         addDirectPokeAccess(aStartAddress, aEndAddress, aMemory, aBaseAddressMask, 0);
     }
    
    
 
    
  
    
    
  // ================ Unsigned/signed conversion methods =============
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * Returns a byte that represents the value supplied.
     * The byte is actually signed, so it is important
     * to remember that accessing its value directly may not
     * return the value supplied to it.
     * @param aByteValue The value to be represented as a byte (0-255)
     * @return A byte that represents the value supplied.
     */
    this.toDataUByte = function(aByteValue) {
        return aByteValue & 0xff;
    };
    
    
    /**
     * Performs toDataUByte(int) on an array
     * @param aArray Array of values
     * @return Array of bytes
     */
 		this.toDataUByte = function(aArray) {
        var zReturn= [];
				var length = aArray.length;
        for (var i=0; i<length; i++) {
            zReturn[i]=toDataUByte(aArray[i]);
        }//end : for i loop
        return zReturn;
    };
    
    /**
     * Performs toDataUByte(int) on a double array
     * @param aArray a double array
     * @return a double array of byte
     */
    this.toDataUByte = function(aArray) {
        var zReturn= [];
				length = aArray.length;
        for (var i=0; i<length; i++) {
            zReturn[i]= [];
            for (var j=0; j<aArray[i].length; j++) {
                zReturn[i][j]=toDataUByte(aArray[i][j]);
            }//end : for j loop
        }//end : for i loop
        return zReturn;
    };

   /* public int hashCode() {
       return myMD5.hashCode();
    }
    */

    this.toString = function() {
        return "Cartridge : " + this.name() + "; md5=" + myMD5;
    };

    
    /**
     * Looks at the data to determine (or guess) what type of cartridge the data
     * represents.
     * @param image the ROM data
     * @return the cartridge type
     */
    this.detectTypeByImage = function(image) {
        // Guess type based on size
        var type ="";
        var size=image.length;
        if((size % 8448) == 0) {
            type = "AR";
        } else if((size == 2048) ||
                ((size == 4096) && (arrayCompare(image, 0, 2048, 2048)==true))) {
            if(isProbablyCV(image, size))
                type = "CV";
            else
                type = TYPE_2K;
        } else if(size == 4096) {
            if(isProbablyCV(image, size))
                type = "CV";
            else
                type = TYPE_4K;
        } else if(size == 8192)  // 8K
        {
            if(isProbablySC(image, size))
                type = TYPE_F8SC;
            else if(arrayCompare(image, 0, 4096, 4096)==true)
                type = TYPE_4K;
            else if(isProbablyE0(image, size))
                type = TYPE_E0;
            else if(isProbably3E(image, size))
                type = "3E";
            else if(isProbably3F(image, size))
                type = TYPE_3F;
            else if(isProbablyUA(image, size))
                type = "UA";
            else if(isProbablyFE(image, size))
                type = TYPE_FE;
            else
                type = TYPE_F8;
        } else if((size == 10495) || (size == 10496) || (size == 10240))  // 10K - Pitfall2
        {
            type = TYPE_DPC;
        } else if(size == 12288)  // 12K
        {
            // TODO - this should really be in a method that checks the first
            // 512 bytes of ROM and finds if either the lower 256 bytes or
            // higher 256 bytes are all the same.  For now, we assume that
            // all carts of 12K are CBS RAM Plus/FASC.
            type = "FASC";
        } else if(size == 16384)  // 16K
        {
            if(isProbablySC(image, size))
                type = TYPE_F6SC;
            else if(isProbablyE7(image, size))
                type = TYPE_E7;
            else if(isProbably3E(image, size))
                type = "3E";
            else if(isProbably3F(image, size))
                type = TYPE_3F;
            else
                type = TYPE_F6;
        } else if(size == 32768)  // 32K
        {
            if(isProbablySC(image, size))
                type = TYPE_F4SC;
            else if(isProbably3E(image, size))
                type = "3E";
            else if(isProbably3F(image, size))
                type = TYPE_3F;
            else
                type = "F4";
        } else if(size == 65536)  // 64K
        {
            // TODO - autodetect 4A50
            if(isProbably3E(image, size))
                type = "3E";
            else if(isProbably3F(image, size))
                type = TYPE_3F;
            else
                type = "MB";
        } else if(size == 131072)  // 128K
        {
            // TODO - autodetect 4A50
            if(isProbably3E(image, size))
                type = "3E";
            else if(isProbably3F(image, size))
                type = TYPE_3F;
            else
                type = "MC";
        } else  // what else can we do?
        {
            if(this.isProbably3E(image, size))
                type = "3E";
            else if(this.isProbably3F(image, size))
                type = this.TYPE_3F;
            else
                type = this.TYPE_4K;  // Most common bankswitching type
        }
       	type="4K"; 
        return type;
    }
    
    
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * Creates a cartridge from the given data.  This is the preferred method
     * for creating cartridge objects.  It detects what type of cartidge needs to be created
     * based on the data, and returns a newly created one.
     * @param image the ROM data
     * @return a cartridge object
     */
    this.create = function(image){
        var zMD5 = this.calculateMD5(image); //Calculate the MD5 based on the byte array
        console.log("LOADING ROM : " + zMD5);
       
        cartridge = null;
        
        zType=this.detectTypeByMD5(zMD5);
        if (zType==null) zType= this.detectTypeByImage(image);
        console.log("JStella - detected cartridge type: " + zType);
        // We should know the cart's zType by now so let's create it
        cartridge=this.create2(image, zType); /* create2 -> has tow args. because javascript does not support overloading */
      
        return cartridge;
    };
    
    
   	this.create2 = function(image,aType){ /* original name of this function is "create", but javascript does not support function overloading */

        cartridge=null;

        zUCType=aType.toUpperCase();
        zIntImage=this.toIntArray(image); //create an int array from the byte array
        /*if(zUCType === TYPE_2K.toUpperCase()) cartridge = new Cartridge2K(zIntImage);
        else*/ if(zUCType===this.TYPE_4K.toUpperCase() || true) cartridge = new Cartridge4K(zIntImage);
        /*else if(zUCType===TYPE_F8.toUpperCase())) cartridge = new CartridgeF8(zIntImage, false);
        else if(zUCType===TYPE_F8SWAPPED.toUpperCase())) cartridge = new CartridgeF8(zIntImage, true);
        else if(zUCType===TYPE_F8SC.toUpperCase())) cartridge = new CartridgeF8SC(zIntImage);
        else if(zUCType===TYPE_F6.toUpperCase())) cartridge = new CartridgeF6(zIntImage);
        else if(zUCType===TYPE_F6SC.toUpperCase())) cartridge = new CartridgeF6SC(zIntImage);      
        else if(zUCType===TYPE_F4SC.toUpperCase())) cartridge = new CartridgeF4SC(zIntImage);
        else if(zUCType===TYPE_FE.toUpperCase())) cartridge = new CartridgeFE(zIntImage);
        else if(zUCType===TYPE_DPC.toUpperCase())) cartridge = new CartridgeDPC(zIntImage);
        else if(zUCType===TYPE_E0.toUpperCase())) cartridge = new CartridgeE0(zIntImage);
         else if(zUCType===TYPE_E7.toUpperCase())) cartridge = new CartridgeE7(zIntImage);
         else if(zUCType===TYPE_3F.toUpperCase())) cartridge = new Cartridge3F(zIntImage);
         else if(zUCType===TYPE_F4.toUpperCase())) cartridge = new CartridgeF4(zIntImage);
         else if(zUCType===TYPE_FASC.toUpperCase()))  cartridge = new CartridgeFASC(zIntImage);*/
        else {
            zMsg="JStella does not yet support Cartridge Type " + aType + ".";
            console.log(zMsg);
       	}
        zMD5 = "6e372f076fb9586aff416144f5cfe1cb";
				//MD5(image); //Calculate the MD5 based on the byte array 
        cartridge.setMD5(zMD5);
        return cartridge;
    }
    
    
    
}

//============================================================================
//
//   SSSS    tt          lll  lll
//  SS  SS   tt           ll   ll
//  SS     tttttt  eeee   ll   ll   aaaa
//   SSSS    tt   ee  ee  ll   ll      aa
//      SS   tt   eeeeee  ll   ll   aaaaa  --  "An Atari 2600 VCS Emulator"
//  SS  SS   tt   ee      ll   ll  aa  aa
//   SSSS     ttt  eeeee llll llll  aaaaa
//
// Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: Cartridge4K.java,v 1.2 2007/08/12 04:51:29 mauvila Exp $
//============================================================================
function Cartridge4K (image){
    this.serialVersionUID = "-3240308689643904765L";
    
    this.CARTRIDGE_MASK_VALUE=0x0FFF;
    this.CARTRIDGE_SIZE=4096;
    this.CARTRIDGE_BANK_COUNT=1;
    
    
    
    
    // The 4K ROM image for the cartridge
    this.myImage=[];
    
    
		//이하 원래 상속 

this.setConsole = function(aConsole) { myConsole=aConsole; };

  	this.systemCyclesReset = function() {    };
    
		this.getMD5 = function(){ return this. myMD5; };
    this.setMD5 = function(aMD5){ this.myMD5=aMD5; };
    
		this.copyImage = function(aSourceImage)
    {
        var zReturn = [];
				var length = aSourceImage.length;
        for (var i=0; i<length; i++)
        {
            zReturn[i]=aSourceImage[i];
        }//end : for i loop
        return zReturn;
    };
    

    this.addIndirectAccess = function(aStartAddress, aEndAddress)
    {
        
        for(var zAddress = (aStartAddress & ~PAGE_MASK); zAddress < (aEndAddress & ~PAGE_MASK); zAddress += PAGE_SIZE)
        {
            mySystem.setPageAccess(zAddress >> PAGE_SHIFT, (new PageAccess()).createIndirectAccess(this));
        } 
    };
    
    this.addDirectPeekAccess = function(aStartAddress, aEndAddress, aMemory, aBaseAddressMask, aBaseAddressOffset)
     {
			 	if(arguments.length == 4)
	         this.addDirectPeekAccess(aStartAddress, aEndAddress, aMemory, aBaseAddressMask, 0);
				else  {
		        for(var zAddress = (aStartAddress & ~PAGE_MASK); zAddress < (aEndAddress & ~PAGE_MASK); zAddress += PAGE_SIZE)
    	    {
      	      this.mySystem.setPageAccess(zAddress >> PAGE_SHIFT, (new PageAccess()).createDirectPeekAccess(this, aMemory, aBaseAddressOffset + (zAddress & aBaseAddressMask)));
        	}  
				}
     };
    
    this.addDirectPokeAccess = function(aStartAddress, aEndAddress, aMemory, aBaseAddressMask, aBaseAddressOffset)
    {
        for(var zAddress = (aStartAddress & ~PAGE_MASK); zAddress < (aEndAddress & ~PAGE_MASK); zAddress += PAGE_SIZE)
        {
            mySystem.setPageAccess(zAddress >> PAGE_SHIFT, PageAccess.createDirectPokeAccess(this, aMemory, aBaseAddressOffset + (zAddress & aBaseAddressMask)));
        } 
    }
    
    this.addDirectPokeAccess = function(aStartAddress, aEndAddress,aMemory, aBaseAddressMask)
     {
         addDirectPokeAccess(aStartAddress, aEndAddress, aMemory, aBaseAddressMask, 0);
     }
    //상속 끝

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.myImage=this.copyImage(image); //Constructor
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.name = function() {
        return "Cartridge4K";
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.reset = function() {
    }
    
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    
    
    this.install = function(system) { //JSSystem?
        this.mySystem = system;        
        this.addDirectPeekAccess(0x1000, 0x2000, this.myImage, this.CARTRIDGE_MASK_VALUE);  // Map ROM image into the system
        
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.peek = function(address) {
        return myImage[address & this.CARTRIDGE_MASK_VALUE];
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.poke = function(aC, aB) {
        // This is ROM so poking has no effect :-)
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.setCurrentBank = function(bank) {
        // Doesn't support bankswitching
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.getCurrentBank = function() {
        // Doesn't support bankswitching
        return 0;
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.bankCount = function() {
        return this.CARTRIDGE_BANK_COUNT;
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.patch = function(address, value) {
        myImage[address & this.CARTRIDGE_MASK_VALUE] = value;
        return true;
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.getImage = function() {
        
        return myImage;
    }
    
    
    
}

/*
 * JStellaCanvas.java
 *
 * Created on August 23, 2007, 12:44 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */


/**
 *
 * @author J.L. Allen
 */
function JStellaCanvas(){
   /* this. Rectangle myClippingRectangle=new Rectangle();
    private AffineTransform myTransform=new AffineTransform();
    
    private BufferedImage myImage=null;
    private int myOriginalWidth=10;
    private int myOriginalHeight=10;
    
    private int myPreviousCanvasWidth=10;
    private int myPreviousCanvasHeight=10;
    
    private double myScaleX=1.0;
    private double myScaleY=1.0;
    
    private int myOffsetX=0;
    private int myOffsetY=0;
    
    private boolean myLetterBoxMode=false;
    private Toolkit myDefaultToolkit=null;
    
    private boolean myRefreshNeeded=false;
    */
    /** Creates a new instance of JStellaCanvas */
   
    
/*  public JStellaCanvas() {
            setOpaque(true);
            setBackground(java.awt.Color.BLACK);
            //setBorder(null);
            setFocusable(true);
            //setDoubleBuffered(false); //I don't know if this will improve performance, but I did it anyway... JLA
            this.addComponentListener(new CanvasComponentListener());
            
            
        }*/
        
        /**
         * This method paints the myBackBuffer BufferedImage to the screen.  The clipping
         * is actually handeled by whatever commands the canvas to repaint, usually
         * the drawMediaSource() method.
         * @param g Graphics (2D)
         */
  
        /*public void paint(Graphics g) {
          
            Graphics2D z2D=(Graphics2D)g;
             if (myRefreshNeeded==true)
            {
                z2D.setColor(Color.BLACK);
                //z2D.setColor(Color.GREEN); //debug
                z2D.fillRect(0,0, this.getWidth(), this.getHeight());
                myRefreshNeeded=false;
            }//end : redraw parent
         //   long zNanoA=System.nanoTime();
           if (myImage!=null) 
           {
                z2D.drawImage(myImage, myTransform, null);
                //System.out.println("debug - image height=" + myImage.getHeight());
           }
            syncPainting();
           // java.awt.Toolkit.getDefaultTo
         //  long zNanoB=System.nanoTime();
        }
        
        */
        /*private void syncPainting() //not sure if this is necessary/prudent...needs checking
        {
            if (myDefaultToolkit==null) myDefaultToolkit=java.awt.Toolkit.getDefaultToolkit();
            
            if (myDefaultToolkit!=null) myDefaultToolkit.sync();
        }
        */
        /*private void setOriginalDimensions(int aOriginalWidth, int aOriginalHeight)
        {
           if ((aOriginalWidth!=myOriginalWidth)||(aOriginalHeight!=myOriginalHeight) || (myPreviousCanvasWidth!=getCanvasWidth()) || (myPreviousCanvasHeight!=getCanvasHeight()))
              {
                 myOriginalWidth=aOriginalWidth;
                 myOriginalHeight=aOriginalHeight;
                 myPreviousCanvasWidth=getCanvasWidth();
                 myPreviousCanvasHeight=getCanvasHeight();
                 updateScale();
               
              }//end : change in dimensions
               
           
            
        }
        
       */
        /*
        private void updateScale()
        {
           myTransform.setToIdentity();
            myScaleX=(double)getCanvasWidth() / myOriginalWidth; // / getCanvasWidth();
            myScaleY=(double)getCanvasHeight() / myOriginalHeight; // / getCanvasHeight();
         if (myLetterBoxMode==true)
          {
              double zOriginalRatio=(double)myOriginalWidth * JSConstants.PIXEL_WIDTH_HEIGHT_RATIO /(double)myOriginalHeight;
              double zCanvasRatio=(double)getCanvasWidth()/(double)getCanvasHeight();
              if (zCanvasRatio>zOriginalRatio) 
              {
                  myScaleX=myScaleY * JSConstants.PIXEL_WIDTH_HEIGHT_RATIO;
                  double zBorderWidth= (getCanvasWidth() - (myOriginalWidth * myScaleX)) / 2.0;
                  myOffsetX=(int)zBorderWidth;
                  myOffsetY=0;
                  myTransform.translate(zBorderWidth, 0.0);
              }//end : limiter=height
              else 
              {
                  myScaleY=myScaleX / JSConstants.PIXEL_WIDTH_HEIGHT_RATIO;
                  
                  //myScaleX=myScaleY * JSConstants.PIXEL_WIDTH_HEIGHT_RATIO;
                   double zBorderWidth= (getCanvasHeight() - (myOriginalHeight * myScaleY)) / 2.0;
                   myOffsetY=(int)zBorderWidth;
                   myOffsetX=0;
                  myTransform.translate(0.0, zBorderWidth);
              }//end : limiter=width
              
              
              
          }//end : letter box mode
            myTransform.scale(myScaleX, myScaleY);
          
        }
        */
        /*
        public void setLetterBoxMode(boolean aEnable)
        {
            if (aEnable!=myLetterBoxMode)
            {
            myLetterBoxMode=aEnable;
            updateScale();
            refreshCanvas();
            }//end : changed value
        }
        */
        this.refreshCanvas = function()
        {
/*            updateScale();
            myRefreshNeeded=true;
            repaint();*/
        }
				/*
        public boolean getLetterBoxMode()
        {
            return myLetterBoxMode;
        }
        */
				/*
        this.getCanvasWidth = function() {
            return this.getWidth();
        }
        */
				/*
        public int getCanvasHeight() {
            return this.getHeight();
        }
        */

        /*private void setClippingRectangle(Rectangle aOriginalClip)
        {
            setClippingRectangle(aOriginalClip.x, aOriginalClip.y, aOriginalClip.width, aOriginalClip.height);
        }
        */
				/*
        private void setClippingRectangle(int aClipX, int aClipY, int aClipWidth, int aClipHeight)
        {
         
          int zX=(int)(aClipX *myScaleX);
          int zY=(int)(aClipY * myScaleY);
        
        int zW=(int)((aClipX + aClipWidth) * myScaleX) + 1 - zX;
        int zH=(int)((aClipY + aClipHeight) * myScaleY) + 1 - zY; 
        
        if (myLetterBoxMode==true)
        {
          zX += myOffsetX;
          zY += myOffsetY;
        }//end : letter box mode
        
        myClippingRectangle.setRect(zX, zY, zW, zH);
        }
        
        */

     this.paintCanvas = function(aImage, aOriginalWidth, aOriginalHeight, aOriginalClip) {
        this.myImage=aImage;

				t = getImageData();

				var x = aOriginalClip.x, y= aOriginalClip.y, w = aOriginalClip.width, h = aOriginalClip.height;

				var i, j, c;
				for(i=0;i<w;i++){
					for(j=0;j<h;j++){
						c = aImage[(x+i)*WIDTH+(y+j)];
						setPixel(t, x+i, y+j, (c >> 16) & 0xFF, (c >> 8) & 0xFF, c & 0xFF);
					}
				}
				
			putImageData(t);
/*        setOriginalDimensions(aOriginalWidth, aOriginalHeight);
     
        setClippingRectangle(aOriginalClip);
        repaint(myClippingRectangle);*/


        
    }
    
    
   /* public  void paintCanvas(BufferedImage aImage, int aOriginalWidth, int aOriginalHeight) {
        myImage=aImage;
        setOriginalDimensions(aOriginalWidth, aOriginalHeight);
       
       
        repaint();
        
    }
    */
   /* public String toString()
    {
        return "Canvas : " + this.getWidth() + " x " + this.getHeight() + "; scale=" + myScaleX + " x " + myScaleY;
    }*/
    
    
    //====================================================
    
    /*private class CanvasComponentListener implements ComponentListener
    {
        public void componentShown(ComponentEvent componentEvent) {
        }

        public void componentResized(ComponentEvent componentEvent) {
            
            updateScale();
            refreshCanvas();
            //JStellaCanvas.this.repaint();
        }

        public void componentMoved(ComponentEvent componentEvent) {
        }

        public void componentHidden(ComponentEvent componentEvent) {
        }
        
    }
    
    */
    
}


function InputMaster(aClient) {
  this.myInputMasterClient = null;
  this.VirtualControlTask = {
    JOYSTICK_A_UP : "JOYSTICK_A_UP",
    JOYSTICK_A_DOWN : "JOYSTICK_A_DOWN",
    JOYSTICK_A_LEFT : "JOYSTICK_A_LEFT",
    JOYSTICK_A_RIGHT : "JOYSTICK_A_RIGHT",
    JOYSTICK_A_BUTTON : "JOYSTICK_A_BUTTON",
  };
  this.performControlItemAction = function(aVItem, aPressed) {
    var zScontrollerA = this.myInputMasterClient.getConsole().getController(Jack.LEFT);
    var zSControllerB = this.myInputMasterClient.getConsole().getController(Jack.RIGHT);
    switch (aVItem) {
      case VirtualControlTask.JOYSTICK_A_UP : zSControllerA.changeControllerState(JSController.JOYSTICK_UP, aPressed); break;
      case VirtualControlTask.JOYSTICK_A_DOWN : zSControllerA.changeControllerState(JSController.JOYSTICK_DOWN, aPressed); break;
      case VirtualControlTask.JOYSTICK_A_LEFT : zSControllerA.changeControllerState(JSController.JOYSTICK_LEFT, aPressed); break;
      case VirtualControlTask.JOYSTICK_A_RIGHT : zSControllerA.changeControllerState(JSController.JOYSTICK_RIGHT, aPressed); break;
      case VirtualControlTask.JOYSTICK_A_BUTTON : zSControllerA.changeControllerState(JSController.JOYSTICK_BUTTON, aPressed); break;
            
//      case JOYSTICK_B_UP : zSControllerB.changeControllerState(JSController.JOYSTICK_UP, aPressed); break;
//      case JOYSTICK_B_DOWN : zSControllerB.changeControllerState(JSController.JOYSTICK_DOWN, aPressed); break;
//      case JOYSTICK_B_LEFT : zSControllerB.changeControllerState(JSController.JOYSTICK_LEFT, aPressed); break;
//      case JOYSTICK_B_RIGHT : zSControllerB.changeControllerState(JSController.JOYSTICK_RIGHT, aPressed); break;
//      case JOYSTICK_B_BUTTON : zSControllerB.changeControllerState(JSController.JOYSTICK_BUTTON, aPressed); break;
//            
//      case PADDLE_A_BUTTON : zSControllerA.changeControllerState(JSController.PADDLE_ALPHA_BUTTON, aPressed); break;
//      case PADDLE_B_BUTTON : zSControllerA.changeControllerState(JSController.PADDLE_BETA_BUTTON, aPressed); break;
//      case PADDLE_C_BUTTON : zSControllerB.changeControllerState(JSController.PADDLE_ALPHA_BUTTON, aPressed); break;
//      case PADDLE_D_BUTTON : zSControllerB.changeControllerState(JSController.PADDLE_BETA_BUTTON, aPressed); break;
//           
//      case PADDLE_A_CW : if (aPressed) zSControllerA.changePaddlePosition(JSController.PaddleID.PADDLE_ALPHA, myPaddleShiftPercentage); break;
//      case PADDLE_B_CW : if (aPressed) zSControllerA.changePaddlePosition(JSController.PaddleID.PADDLE_BETA, myPaddleShiftPercentage); break;
//      case PADDLE_C_CW : if (aPressed) zSControllerB.changePaddlePosition(JSController.PaddleID.PADDLE_ALPHA, myPaddleShiftPercentage); break;
//      case PADDLE_D_CW : if (aPressed) zSControllerB.changePaddlePosition(JSController.PaddleID.PADDLE_BETA, myPaddleShiftPercentage); break;
//            
//      case PADDLE_A_CCW : if (aPressed) zSControllerA.changePaddlePosition(JSController.PaddleID.PADDLE_ALPHA, -1 * myPaddleShiftPercentage); break;
//      case PADDLE_B_CCW : if (aPressed) zSControllerA.changePaddlePosition(JSController.PaddleID.PADDLE_BETA, -1 * myPaddleShiftPercentage); break;
//      case PADDLE_C_CCW : if (aPressed) zSControllerB.changePaddlePosition(JSController.PaddleID.PADDLE_ALPHA, -1 * myPaddleShiftPercentage); break;
//      case PADDLE_D_CCW : if (aPressed) zSControllerB.changePaddlePosition(JSController.PaddleID.PADDLE_BETA, -1 * myPaddleShiftPercentage); break;
//            
//      case BOOSTERGRIP_A_BOOSTER : zSControllerA.setBoosterGripBooster(aPressed); break;
//      case BOOSTERGRIP_B_BOOSTER : zSControllerB.setBoosterGripBooster(aPressed); break;
//            
//      case BOOSTERGRIP_A_TRIGGER : zSControllerA.setBoosterGripTrigger(aPressed); break;
//      case BOOSTERGRIP_B_TRIGGER : zSControllerB.setBoosterGripTrigger(aPressed); break;
  }
	}
  
 
  /* Constructor */
  if (aClient === undefined || aClient === null) {
    this.setControls(DEFAULT_CONTROL_BINDERS);
    this.setSwitches(DEFAULT_SWITCH_BINDERS);
  }
  this.myInputMaster = aClient;

  $(document).keydown(function(e){
    switch(e.charCode) {
      case 32:
        // SPACE
        this.performControlItemAction(this.VirtualControlTask.JOYSTICK_A_BUTTON, true);
        break;
      case 37:
        // left arrow
        this.performControlItemAction(this.VirtualControlTask.JOYSTICK_A_LEFT, true);
        break;
      case 38:
        // up arrow
        this.performControlItemAction(this.VirtualControlTask.JOYSTICK_A_UP, true);
        break;

      case 39:
        // right arrow
        this.performControlItemAction(this.VirtualControlTask.JOYSTICK_A_RIGHT, true);
        break;

      case 40:
        // down arrow
        this.performControlItemAction(this.VirtualControlTask.JOYSTICK_A_DOWN, true);
        break;

    }
  });

	$(document).keyup(function(e){
    switch(e.charCode) {
      case 32:
        // SPACE
        this.performControlItemAction(this.VirtualControlTask.JOYSTICK_A_BUTTON, false);
        break;
      case 37:
        // left arrow
        this.performControlItemAction(this.VirtualControlTask.JOYSTICK_A_LEFT, false);
        break;
      case 38:
        // up arrow
        this.performControlItemAction(this.VirtualControlTask.JOYSTICK_A_UP, false);
        break;

      case 39:
        // right arrow
        this.performControlItemAction(this.VirtualControlTask.JOYSTICK_A_RIGHT, false);
        break;

      case 40:
        // down arrow
        this.performControlItemAction(this.VirtualControlTask.JOYSTICK_A_DOWN, false);
        break;

    }
  });

}


function J6507(aSystem) {
  this.AddressingMode = {
    Absolute: "Absolute",
    AbsoluteX: "AbsoluteX",
    AbsoluteY: "AbsoluteY",
    Immediate: "Immediate",
    Implied: "Implied",
    Indirect: "Indirect",
    IndirectX: "IndirectX",
    IndirectY: "IndirectY",
    Invalid: "Invalid",
    Relative: "Relative",
    Zero: "Zero",
    ZeroX: "ZeroX",
    ZeroY: "ZeroY"
  };
  this.ourAddressingModeTable = [
    this.AddressingMode.Implied,    this.AddressingMode.IndirectX, this.AddressingMode.Invalid,   this.AddressingMode.IndirectX,    // 0x0?
    this.AddressingMode.Zero,   this.AddressingMode.Zero,      this.AddressingMode.Zero,      this.AddressingMode.Zero,
    this.AddressingMode.Implied,    this.AddressingMode.Immediate, this.AddressingMode.Implied,   this.AddressingMode.Immediate,
    this.AddressingMode.Absolute,   this.AddressingMode.Absolute,  this.AddressingMode.Absolute,  this.AddressingMode.Absolute,
    
    this.AddressingMode.Relative,   this.AddressingMode.IndirectY, this.AddressingMode.Invalid,   this.AddressingMode.IndirectY,    // 0x1?
    this.AddressingMode.ZeroX,  this.AddressingMode.ZeroX,     this.AddressingMode.ZeroX,     this.AddressingMode.ZeroX,
    this.AddressingMode.Implied,    this.AddressingMode.AbsoluteY, this.AddressingMode.Implied,   this.AddressingMode.AbsoluteY,
    this.AddressingMode.AbsoluteX,  this.AddressingMode.AbsoluteX, this.AddressingMode.AbsoluteX, this.AddressingMode.AbsoluteX,
    
    this.AddressingMode.Absolute,   this.AddressingMode.IndirectX, this.AddressingMode.Invalid,   this.AddressingMode.IndirectX,    // 0x2?
    this.AddressingMode.Zero,   this.AddressingMode.Zero,  this.AddressingMode.Zero,  this.AddressingMode.Zero,
    this.AddressingMode.Implied,    this.AddressingMode.Immediate, this.AddressingMode.Implied,   this.AddressingMode.Immediate,
    this.AddressingMode.Absolute,   this.AddressingMode.Absolute,  this.AddressingMode.Absolute,  this.AddressingMode.Absolute,
    
    this.AddressingMode.Relative,   this.AddressingMode.IndirectY, this.AddressingMode.Invalid,   this.AddressingMode.IndirectY,    // 0x3?
    this.AddressingMode.ZeroX,  this.AddressingMode.ZeroX,     this.AddressingMode.ZeroX,     this.AddressingMode.ZeroX,
    this.AddressingMode.Implied,    this.AddressingMode.AbsoluteY, this.AddressingMode.Implied,   this.AddressingMode.AbsoluteY,
    this.AddressingMode.AbsoluteX,  this.AddressingMode.AbsoluteX, this.AddressingMode.AbsoluteX, this.AddressingMode.AbsoluteX,
    
    this.AddressingMode.Implied,    this.AddressingMode.IndirectX, this.AddressingMode.Invalid,   this.AddressingMode.IndirectX,    // 0x4?
    this.AddressingMode.Zero,   this.AddressingMode.Zero,  this.AddressingMode.Zero,  this.AddressingMode.Zero,
    this.AddressingMode.Implied,    this.AddressingMode.Immediate, this.AddressingMode.Implied,   this.AddressingMode.Immediate,
    this.AddressingMode.Absolute,   this.AddressingMode.Absolute,  this.AddressingMode.Absolute,  this.AddressingMode.Absolute,
    
    this.AddressingMode.Relative,   this.AddressingMode.IndirectY, this.AddressingMode.Invalid,   this.AddressingMode.IndirectY,    // 0x5?
    this.AddressingMode.ZeroX,  this.AddressingMode.ZeroX,     this.AddressingMode.ZeroX,     this.AddressingMode.ZeroX,
    this.AddressingMode.Implied,    this.AddressingMode.AbsoluteY, this.AddressingMode.Implied,   this.AddressingMode.AbsoluteY,
    this.AddressingMode.AbsoluteX,  this.AddressingMode.AbsoluteX, this.AddressingMode.AbsoluteX, this.AddressingMode.AbsoluteX,
    
    this.AddressingMode.Implied,    this.AddressingMode.IndirectX, this.AddressingMode.Invalid,   this.AddressingMode.IndirectX,    // 0x6?
    this.AddressingMode.Zero,   this.AddressingMode.Zero,  this.AddressingMode.Zero,  this.AddressingMode.Zero,
    this.AddressingMode.Implied,    this.AddressingMode.Immediate, this.AddressingMode.Implied,   this.AddressingMode.Immediate,
    this.AddressingMode.Indirect,   this.AddressingMode.Absolute,  this.AddressingMode.Absolute,  this.AddressingMode.Absolute,
    
    this.AddressingMode.Relative,   this.AddressingMode.IndirectY, this.AddressingMode.Invalid,   this.AddressingMode.IndirectY,    // 0x7?
    this.AddressingMode.ZeroX,  this.AddressingMode.ZeroX,     this.AddressingMode.ZeroX,     this.AddressingMode.ZeroX,
    this.AddressingMode.Implied,    this.AddressingMode.AbsoluteY, this.AddressingMode.Implied,   this.AddressingMode.AbsoluteY,
    this.AddressingMode.AbsoluteX,  this.AddressingMode.AbsoluteX, this.AddressingMode.AbsoluteX, this.AddressingMode.AbsoluteX,
    
    this.AddressingMode.Immediate,  this.AddressingMode.IndirectX, this.AddressingMode.Immediate, this.AddressingMode.IndirectX,    // 0x8?
    this.AddressingMode.Zero,   this.AddressingMode.Zero,  this.AddressingMode.Zero,  this.AddressingMode.Zero,
    this.AddressingMode.Implied,    this.AddressingMode.Immediate, this.AddressingMode.Implied,   this.AddressingMode.Immediate,
    this.AddressingMode.Absolute,   this.AddressingMode.Absolute,  this.AddressingMode.Absolute,  this.AddressingMode.Absolute,
    
    this.AddressingMode.Relative,   this.AddressingMode.IndirectY, this.AddressingMode.Invalid,   this.AddressingMode.IndirectY,    // 0x9?
    this.AddressingMode.ZeroX,  this.AddressingMode.ZeroX,     this.AddressingMode.ZeroY,     this.AddressingMode.ZeroY,
    this.AddressingMode.Implied,    this.AddressingMode.AbsoluteY, this.AddressingMode.Implied,   this.AddressingMode.AbsoluteY,
    this.AddressingMode.AbsoluteX,  this.AddressingMode.AbsoluteX, this.AddressingMode.AbsoluteY, this.AddressingMode.AbsoluteY,
    
    this.AddressingMode.Immediate,  this.AddressingMode.IndirectX, this.AddressingMode.Immediate, this.AddressingMode.IndirectX,    // 0xA?
    this.AddressingMode.Zero,   this.AddressingMode.Zero,  this.AddressingMode.Zero,  this.AddressingMode.Zero,
    this.AddressingMode.Implied,    this.AddressingMode.Immediate, this.AddressingMode.Implied,   this.AddressingMode.Immediate,
    this.AddressingMode.Absolute,   this.AddressingMode.Absolute,  this.AddressingMode.Absolute,  this.AddressingMode.Absolute,
    
    this.AddressingMode.Relative,   this.AddressingMode.IndirectY, this.AddressingMode.Invalid,   this.AddressingMode.IndirectY,    // 0xB?
    this.AddressingMode.ZeroX,  this.AddressingMode.ZeroX,     this.AddressingMode.ZeroY,     this.AddressingMode.ZeroY,
    this.AddressingMode.Implied,    this.AddressingMode.AbsoluteY, this.AddressingMode.Implied,   this.AddressingMode.AbsoluteY,
    this.AddressingMode.AbsoluteX,  this.AddressingMode.AbsoluteX, this.AddressingMode.AbsoluteY, this.AddressingMode.AbsoluteY,
    
    this.AddressingMode.Immediate,  this.AddressingMode.IndirectX, this.AddressingMode.Immediate, this.AddressingMode.IndirectX,    // 0xC?
    this.AddressingMode.Zero,   this.AddressingMode.Zero,  this.AddressingMode.Zero,  this.AddressingMode.Zero,
    this.AddressingMode.Implied,    this.AddressingMode.Immediate, this.AddressingMode.Implied,   this.AddressingMode.Immediate,
    this.AddressingMode.Absolute,   this.AddressingMode.Absolute,  this.AddressingMode.Absolute,  this.AddressingMode.Absolute,
    
    this.AddressingMode.Relative,   this.AddressingMode.IndirectY, this.AddressingMode.Invalid,   this.AddressingMode.IndirectY,    // 0xD?
    this.AddressingMode.ZeroX,  this.AddressingMode.ZeroX,     this.AddressingMode.ZeroX,     this.AddressingMode.ZeroX,
    this.AddressingMode.Implied,    this.AddressingMode.AbsoluteY, this.AddressingMode.Implied,   this.AddressingMode.AbsoluteY,
    this.AddressingMode.AbsoluteX,  this.AddressingMode.AbsoluteX, this.AddressingMode.AbsoluteX, this.AddressingMode.AbsoluteX,
    
    this.AddressingMode.Immediate,  this.AddressingMode.IndirectX, this.AddressingMode.Immediate, this.AddressingMode.IndirectX,    // 0xE?
    this.AddressingMode.Zero,   this.AddressingMode.Zero,  this.AddressingMode.Zero,  this.AddressingMode.Zero,
    this.AddressingMode.Implied,    this.AddressingMode.Immediate, this.AddressingMode.Implied,   this.AddressingMode.Immediate,
    this.AddressingMode.Absolute,   this.AddressingMode.Absolute,  this.AddressingMode.Absolute,  this.AddressingMode.Absolute,
    
    this.AddressingMode.Relative,   this.AddressingMode.IndirectY, this.AddressingMode.Invalid,   this.AddressingMode.IndirectY,    // 0xF?
    this.AddressingMode.ZeroX,  this.AddressingMode.ZeroX,     this.AddressingMode.ZeroX,     this.AddressingMode.ZeroX,
    this.AddressingMode.Implied,    this.AddressingMode.AbsoluteY, this.AddressingMode.Implied,   this.AddressingMode.AbsoluteY,
    this.AddressingMode.AbsoluteX,  this.AddressingMode.AbsoluteX, this.AddressingMode.AbsoluteX, this.AddressingMode.AbsoluteX
  ];
  
  this.ourInstructionProcessorCycleTable = [
    //  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
        7, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 4, 4, 6, 6,  // 0
        2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,  // 1
        6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 4, 4, 6, 6,  // 2
        2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,  // 3
        6, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 3, 4, 6, 6,  // 4
        2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,  // 5
        6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 5, 4, 6, 6,  // 6
        2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,  // 7
        2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4,  // 8
        2, 6, 2, 6, 4, 4, 4, 4, 2, 5, 2, 5, 5, 5, 5, 5,  // 9
        2, 6, 2, 6, 3, 3, 3, 4, 2, 2, 2, 2, 4, 4, 4, 4,  // a
        2, 5, 2, 5, 4, 4, 4, 4, 2, 4, 2, 4, 4, 4, 4, 4,  // b
        2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6,  // c
        2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,  // d
        2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6,  // e
        2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7   // f
  ];
  this.ourInstructionPageCrossDelay = [
    //  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 0
        2, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,  // 1
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 2
        2, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,  // 3
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 4
        2, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,  // 5
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 6
        2, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,  // 7
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 8
        2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 9
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // a
        2, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1,  // b
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // c
        2, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,  // d
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // e
        2, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0  // f
  ];
  this.ourInstructionMnemonicTable = [
        "BRK",  "ORA",  "n/a",  "slo",  "nop",  "ORA",  "ASL",  "slo",    // 0x0?
        "PHP",  "ORA",  "ASLA", "anc",  "nop",  "ORA",  "ASL",  "slo",
        
        "BPL",  "ORA",  "n/a",  "slo",  "nop",  "ORA",  "ASL",  "slo",    // 0x1?
        "CLC",  "ORA",  "nop",  "slo",  "nop",  "ORA",  "ASL",  "slo",
        
        "JSR",  "AND",  "n/a",  "rla",  "BIT",  "AND",  "ROL",  "rla",    // 0x2?
        "PLP",  "AND",  "ROLA", "anc",  "BIT",  "AND",  "ROL",  "rla",
        
        "BMI",  "AND",  "n/a",  "rla",  "nop",  "AND",  "ROL",  "rla",    // 0x3?
        "SEC",  "AND",  "nop",  "rla",  "nop",  "AND",  "ROL",  "rla",
        
        "RTI",  "EOR",  "n/a",  "sre",  "nop",  "EOR",  "LSR",  "sre",    // 0x4?
        "PHA",  "EOR",  "LSRA", "asr",  "JMP",  "EOR",  "LSR",  "sre",
        
        "BVC",  "EOR",  "n/a",  "sre",  "nop",  "EOR",  "LSR",  "sre",    // 0x5?
        "CLI",  "EOR",  "nop",  "sre",  "nop",  "EOR",  "LSR",  "sre",
        
        "RTS",  "ADC",  "n/a",  "rra",  "nop",  "ADC",  "ROR",  "rra",    // 0x6?
        "PLA",  "ADC",  "RORA", "arr",  "JMP",  "ADC",  "ROR",  "rra",
        
        "BVS",  "ADC",  "n/a",  "rra",  "nop",  "ADC",  "ROR",  "rra",    // 0x7?
        "SEI",  "ADC",  "nop",  "rra",  "nop",  "ADC",  "ROR",  "rra",
        
        "nop",  "STA",  "nop",  "sax",  "STY",  "STA",  "STX",  "sax",    // 0x8?
        "DEY",  "nop",  "TXA",  "ane",  "STY",  "STA",  "STX",  "sax",
        
        "BCC",  "STA",  "n/a",  "sha",  "STY",  "STA",  "STX",  "sax",    // 0x9?
        "TYA",  "STA",  "TXS",  "shs",  "shy",  "STA",  "shx",  "sha",
        
        "LDY",  "LDA",  "LDX",  "lax",  "LDY",  "LDA",  "LDX",  "lax",    // 0xA?
        "TAY",  "LDA",  "TAX",  "lxa",  "LDY",  "LDA",  "LDX",  "lax",
        
        "BCS",  "LDA",  "n/a",  "lax",  "LDY",  "LDA",  "LDX",  "lax",    // 0xB?
        "CLV",  "LDA",  "TSX",  "las",  "LDY",  "LDA",  "LDX",  "lax",
        
        "CPY",  "CMP",  "nop",  "dcp",  "CPY",  "CMP",  "DEC",  "dcp",    // 0xC?
        "INY",  "CMP",  "DEX",  "sbx",  "CPY",  "CMP",  "DEC",  "dcp",
        
        "BNE",  "CMP",  "n/a",  "dcp",  "nop",  "CMP",  "DEC",  "dcp",    // 0xD?
        "CLD",  "CMP",  "nop",  "dcp",  "nop",  "CMP",  "DEC",  "dcp",
        
        "CPX",  "SBC",  "nop",  "isb",  "CPX",  "SBC",  "INC",  "isb",    // 0xE?
        "INX",  "SBC",  "NOP",  "sbc",  "CPX",  "SBC",  "INC",  "isb",
        
        "BEQ",  "SBC",  "n/a",  "isb",  "nop",  "SBC",  "INC",  "isb",    // 0xF?
        "SED",  "SBC",  "nop",  "isb",  "nop",  "SBC",  "INC",  "isb"
  ];
  this.StopExecutionBit = 0x01;
  this.FatalErrorBit = 0x02;
  this.MaskableInterruptBit = 0x04;
  this.NonmaskableInterruptBit = 0x08;
  this.BCDTable = array2d(2,256);
	for(var t=0;t<256;t++){
		this.BCDTable[0][t] = ((t>>4)*10) + (t & 0x0f);
		this.BCDTable[1][t] = (((t %100) / 10) <<4) | (t % 10);
	}

  this.myCurrentSystem = null;
  this.N = false;
  this.V = false;
  this.B = false;
  this.D = false; 
  this.I = false; 
  this.C = false; 
  this.notZ = false;
  this.A = 0;
  this.X = 0;
  this.Y = 0;
  this.SP = 0; 
  this.IR = 0; 
  this.PC = 0;
  
  this.myExecutionStatus = 0;
  this.myLastOperandAddress = 0;
  this.myLastImmediateValues= [0, 0];
  this.myPageCrossed = false;
  this.myBranchResult = 0;
  this.myCyclesSignaled = 0;
  this.myReadLast = false;
  this.debugStartDump = false;

  this.getRegisterSnapshot = function() {
    var zReturn = [this.A, this.X, this.Y, this.PC, this.SP, this.getFlags()];
    return zReturn;
  }
  this.getFlags = function() {
    var ps = 0x20;
    if (this.N) ps |= 0x80;
    if (this.V) ps |= 0x40;
    if (this.B) ps |= 0x10;
    if (this.D) ps |= 0x08;
    if (this.I) ps |= 0x04;
    if (!this.notZ) ps |= 0x02;
    if (this.C) ps |= 0x01;

    return ps;
  }
  /* Set the system */
  this.install = function(aSystem) {
    this.myCurrentSystem = aSystem;
  }
  this.stop = function() {
    this.myExecutionStatus |= this.StopExecutionBit;
  }

  /* Accessors */
  this.getBCDTable = function() {
    return this.BCDTable;
  }
  this.isN = function() {
    return this.N;
  }
  this.setN = function(inputN) {
    if (typeof inputN == "boolean") this.N = inputN;
    if (typeof inputN == "number") this.N = (inputN!=0);
    return this.N;
  }
  this.isV = function() {
    return this.V;
  }
  this.setV = function(inputV) {
    if(typeof inputV == "boolean") this.V = inputV;
		else this.V = (inputV != 0);
  }
  this.isB = function() {
    return this.B;
  }
  this.setB = function(inputB) {
    if (typeof inputB == "boolean") this.B = inputB;
    if (typeof inputB == "number") this.B = (inputB!=0);
    return this.B;
  }
  this.isD = function() {
    return this.D;   
  }
  this.setD = function(inputD) {
    if (typeof inputD == "boolean") this.D = inputD;
    if (typeof inputD == "number") this.D = (inputD!=0);
    return this.D;
  }
  this.isI = function() {
    return this.I;
  }
  this.setI = function(inputI) {
    if (typeof inputI == "boolean") this.I = inputI;
    if (typeof inputI == "number") this.I = (inputI!=0);
    return this.I;
  }
  this.isNotZ = function() {
    return this.notZ;
  }
  this.setNotZ = function(inputnotZ) {
    if (typeof inputnotZ == "boolean") this.notZ = inputnotZ;
    if (typeof inputnotZ == "number") this.notZ = (inputnotZ!=0);
    return this.notZ;
  }
  this.isC = function() {
    return this.C;
  }
  this.setC = function(inputC) {
    if (typeof inputC == "boolean") this.C = inputC;
    if (typeof inputC == "number") this.C = (inputC!=0);
    return this.C;
  }
  this.getA = function() {
    assert((this.A>=0)&&(this.A<0x100));
    return this.A; 
  }
  this.setA = function(aValue) {
    assert((aValue>=0)&&(aValue<0x100));
    this.A = aValue & 0xFF;
  }
  this.getX = function() {
    return this.X;
  }
  this.setX = function(aValue) {
    assert((aValue>=0)&&(aValue<0x100));
    this.X = aValue & 0xFF;
  }
  this.getY = function() {
    return this.Y;
  } 
  this.setY = function(aValue) {
    assert((aValue>=0)&&(aValue<0x100));
    this.Y = aValue & 0xFF;
  }
  this.getSP = function(aValue) {
    assert((aValue>=0)&&(aValue<0x100));
    return this.SP;
  }
	this.setSP = function(aValue) {
        assert((aValue>=0)&&(aValue<0x100));
        this.SP = aValue;
    }
  this.SPdec = function() {
    var oldSP = this.SP;
    this.SP = ((this.SP-1)&0xFF);
    return oldSP;
  }
  this.SPinc = function() {
    var oldSP = this.SP;
    this.SP = ((this.SP+1)&0xFF);
    return oldSP;
  }
  this.getIR = function() {
    return this.IR;
  }
  this.setIR = function(aValue) {
    assert((aValue>=0)&&(aValue<0x100));
    this.IR = aValue;
  }
  this.getPC = function() {
    return this.PC;
  }
  this.setPC = function(aPC) {
    this.PC = aPC;
  }
  

  /* Genereal Methods */
  this.lastAccessWasRead = function() {
    return this.myReadLast;
  }
  this.notSamePage = function(aAddrA, aAddrB) {
    return ((((aAddrA)^(aAddrB)) & 0xFF00)!=0);
  }
  this.execute = function(aRepeats) {
    if (aRepeats === undefined || aRepeats === null) aRepeats = -1;
    
    var zContinue = true;
    this.myExecutionStatus &= this.FatalErrorBit;
    var zCounter = 0;

    while (zContinue) {
      if ((aRepeats >= 0) && (zCounter == aRepeats)) {
        zContinue = false;
        break;
      }
      else zCounter++;
      if (zContinue==false) {
        break;
      }
      var zPreSnapShot = null;
      if (DEBUG_MODE_ON) zPreSnapShot = this.getRegisterSnapshot();
      var zOpPC = this.getPC();
      this.IR = this.peekImmediate();
      var zOperand = 0;
      var zOperandAddress = 0;

			
      switch (this.IR) {
        case 0x00 :   
          this.INSTR_BRK();
          break;
        case 0x69 :
        case 0x65 :
        case 0x75 :
        case 0x6d :
        case 0x7d :
        case 0x79 :
        case 0x61 :
        case 0x71 :
          zOperand= this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_ADC(zOperand);
          break;
        case 0xA9 :
        case 0xA5 :
        case 0xB5 :
        case 0xAD :
        case 0xBD :
        case 0xB9 :
        case 0xA1 :
        case 0xB1 :
          zOperand= this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_LDA(zOperand);
          break;
        case 0xA2 :
        case 0xA6 :
        case 0xB6 :
        case 0xAE :
        case 0xBE :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_LDX(zOperand);
          break;
        case 0xA0 :
        case 0xA4 :
        case 0xB4 :
        case 0xAC :
        case 0xBC :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_LDY(zOperand);
          break;
        case 0x29 :
        case 0x25 :
        case 0x35 :
        case 0x2D :
        case 0x3D :
        case 0x39 :
        case 0x21 :
        case 0x31 :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_AND(zOperand);
          break;
        case 0x0A : this.INSTR_ASLA(); break;
        case 0x06 :
        case 0x16 :
        case 0x0E :
        case 0x1E :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          zOperandAddress=this.myLastOperandAddress;
          this.INSTR_ASL(zOperand, zOperandAddress);
          break;
        case 0x24 :
        case 0x2C :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_BIT(zOperand);
          break;
        case 0x18 : this.INSTR_CLC(); break;
        case 0x38 : this.INSTR_SEC(); break;
        case 0x58 : this.INSTR_CLI(); break;
        case 0x78 : this.INSTR_SEI(); break;
        case 0xB8 : this.INSTR_CLV(); break;
        case 0xD8 : this.INSTR_CLD(); break;
        case 0xF8 : this.INSTR_SED(); break;
        case 0xC9 :
        case 0xC5 :
        case 0xD5 :
        case 0xCD :
        case 0xDD :
        case 0xD9 :
        case 0xC1 :
        case 0xD1 :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_CMP(zOperand);
          break;
        case 0xE0 :
        case 0xE4 :
        case 0xEC :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_CPX(zOperand);
          break;
        case 0xC0 :
        case 0xC4 :
        case 0xCC :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_CPY(zOperand);
          break;
        case 0xC6 :
        case 0xD6 :
        case 0xCE :
        case 0xDE :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          zOperandAddress=this.myLastOperandAddress;
          this.INSTR_DEC(zOperand, zOperandAddress);
          break;
        case 0x49 :
        case 0x45 :
        case 0x55 :
        case 0x4D :
        case 0x5D :
        case 0x59 :
        case 0x41 :
        case 0x51 :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_EOR(zOperand);
          break;
        case 0xE6 :
        case 0xF6 :
        case 0xEE :
        case 0xFE :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          zOperandAddress=this.myLastOperandAddress;
          this.INSTR_INC(zOperand, zOperandAddress);
          break;
        case 0xAA : this.INSTR_TAX(); break;
        case 0x8A : this.INSTR_TXA(); break;
        case 0xCA : this.INSTR_DEX(); break;
        case 0xE8 : this.INSTR_INX(); break;
        case 0xA8 : this.INSTR_TAY(); break;
        case 0x98 : this.INSTR_TYA(); break;
        case 0x88 : this.INSTR_DEY(); break;
        case 0xC8 : this.INSTR_INY(); break;
        case 0x4C :
          this.peekAbsoluteJMP();
          this.INSTR_JMP(zOperand, this.myLastOperandAddress);
          break;
        case 0x6C :
          this.peekIndirect();
          this.INSTR_JMP(zOperand, this.myLastOperandAddress);
          break;
        case 0x20 :  this.INSTR_JSR(); break;
        case 0x4A : this.INSTR_LSRA(); break;
        case 0x46 :
        case 0x56 :
        case 0x4E :
        case 0x5E :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          zOperandAddress=this.myLastOperandAddress;
          this.INSTR_LSR(zOperand, zOperandAddress);
          break;
        case 0xEA : 
          this.INSTR_NOP(); break;
        case 0x09 :
        case 0x05 :
        case 0x15 :
        case 0x0D :
        case 0x1D :
        case 0x19 :
        case 0x01 :
        case 0x11 :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_ORA(zOperand);
          break;
        case 0x9A : this.INSTR_TXS(); break;
        case 0xBA : this.INSTR_TSX(); break;
        case 0x48 : this.INSTR_PHA(); break;
        case 0x68 : this.INSTR_PLA(); break;
        case 0x08 : this.INSTR_PHP(); break;
        case 0x28 : this.INSTR_PLP(); break;
        case 0x2A : this.INSTR_ROLA(); break;
        case 0x26 :
        case 0x36 :
        case 0x2E :
        case 0x3E :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          zOperandAddress=this.myLastOperandAddress;
          this.INSTR_ROL(zOperand, zOperandAddress);
          break;
        case 0x6A : this.INSTR_RORA(); break;
        case 0x66 :
        case 0x76 :
        case 0x6E :
        case 0x7E :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          zOperandAddress=this.myLastOperandAddress;
          this.INSTR_ROR(zOperand, zOperandAddress);
          break;
        case 0x40 : this.INSTR_RTI(); break;
        case 0x60 : this.INSTR_RTS(); break;
        case 0xE9 :
        case 0xE5 :
        case 0xF5 :
        case 0xED :
        case 0xFD :
        case 0xF9 :
        case 0xE1 :
        case 0xF1 :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_SBC(zOperand);
          break;
        case 0x85 :
        case 0x95 :
        case 0x8D :
        case 0x9D :
        case 0x99 :
        case 0x81 :
        case 0x91 :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          zOperandAddress=this.myLastOperandAddress;
          this.INSTR_STA(zOperand, zOperandAddress);
          break;
        case 0x86 :
        case 0x96 :
        case 0x8E :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          zOperandAddress=this.myLastOperandAddress;
          this.INSTR_STX(zOperand, zOperandAddress);
          break;
        case 0x84 :
        case 0x94 :
        case 0x8C :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          zOperandAddress=this.myLastOperandAddress;
          this.INSTR_STY(zOperand, zOperandAddress);
          break;
        case 0x10 :
          zOperand=this.peekImmediate();
          this.INSTR_BPL(zOperand);
          break;
        case 0x30 :
          zOperand=this.peekImmediate();
          this.INSTR_BMI(zOperand);
          break;
        case 0x50 :
          zOperand=this.peekImmediate();
          this.INSTR_BVC(zOperand);
          break;
        case 0x70 :
          zOperand=this.peekImmediate();
          this.INSTR_BVS(zOperand);
          break;
        case 0x90 :
          zOperand=this.peekImmediate();
          this.INSTR_BCC(zOperand);
          break;
        case 0xB0 :
          zOperand=this.peekImmediate();
          this.INSTR_BCS(zOperand);
          break;
        case 0xD0 :
          zOperand=this.peekImmediate();
          this.INSTR_BNE(zOperand);
          break;
        case 0xF0 :
          zOperand=this.peekImmediate();
          this.INSTR_BEQ(zOperand);
          break;
        case 0x87 :
        case 0x97 :
        case 0x83 :
        case 0x8F :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          zOperandAddress=this.myLastOperandAddress;
          this.INSTR_sax(zOperand, zOperandAddress);
          break;
        case 0xA3 :
        case 0xA7 :
        case 0xB3 :
        case 0xAF :
        case 0xB7 :
        case 0xBF :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_lax(zOperand);
          break;
        case 0xCB :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_sbx(zOperand);
          break;
        case 0x04 : 
        case 0x0C : 
        case 0x14 :
        case 0x1C :
        case 0x1A :
        case 0x34 :
        case 0x3C : 
        case 0x3A :
        case 0x44 :
        case 0x54 :
        case 0x5C :
        case 0x5A :
        case 0x64 :
        case 0x74 :
        case 0x7C :
        case 0x7A :
        case 0x80 :
        case 0x82 :
        case 0x89 : 
        case 0xC2 :
        case 0xD4 :
        case 0xDC :
        case 0xDA :
        case 0xE2 :
        case 0xF4 :
        case 0xFC :
        case 0xFA :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_nop(zOperand);
          break;
        case 0xC3 :
        case 0xC7 :
        case 0xCF :
        case 0xD3 :
        case 0xD7 :
        case 0xDB :
        case 0xDF :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          zOperandAddress=this.myLastOperandAddress;
          this.INSTR_dcp(zOperand, zOperandAddress);
          break;
        case 0xE3 :
        case 0xE7 :
        case 0xEF :
        case 0xF3 :
        case 0xF7 :
        case 0xFB :
        case 0xFF :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          zOperandAddress=this.myLastOperandAddress;
          this.INSTR_isb(zOperand, zOperandAddress);
          break;
        case 0x03 :
        case 0x07 :
        case 0x0F :
        case 0x13 :
        case 0x17 :
        case 0x1B :
        case 0x1F :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          zOperandAddress=this.myLastOperandAddress;
          this.INSTR_slo(zOperand, zOperandAddress);
          break;
        case 0x4B :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          this.INSTR_asr(zOperand);
          break;    
        case 0x27 :
        case 0x37 :
        case 0x2F :
        case 0x3F :
        case 0x3B :
        case 0x23 :
        case 0x33 :
          zOperand=this.retrieveOperand(this.ourAddressingModeTable[this.IR]);
          zOperandAddress=this.myLastOperandAddress;
          this.INSTR_rla(zOperand, zOperandAddress);
          break;
        default :
//          alert(this.IR);
          // TODO : Throw Exception
//					return;
      }
      var zCycles = this.calculateCycles(this.IR) - this.myCyclesSignaled;
      if (zCycles < 0) {
        var zDebug = 20;
      }
      assert(zCycles>=0);
      this.myCurrentSystem.processorCycle(zCycles); // TODO : Processor class is undefined!
      this.myCyclesSignaled = 0;

      if (((this.myExecutionStatus & this.MaskabaleInsterruptBit) != 0) || (this.myExecutionStatus & this.NonmaskableInterruptBit) != 0) {
        assert(false);
        // InterruptHandlers(); ::1250 in J6507.java
      }
      if ((this.myExecutionStatus & this.StopExecutionBit) != 0) {
        break;
      }

    }
    return zCounter;
  }
  this.signalCycle = function() {
    this.myCurrentSystem.processorCycle(1);
    this.myCyclesSignaled++;
  }
  this.calculateCycles = function(aIR) {
    var zCycleNum = this.ourInstructionProcessorCycleTable[aIR];
    var zIsBranch = (this.ourInstructionPageCrossDelay[aIR]==2);
    var zPageDependent = (this.ourInstructionPageCrossDelay[aIR] == 1);
    if ((zIsBranch == true)) zCycleNum += this.myBranchResult;
    else if ((zPageDependent == true) && (this.myPageCrossed == true)) zCycleNum++;
    return zCycleNum;
  }
  this.reset = function() {
    this.myExecutionStatus = 0;
    this.A = 0x00;
    this.X = 0x00;
    this.Y = 0x00;
    this.SP = 0xff;
    this.setFlags(0x20);
    this.setPC(this.myCurrentSystem.getResetPC());
  }
  this.peek = function(aAddress, aSignalCycle) {
    if (aSignalCycle === undefined) return this.peek(aAddress, true);
    assert(aAddress>=0);
    this.myReadLast = true;
    this.myLastOperandAddress = aAddress;
    if (aSignalCycle == true) this.signalCycle();
    return this.myCurrentSystem.peek(aAddress);
  }
  this.peekImmediate = function() {
    var zReturn = this.peek(this.PC);
    this.PC++;
    this.myLastImmediateValues[1] = this.myLastImmediateValues[0];
    this.myLastImmediateValues[0] = zReturn;
    return zReturn;
  }
  this.peekZeroPage = function(aAdd) {
    if (aAdd === undefined || aAdd === null) {
      var zAddr = this.peekImmediate();
      return this.peek(zAddr);
    }
    else {
      var zAddr = this.peekImmediate();
      this.peek(zAddr);
      zAddr += aAdd;
      zAddr &= 0xFF;
      return this.peek(zAddr);
    }
  }
  this.peekAbsolute = function() {
    var zLowByte = this.peekImmediate();
    var zHighByte = this.peekImmediate();
    var zAddr = (zLowByte | (zHighByte << 8));
    this.myPageCrossed = false;
    return this.peek(zAddr);
  }
  this.peekAbsoluteJMP = function() {
    var zLowByte = this.peekImmediate();
    var zHighByte = this.peekImmediate();
    var zAddr = (zLowByte | (zHighByte << 8));

    this.myPageCrossed = false;
    return this.peek(zAddr, false);
  }
  this.peekAbsoluteIndex = function(aAdd) {
    var zLowByte = this.peekImmediate();
    var zHighByte = this.peekImmediate();
    var zAddr = (zLowByte | (zHighByte << 8));
    zAddr += aAdd;

    if (zLowByte + aAdd > 0xFF) {
      this.peek(zAddr);
      this.myPageCrossed = true;
    }
    else this.myPageCrossed = false;
    return this.peek(zAddr);
  }
  this.peekIndirect = function() {
    var zLowByte = this.peekImmediate();
    var zHighByte = this.peekImmediate();
    var zAddr = (zLowByte | (zHighByte << 8));
    var zLowByteB = this.peek(zAddr);
    var zHighByteB = this.peek((zAddr+1));
    var zAddrB = (zLowByteB | (zHighByteB << 8));
    return this.peek(zAddrB, false);
  }
  this.peekIndirectX = function () {
    var zZeroPage = (this.peekImmediate() + this.X)&0xFF;
    var zLowByte = this.peek(zZeroPage);
    var zHighByte = this.peek(((zZeroPage+1)&0xFF));
    var zAddr = (zLowByte | (zHighByte << 8));
    var zReturn = this.peek(zAddr);
    return zReturn;
  }
  this.peekIndirectY = function() {
    var zZeroPage = this.peekImmediate();
    var zLowByte = this.peek(zZeroPage);
    var zHighByte = this.peek(zZeroPage + 1);
    var zAddr = (zLowByte | (zHighByte << 8)) + this.Y;
    if (zLowByte + this.Y > 0xFF) {
      this.peek(zAddr);
      this.myPageCrossed = true;
    }
    else this.myPageCrossed = false;
    return this.peek(zAddr);
  }
  this.peekRelative = function() {
    var zOldPC = this.PC;
    var zByte = this.peekImmediate();
    var zAdd = this.toSignedByteValue(zByte);
    return zOldPC + zAdd;
  }
  this.toSignedByteValue = function(aUBV) {
    assert(aUBV>=0);
    assert(aUBV<256);
    if ((aUBV >= 0) && (aUBV <= 127)) return aUBV;
    else return aUBV - 256;
  }
  this.retrieveOperand = function(aMode) {
    if (aMode==this.AddressingMode.Immediate) return this.peekImmediate();
    else if (aMode==this.AddressingMode.Zero) return this.peekZeroPage();
    else if (aMode==this.AddressingMode.ZeroX) return this.peekZeroPage(this.X);
    else if (aMode==this.AddressingMode.ZeroY) return this.peekZeroPage(this.Y);
    else if (aMode==this.AddressingMode.Indirect) return this.peekIndirect();
    else if (aMode==this.AddressingMode.IndirectX) return this.peekIndirectX();
    else if (aMode==this.AddressingMode.IndirectY) return this.peekIndirectY();
    else if (aMode==this.AddressingMode.Absolute) return this.peekAbsolute();
    else if (aMode==this.AddressingMode.AbsoluteX) return this.peekAbsoluteIndex(this.X);
    else if (aMode==this.AddressingMode.AbsoluteY) return this.peekAbsoluteIndex(this.Y);
    else if (aMode==this.AddressingMode.Relative) return this.peekRelative();
    else {
      assert(false);
      return 0;
    }
  }
  this.poke = function(aAddress, aByteValue) {
    assert((aByteValue<0x100)&&(aByteValue)>=0x00);
    if (aAddress >= 0) {
      this.myCurrentSystem.poke(aAddress, aByteValue);
    }
    this.myReadLast = false;
  }
  this.setFlags = function(aByteValue) {
    this.N = ((aByteValue & 0x80)!=0);
    this.V = ((aByteValue & 0x40)!=0);
    this.B = ((aByteValue & 0x10)!=0); //;  The 6507's B flag always true
    this.D = ((aByteValue & 0x08)!=0);
    this.I = ((aByteValue & 0x04)!=0);
    this.notZ = !((aByteValue & 0x02)!=0);
    this.C = ((aByteValue & 0x01)!=0);
  }
  this.getBit = function(aByte, aBitNumber) {
    return ((aByte & (0x01 << aBitNumber)) != 0);
  }

  /* INSTRUCTIONS */
  this.INSTR_ADC = function (operand) {
    assert((operand>=0)&&(operand<0x100));
    var oldA = this.A;
    if(!this.D) {
      var zSignedSum=(this.A + operand);
      if (this.C==true) zSignedSum++;
      this.V = ((zSignedSum > 127) || (zSignedSum < -128)); //overflow
      var zUSum = this.A +operand;
      if (this.C==true) zUSum++;
      this.setC(zUSum > 0xff);
      this.setA(zUSum & 0xFF);
      this.setNotZ((zUSum & 0xff)!=0);
      this.setN(this.getBit(this.A, 7));
    } 
    else {
      var sum = this.BCDTable[0][this.A] + this.BCDTable[0][operand] + (this.C ? 1 : 0);
      this.setC(sum > 99);
      this.setA(this.BCDTable[1][sum & 0xff]);
      this.setNotZ(this.A!=0);
      this.setN(this.getBit(this.A, 7));
      this.V=(((oldA ^ this.A) & 0x80)!=0) && (((this.A ^ operand) & 0x80)!=0);
    }
  }
  this.INSTR_SBC = function (operand) { 
    var oldA = this.A & 0xFF;
    assert((operand>=0)&&(operand<0x100));
    if(!this.D) {
      var zRevOperand = (~operand) & 0xFF; 
      var zAmountToAdd = this.toSignedByteValue(zRevOperand) + (this.C ? 1 : 0); //if carry is on, amountToAdd= -1 * amountToSubtract, else it's one less (i.e. more negative)
      var zSignedResult = this.toSignedByteValue(this.A) + zAmountToAdd ;       
      this.setV(((zSignedResult > 127) || (zSignedResult < -128)));
      var zNewA = this.A + zAmountToAdd;
      var zAmountToSubtract=operand + (this.C ? 0 : 1);  
      this.setC(zAmountToSubtract<= oldA);
      this.setA(zNewA & 0xFF);
      this.setNotZ(this.A!=0);
      this.setN((this.A & 0x80)!=0);
    } 
    else {
      var difference = this.BCDTable[0][this.A] - this.BCDTable[0][operand] - (this.C ? 0 : 1);
      if(difference < 0)
        difference += 100;
        this.setA(this.BCDTable[1][difference]);
        this.setNotZ(this.A!=0);
        this.setN((this.A & 0x80)!=0);
        this.setC((oldA >= (operand + (this.C ? 0 : 1))));
        this.setV((((oldA ^ this.A) & 0x80)!=0) && (((this.A ^ operand) & 0x80)!=0));
    }
  }
  this.INSTR_LDA = function (aValue) {
    this.setA(aValue);
    this.notZ = (this.A!=0);
    this.N = ((this.A & 0x80)!=0);
  }
  this.INSTR_LDX = function (operand) {
    assert(operand<0x100);
    this.setX(operand);
    this.notZ = (this.X!=0);
    this.N = ((this.X & 0x80)!=0);
  }    
  this.INSTR_LDY = function (operand) {
    this.Y = operand;
    this.notZ = (this.Y!=0);
    this.N = ((this.Y & 0x80)!=0);
  }
  this.INSTR_AND = function (aValue) { 
    var zNewA= this.getA() & aValue;
    this.setA(zNewA);
    this.setNotZ(zNewA!=0);
    this.setN((zNewA & 0x80)!=0);
  }
  this.INSTR_EOR = function (aValue) {
    var zNewA = this.getA() ^ aValue;
    this.setA(zNewA);
    this.setNotZ(zNewA!=0);
    this.setN((zNewA & 0x80)!=0);
  }
  this.INSTR_ORA = function(aValue) { 
    var zNewA= this.getA() | aValue;
    this.setA(zNewA);
    this.setNotZ(zNewA!=0);
    this.setN((zNewA & 0x80)!=0);
  }
  this.INSTR_ASL = function (aValue, operandAddress) {
    this.setC(aValue & 0x80);
    aValue <<= 1;
    aValue &= 0xFF;
    this.poke(operandAddress, aValue);
    this.setNotZ(aValue!=0);
    this.setN(aValue & 0x80);
  }
  this.INSTR_ASLA = function() {
    this.setC(this.A & 0x80);
    var zNewA= this.getA()  << 1;
    zNewA&=0xFF;
    this.setA(zNewA);
    this.setNotZ(this.A!=0);
    this.setN((this.A & 0x80)!=0);
  }
  this.branch = function (aDoBranch, aDelta) {
    if(aDoBranch==true) {
      this.peek(this.PC);
      var address = this.PC + this.toSignedByteValue(aDelta);
      if(this.notSamePage(this.PC, address)) this.myBranchResult=2;
      else this.myBranchResult=1;
      this.setPC(address);
    } 
    else this.myBranchResult=0;
  }
  this.INSTR_BCC = function (operand) { this.branch(!this.C, operand); }    
  this.INSTR_BCS = function (operand) { this.branch(this.C, operand);  }    
  this.INSTR_BEQ = function (operand) { this.branch(!this.notZ, operand);  }   
  this.INSTR_BMI = function (operand) { this.branch(this.N, operand);  }    
  this.INSTR_BNE = function (operand) { this.branch(this.notZ, operand);  }    
  this.INSTR_BPL = function (operand) { this.branch(!this.N, operand);   }    
  this.INSTR_BVC = function (operand) { this.branch(!this.V, operand);   }    
  this.INSTR_BVS = function (operand) { this.branch(this.V, operand);   }
  this.INSTR_BIT = function (operand) {
    this.setNotZ(this.A & operand);
    this.setN(operand & 0x80);
    this.setV(operand & 0x40);
  }
  this.INSTR_BRK = function () { 
    this.peek(this.PC++);
    this.B = true;
    this.poke(0x0100 + this.SPdec(), this.PC >> 8);
    this.poke(0x0100 + this.SPdec(), this.PC & 0x00ff);
    this.poke(0x0100 + this.SPdec(), this.getFlags());
    this.I = true;
    this.PC=this.peek(0xfffe);
    this.PC |= (this.peek(0xffff) << 8);
  }
  this.INSTR_CLC = function () {this.setC(false); }
  this.INSTR_CLD = function () {this.setD(false);   }    
  this.INSTR_CLI = function () {this.setI(false);   }    
  this.INSTR_CLV = function () {this.setV(false); }
  this.INSTR_SEC = function () { this.setC(true); }    
  this.INSTR_SED = function () { this.setD(true); }    
  this.INSTR_SEI = function () { this.setI(true); }
  this.INSTR_CMP = function (operand) { 
    var value = this.A - operand;
    this.setNotZ(value);
    this.setN(value & 0x0080);
    this.setC(((value & 0x0100)==0));
  }
  this.INSTR_CPX = function (operand) {
    var value = this.X - operand;
    this.setNotZ(value);
    this.setN(value & 0x0080);
    this.setC((value & 0x0100)==0);
  }
  this.INSTR_CPY = function (operand) {
    var value = this.Y - operand;
    this.setNotZ(value);
    this.setN(value & 0x0080);
    this.setC((value & 0x0100)==0);
  }
  this.INSTR_DEC = function (operand, operandAddress) { 
		var value = operand - 1;
    value &= 0xFF;
    this.poke(operandAddress, value);
    this.setNotZ(value);
    this.setN(value & 0x80);
  }
  this.INSTR_DEX = function () { 
    this.X--;
    this.X&=0xFF; //masking, in case it went below zero
    this.notZ = (this.X!=0);
    this.N = ((this.X & 0x80)!=0);
  }
  this.INSTR_DEY = function() { //OK
    this.Y--;
    this.Y&=0xFF; //masking, in case it went below zero
    this.notZ = (this.Y!=0);
    this.N = ((this.Y & 0x80)!=0);
  }
  this.INSTR_INC = function (operand, operandAddress) { //ok
    var value = operand + 1;
    value &=0xFF;
    this.poke(operandAddress, value);
    this.setNotZ(value);
    this.setN(value & 0x80);
  }
  this.INSTR_INX = function () { //OK
    this.X++;
    this.X &=0xFF;
    assert(this.X<0x100);
    this.notZ = (this.X!=0);
    this.N = ((this.X & 0x80)!=0);
  }
  this.INSTR_INY = function () { //OK
    this.Y++;
    this.Y &=0xFF;
    this.notZ = (this.Y!=0);
    this.N = ((this.Y & 0x80)!=0);
  }
  this.INSTR_JMP = function (operand, operandAddress) { //OK
    this.PC=operandAddress;
  }
  this.INSTR_JSR = function() { //OK
    var low = this.peekImmediate();//PC++);
    this.peek(0x0100 + this.SP);
    this.poke(0x0100 + this.SPdec(), this.PC >>> 8);
      this.poke(0x0100 + this.SPdec(), this.PC & 0xff);
      var high= this.peekImmediate();
      this.PC=(low | (high << 8));
    }
  this.INSTR_RTS = function() { //OK
    this.peek(0x0100 + this.SPinc());
    var zAddr=0;
    zAddr=this.peek(0x100 + this.SPinc());
    var zNewPC= (zAddr | (this.peek(0x0100 + this.SP) << 8));
    this.setPC(zNewPC);
    this.peek(this.PC++);
  }
  this.INSTR_LSR = function (operand, operandAddress) { //OK
    this.setC(operand & 0x01);
    operand = (operand >> 1) & 0x7f;
    this.poke(operandAddress, operand);
    this.notZ = (operand!=0);
    this.setN(operand & 0x80);
  }
  this.INSTR_LSRA = function() { //OK
    this.setC(this.A & 0x01);
    this.setA( (this.getA() >> 1) & 0x7f);
    this.setNotZ(this.A!=0);
    this.setN((this.A & 0x80)!=0);
  }
  this.INSTR_NOP = function() {  //OK
  } 
  this.INSTR_PHA = function() { //OK
    this.poke(0x0100 + this.SPdec(), this.A);
  }
  this.INSTR_PHP = function() { //OK
    this.poke(0x0100 + this.SPdec(), this.getFlags());
  }
  this.INSTR_PLA = function() { //OK
    this.peek(0x0100 + this.SPinc());
    this.setA(this.peek(0x0100 + this.SP));
    this.setNotZ(this.A!=0);
    this.setN((this.A & 0x80)!=0);
  }
  this.INSTR_PLP = function() { //OK
    this.peek(0x0100 + this.SPinc());
    this.setFlags(this.peek(0x0100 + this.SP));
  }
  this.INSTR_ROL = function(operand, operandAddress) { //OK
    var oldC=this.C;
    this.setC(operand & 0x80);
    operand = ((operand << 1) | (oldC ? 1 : 0))& 0xFF;
    this.poke(operandAddress, operand);
    this.notZ = (operand!=0);
    this.setN(operand & 0x80);
  }
  this.INSTR_ROLA = function() { //OK
    var oldC=this.C;
    this.setC(this.A & 0x80);
    var zNewA=(this.getA() << 1) | (oldC ? 1 : 0);
    this.setA(zNewA & 0xFF);
    this.setNotZ(this.A!=0);
    this.N = ((this.A & 0x80)!=0);
  }
  this.INSTR_ROR = function (operand, operandAddress) { 
    var oldC=this.C;
    this.setC(operand & 0x01);
    operand = ((operand >> 1) & 0x7f) | (oldC ? 0x80 : 0x00);
    this.poke(operandAddress, operand);
    this.notZ = (operand!=0);
    this.setN(operand & 0x80);
  }
  this.INSTR_RORA = function() {
    var oldC=this.C;
    this.setC(this.A & 0x01);
    var zOldA=this.getA();
    var zNewA=((this.getA() >> 1) & 0x7f) | (oldC ? 0x80 : 0x00);
    this.setA(zNewA);
    this.notZ = (zNewA!=0);
    this.N = ((zNewA & 0x80)!=0);
  }
  this.INSTR_RTI = function() { 
    this.peek(0x0100 + this.SPinc());
    this.setFlags(this.peek(0x0100 + this.SPinc()));
    this.PC=this.peek(0x0100 + this.SPinc());
    this.PC |= (this.peek(0x0100 + this.SP) << 8);
  }
  this.INSTR_STA = function (operand, operandAddress) { //OK
    this.poke(operandAddress, this.getA());
  }
  this.INSTR_STX = function (operand, operandAddress) { //ok
    this.poke(operandAddress, this.X);
  }
  this.INSTR_STY = function (operand, operandAddress) { //ok
    this.poke(operandAddress, this.Y);
  }
  this.INSTR_TAX = function() { //OK
    this.X = this.A;
    this.notZ = (this.X!=0);
    this.N = ((this.X & 0x80)!=0);
  }
  this.INSTR_TAY = function() { //OK
    this.Y = this.A;
    this.notZ = (this.Y!=0);
    this.N = ((this.Y & 0x80)!=0);
  }
  this.INSTR_TSX = function() { //OK
    this.X = this.SP;
    this.notZ = (this.X!=0);
    this.N = ((this.X & 0x80)!=0);
  }
  this.INSTR_TXA = function() { //OK
    this.setA(this.X);
    this.notZ = (this.A!=0);
    this.N = ((this.A & 0x80)!=0);
  }
  this.INSTR_TXS = function() { //OK
    this.setSP(this.X);
  }
  this.INSTR_TYA = function() { //OK
    this.setA(this.Y);
    this.notZ = (this.A!=0);
    this.N = ((this.A & 0x80)!=0);
  }
  // ************** UNOFFICIAL INSTRUCTIONS ****************************  
  this.INSTR_sax = function (operand, operandAddress) { 
    this.poke(operandAddress, this.A & this.X);
  }
  this.INSTR_lax = function (aValue) { 
    this.setA(aValue);
    this.setX(aValue);
    this.notZ = (this.A!=0);
    this.N = ((this.A & 0x80)!=0);
  }
  this.INSTR_sbx = function (operand) { 
    var difference = ((this.A&this.X)&0xff)-operand;
    this.setC((difference & 0x100)==0);
    difference &= 0xff;
    this.setX(difference);
    this.setNotZ(difference!=0);
    this.setN((difference & 0x80)!=0);
  }
  this.INSTR_asr = function (operand) { 
    var myA = this.A&operand;
    this.setC(myA & 0x01);
 	  myA = (myA >> 1) & 0x7f;
    this.setA(myA);
    this.setNotZ(myA!=0);
    this.setN((myA & 0x80)!=0);
  }
  this.INSTR_rla = function (operand, operandAddress) { //TODO: Double check code--it is untested
    var zValue = (operand << 1) | (this.C ? 1 : 0);
    this.poke(operandAddress, zValue);
    var zNewA = this.A & zValue; 
    this.setA(zNewA & 0xFF);
    this.setC(operand & 0x80);
    this.setNotZ(zNewA);
    this.setN(zNewA & 0x80);
  }
  this.INSTR_nop = function (operand) {  //do nothing (??)
  }
  this.INSTR_dcp = function (operand, operandAddress) { //OK
    var value = operand - 1;
    value &= 0xFF;
    this.poke(operandAddress, value);
    value = this.A - value;
    this.setNotZ(value);
    this.setN(value & 0x0080);
    this.setC(((value & 0x0100)==0));
  }
  this.INSTR_isb =function (operand, operandAddress) { 
    var value = operand + 1;
    value &=0xFF;
    this.poke(operandAddress, value);
    var oldA = this.A;
    if(!this.D) {
      var zRevOperand = (~value) & 0xFF; 
      var Sdifference = this.toSignedByteValue(this.A) + this.toSignedByteValue(zRevOperand) + (this.C ? 1 : 0);
      this.setV(((Sdifference > 127) || (Sdifference < -128)));
      var zSBV= this.toSignedByteValue(zRevOperand);
      var difference = this.A + zSBV + (this.C ? 1 : 0);
      var zSubAmount=value + (this.C ? 0 : 1);
      this.setC(zSubAmount<= oldA);
      this.setA(difference & 0xFF);
      this.setNotZ(this.A!=0);
      this.setN((this.A & 0x80)!=0);
    } else {
      var difference = this.BCDTable[0][this.A&0xff] - this.BCDTable[0][value&0xff] - (this.C ? 0 : 1);
      if(difference < 0)
        difference += 100;
      this.setA(this.BCDTable[1][difference&0xff]);
      this.setNotZ(this.A!=0);
      this.setN((this.A & 0x80)!=0);
      this.setC((oldA >= (value + (this.C ? 0 : 1))));
      this.setV((((oldA ^ this.A) & 0x80)!=0) && (((this.A ^ value) & 0x80)!=0));
    }
  }
  this.INSTR_slo = function (operand, operandAddress) { 
    this.setC(operand & 0x80);
    operand <<= 1;
    operand &= 0xFF;
    this.poke(operandAddress, operand);
    this.INSTR_ORA(operand);
  }
  //constructor
  this.install(aSystem);
}

function JSController() {
  this.serialVersionUID;
  this.JOYSTICK_UP = 0;
  this.JOYSTICK_DOWN=1;
  this.JOYSTICK_LEFT=2;
  this.JOYSTICK_RIGHT=3;
  this.JOYSTICK_BUTTON=5;

  this.PADDLE_ALPHA_BUTTON = 3;
  this.PADDLE_BETA_BUTTON=2;
  this.PADDLE_ALPHA_RESISTANCE = 8;
  this.PADDLE_BETA_RESISTANCE = 4;

  this.BOOSTERGRIP_BOOSTER = 4;
  this.BOOSTERGRIP_TRIGGER = 8;

  this.PaddleID = {
    PADDLE_ALPHA: "PADDLE_ALPHA",
    PADDLE_BETA: "PADDLE_BETA"
  };

  this.myJack = Jack.LEFT; // TODO
	this.myPinValue = [0,0,0,0,0,0,0,0];

  this.JSController = function () {
    this.resetController();
  }
  this.resetController = function() {
    var i;
    for (i=0;iL<this.myPinValue.length;i++) {
      this.myPinValue[i] = 1;
    }
    this.setPaddlePosition(this.PaddleID.PADDLE_ALPHA, 00);
    this.setPaddlePosition(this.PaddleID.PADDLE_BETA, 00);
  }

  this.read = function (pin) {
    // TODO
    if (pin <10 ) return (this.myPinValue[this.getPinIndex(pin)]!=0);
    if (pin >=10) return (this.myPinValue[this.getPinIndex(pin)]);
  }
  this.write = function (pin, value) {
  }
  this.setJoystickState = function(aJoystickDir, aPressed) {
    if (aPressed == true) this.myPinValue[aJoystickDir] = 0;
    else this.myPinValue[aJoystickDir] =1;
  }
  this.setPaddleTrigger = function(aID, aPressed) {
    var zValue = (aPressed)? 0: 1;
    if (aID == this.PaddleID.PADDLE_ALPHA) this.myPinValue[this.PADDLE_ALPHA_BUTTON] = zValue;
    else if (aID == this.PaddleID.PADDLE_BETA) this.myPinValue[this.PADDLE_BETA_BUTTON] = zValue;
  }
  this.changeControllerState = function (aControlEventType, aOn) {
    var zValue = (aOn)? 0: 1;
    this.myPinValue[aControlEventT$ype] = zValue;
  }
  this.toPercentX = function (aResistance) {
    return Math.floor(10- (aResistance/10000.0));
  }
  this.toResistance = function (aPercentX) {
    return Math.floor(10000.0 * (100 - aPercentX));
  }
  this.setPaddlePosition = function (aID, aPercentage) {
    var zNewPercent = (aPercentage>100)? 100: aPercentage;
    zNewPercent = (zNewPercent>0)? zNewPercent: 0;
    var zRes = toResistance(zNewPercent);
    if (aID == this.PaddleID.PADDLE_ALPHA) this.myPinValue[this.PADDLE_ALPHA_RESISTANCE] = zRes;
    else if (aID == this.PaddleID.PADDLE_BETA) this.myPinValue[this.PADDLE_BETA_RESISTANCE] = zRes;
  }
  this.getPaddlePosition = function(aID) {
    var zIndex = (aID == this.PaddleID.PADDLE_BETA)? PADDLE_BETA_RESISTANCE: PADDLE_ALPHA_RESISTANCE;
    return this.toPercentX(this.myPinValue[zIndex]);
  }
  this.changePaddlePositon = function (aID, aDeltaPercent) {
    var zCurrent = this.getPaddlePosition(aID);
    this.setPaddlePosition(aID, zCurrent+aDeltaPercent);
  }
  this.setBoosterGripBooster = function (aPressed) {
    this.setPaddlePosition(this.PaddleID.PADDLE_BETA, (aPressed? 100: 0));
  }
  this.setBoosterGripTrigger = function (aPressed) {
    this.setPaddlePosition(this.PaddleID.PADDLE_ALPHA, (aPressed? 100: 0));
  }
  this.getPinIndex = function (aPin) {
    // TODO
    if (aPin < 10) {
      switch (aPin) {
        case 1 : return 0;
        case 2 : return 1;
        case 3 : return 2;
        case 4 : return 3;
        case 5 : return 5;
        default : return 0;
      }
    }
    if (aPin>10) {
      switch (aPin) {
        case 11 : return 4;
        case 12 : return 8;
        default : return 0;
      }
    }
  }
}


/*
 * JSVideo.java
 *
 * Created on July 16, 2007, 10:22 PM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */

/**
 * The class that takes care of drawing to the user's computer screen.
 * 
 * <p>
 *     It essentially works this way: <br>
 *     The myCurrentFrameBuffer array (and the myPreviousFrameBuffer one) represent
 *     the pixels of the TV display, with the top left being the first, and increasing
 *     to the right, eventually continuing on the next line down, on the left side of the 
 *     screen. The values of this array represent INDICES (of the palette array) of the 
 *     colors pertaining to that pixel.  It is the TIA's job to set the values of this
 *     array--it does so when JSConsole's doFrame() calls the TIA's processFrame() method.
 *     When the JSConsole calls the doVideo() method, this data should already be updated.
 *     So JSVideo first takes the values in the FrameBuffer array and uses them to 
 *     set the pixels on the back buffer image to the corresponding color.  It then has
 *     the back buffer painted onto the GUI's canvas.
 *     
 *     All of the GUI related scaling is done in the canvas class of the GUI.
 *     
 *     
 *     
 *     
 * </p>
 * @author Bradford W. Mott and the Stella team (original)
 * J.L. Allen (Java translation)
 */

    
    //==================================================
    /**
     * A rectangle that remembers what part of the screen has been changed.
     * Everytime the drawMediaSource() method encounters a changed pixel,
     * it informs an object of this class, which resizes to encompass the new
     * point.
     */
    function ClipRectangle(){
        this.isClear=true;
				this.x=0;
				this.y=0;
				this.width=0;
				this.height=0;
        
        /**
         * Resets the area of the rectangle.  Should be called every frame.
         */
        this.resetRect = function() {
            this.isClear=true;
            this.x=0;
            this.y=0;
            this.width=0;
            this.height=0;
        }
        
        
        
        /**
         * Tells the rectangle to expand to encompass the given point.
         * @param aX X
         * @param aY Y
         */
        this.addPoint = function(aX, aY) {
            if (this.isClear==true) //first point
            {
                this.x=aX - 1;
                this.y=aY - 1;
                this.width=3;
                this.height=3;
                this.isClear=false;
            }//end : first point
            else {
                if (aX >= (this.x+this.width)) //to the right of rect
                {
                    this.width=(aX - this.x)+ 2;
                } else if (aX <= this.x) //to the left of x
                {
                    this.width += (this.x - aX) + 2; //expand width
                    this.x=aX - 1;
                }
                
                if (aY >= (this.y+this.height)) //below rect
                {
                    this.height=(aY -this.y) + 2;
                } else if (aY <= this.y) //above y
                {
                    this.height += (this.y - aY) + 2; //expand height
                    this.y=aY - 1;
                }
                
            }//end : additional points
            
            
        }//::
        
        
    }//INNER CLASS END
    
function JSVideo(aConsole){
    this.serialVersionUID = 701607876730703063;
    
    
    this.DEFAULT_WIDTH=160;
    this.DEFAULT_HEIGHT=200; //not sure if this is still used
    
    this.DEFAULT_PHOSPHOR_BLEND=77; 
    
    this.myRandomGenerator=Math.random(); //TOdO if int?
    
    
    
    this.PALETTE_GRAY_STANDARD = [];
   	
		function getRGB(r,g,b){
			return (r<<16 | g<<8 | b);
		}

        for (var i=0; i<256; i++) {
            this.PALETTE_GRAY_STANDARD[i]=getRGB(i,i,i);
        }//end : for i loop
        
    this.myConsole=null;
    
    // TIA palettes for normal and phosphor modes
    this.myNormalPalette= [];
    this.myBlendedPalette= (function(){
			var r = [];
			for(var i=0;i<256;i++)
				r.push([]);

			return r; 
		})();
    this.myGrayPalette=[];
    
    this.myCurrentFrameBuffer=null;
    this.myPreviousFrameBuffer=null;
    
    
    this.myResidualColorBuffer=null;
    
    this.myGrayPaletteMode=false;
    
    
    this.myRedrawTIAIndicator=true;   // Indicates if the TIA area should be redrawn
    this.myUsePhosphor=false;  // Use phosphor effect (aka no flicker on 30Hz screens)
    this.myPhosphorBlendPercent=this.DEFAULT_PHOSPHOR_BLEND;   // Amount to blend when using phosphor effect
    
		this.myClipRect = new ClipRectangle();

    //private transient ClipRectangle myClipRect=new ClipRectangle();
		this.myBackBuffer = null;
    //private transient BufferedImage myBackBuffer=null;//(DEFAULT_WIDTH, DEFAULT_HEIGHT); //new BufferedImage(DEFAULT_WIDTH, DEFAULT_HEIGHT, BufferedImage.TYPE_INT_ARGB);
//    this.myBackBufferData=null; //new byte[0];
    
    
    this.myTestPattern=null;
    
    
     /**
     * This method is called for the creation of the back buffer.  It is called when 
     * a new JSVideo object is created, as well as when a JSVideo object is
     * deserialized--that is, loaded from a stream (when a saved game state is loaded).
     * @param aWidth desired width of the back buffer
     * @param aHeight desired height of the back buffer
     * @return the new back buffer
     */
    this.createBackBuffer = function(aWidth, aHeight)
    {
       // BufferedImage zReturn=new BufferedImage(aWidth, aHeight, BufferedImage.TYPE_INT_ARGB);
   //     BufferedImage zReturn=GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration().createCompatibleImage(aWidth, aHeight);
				
        //System.out.println("debug: image=" + zReturn);
				zReturn = array2d(aWidth, aHeight);
        return zReturn;
        
    }
    
    
    /**
     * Creates a new instance of JSVideo
     * @param aConsole the parent console
     */
    this.initBackBuffer = function(aWidth, aHeight)
    {
        this.myBackBuffer=this.createBackBuffer(aWidth, aHeight);
       /* switch(myBackBuffer.getType())
        {
            case BufferedImage.TYPE_INT_ARGB :
            case BufferedImage.TYPE_INT_ARGB_PRE :
            case BufferedImage.TYPE_INT_RGB :
          
       
           	 myBackBufferData=((myBackBuffer.getRaster().getDataBuffer()).getData();
            break;
     
            
            default :
        {
            System.out.println("Backbuffer is not integer RGB type");
            myBackBufferData=null;
            break;
        }//end : not correct type for optimized buffer handling
    }*/
    }//::
    
    /**
     * This method is a special method used by Java's serialization mechanism.  It is called
     * when a JSVideo object is deserialized (e.g. during the loading of a saved game), and
     * acts as an "alternate constructor", rebuilding any object that wasn't able to be
     * serialized/deserialized.
     * @param in the object input stream
     * @throws java.io.IOException input/output exception
     * @throws java.lang.ClassNotFoundException called if it can't find the class.
     */
/*    private void readObject(java.io.ObjectInputStream in)  throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        if (myClipRect==null) myClipRect=new ClipRectangle();
      //  if (myBackBuffer==null) myBackBuffer=createBackBuffer(getWidth(), getHeight()); //new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_ARGB);
        if (myCurrentFrameBuffer==null)  myCurrentFrameBuffer = new int[CLOCKS_PER_LINE_VISIBLE * FRAME_Y_MAX];
        if (myPreviousFrameBuffer==null) myPreviousFrameBuffer = new int[CLOCKS_PER_LINE_VISIBLE * FRAME_Y_MAX];
        initBackBuffer(getWidth(), getHeight());
        initPalettes();
        loadImages();
        initialize();
        refresh();
    }
    */
    
    /**
     * This is a special method that is called by Java's serialization mechanism.
     * See readObject(...)
     * @param out object output stream
     * @throws java.io.IOException thrown if an i/o exception occurs
     */
/*    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
    }
  */  

   	this.initPalettes = function()
    {
        myNormalPalette=new Array(256);
        myBlendedPalette=array2d(256, 256);
        myGrayPalette=new Array(256);
    }
    
    /**
     * Clears the buffers.
     */
    this.clearBuffers  = function() {
        for(var i = 0; i < this.myCurrentFrameBuffer.length; ++i) {
            this.myCurrentFrameBuffer[i] = 0;
            this.myPreviousFrameBuffer[i] = 0;
        }
        
    }
    
    /**
     * This is called once a frame to swap the previous and the current frame buffers.
     * The previous becomes the current, and the former current becomes the previous.
     */
    this.swapFrameBuffers = function() {
        var tmp = this.myCurrentFrameBuffer;
        this.myCurrentFrameBuffer = this.myPreviousFrameBuffer;
        this.myPreviousFrameBuffer = tmp;
    }
    
    /**
     * Returns the current frame buffer.
     * <p>
     *    The current frame buffer represents all the pixels on the display screen (with
     *    each integer representing the index of a color in the current palette).
     * </p>
     * @return the current frame buffer
     */
    this.getCurrentFrameBuffer = function() { return this.myCurrentFrameBuffer; }
    /**
     * Returns the previous frame buffer.
     * There are two frame buffers, a current and a previous, and they are switched every
     * frame.  This way, JSVideo can keep track of which pixels have changed, so that
     * it only has to redraw things that have changed.
     * @return previous frame buffer
     */
  	this.getPreviousFrameBuffer = function() { return this.myPreviousFrameBuffer; }
    
    /**
     * Calls the console's getWidth() method.
     * @return width of the display (as far as TIA is concerned)
     */
    this.getWidth = function() { return this.myConsole.getDisplayWidth();}
    /**
     * Calls the console's getHeight() method.
     * @return height of the display (as far as TIA is concerned)
     */
    this.getHeight = function() { return this.myConsole.getDisplayHeight(); }
    
    
    /**
     * This method signals to the JSVideo that the whole display screen needs to be 
     * updated.  Normally, for performance reasons, the JSVideo object will only update
     * those regions of the display that, by its calculations, have changed.  This method 
     * tells JSVideo to ignore its calculations during the next frame, and redraw the whole
     * thing.
     * It does not cause the frame to be redrawn...it merely causes the ENTIRE frame to be
     * redrawn the next time a redraw occurs.
     */
    this.refresh = function() {
        this.myRedrawTIAIndicator = true;
    }
    
    /**
     * Repaints the current frame.
     * This is similar to refresh(), but it also redraws the current frame, whereas refresh waits 
     * until it's time to redraw the frame again.
     */
    this.updateVideoFrame = function() {
        this.refresh();
        switch (this.myConsole.getTelevisionMode())
        {
            case TELEVISION_MODE_GAME : this.doFrameVideo(); break;
            case TELEVISION_MODE_SNOW : this.doSnow(); break;
            case TELEVISION_MODE_TEST_PATTERN : this.doTestPattern(); break;
        }//end : switch
        
    }
    
     
    
    
    /**
     * Is used to paint the current frame in shades of gray...is used when paused.
     * This method first changes the palette to grayscale, then repaints the 
     * current frame with that palette, and then changes the palette back to what
     * it was previously.  Thus, this is only good for one frame, so this is best
     * used when the game is paused.
     */
   this.grayCurrentFrame = function() {
        var zOldMode=myGrayPaletteMode;
        myGrayPaletteMode=true;
        this.updateVideoFrame();
        myGrayPaletteMode=zOldMode;
        
    }
   
    /**
     * Returns the back buffer object
     * @return the back buffer
     */
    this.getBackBuffer = function() {
        return this.myBackBuffer;
    }
    
    /**
     * Erases any images on the back buffer
     */
   	this.clearBackBuffer = function() {
     /*   Graphics2D z2D=myBackBuffer.createGraphics();
        z2D.setColor(Color.BLACK);
        z2D.fillRect(0,0, myBackBuffer.getWidth(), myBackBuffer.getHeight());
        z2D.dispose(); */
    }
    
    /**
     * Ensures the back buffer is big enough to contain the current display.
     * The back buffer is a buffered image object that the JSVideo draws to, and which is
     * subsequently drawn to the screen by the canvas object.  The back buffer should be the
     * size of the display, so when the display changes size, this method should be called.
     * @param aNewWidth new display width
     * @param aNewHeight new display height
     */
    this.adjustBackBuffer = function(aNewWidth, aNewHeight) {
				return;
//        if ((aNewWidth>myBackBuffer.getWidth())||(aNewHeight > myBackBuffer.getHeight())) {
         //   myBackBuffer=createBackBuffer(
  //           initBackBuffer(Math.max(myBackBuffer.getWidth(), aNewWidth), Math.max(myBackBuffer.getHeight(), aNewHeight));//new BufferedImage(Math.max(myBackBuffer.getWidth(), aNewWidth), Math.max(myBackBuffer.getHeight(), aNewHeight), BufferedImage.TYPE_INT_ARGB);
    //    }//end : needs to be larger
    }
    
    
    
    
    
    
    /**
     * Prepares the JSVideo for use.
     */
  	this.initialize = function() {
        this.setTIAPalette(PALETTE_NTSC);
    }
    
    /**
     * This method loads any images needed by the JSVideo object (e.g. the television 
     * test pattern image).  It is called when JSVideo object is created.
     */
    this.loadImages = function() {
        
//        URL zTestPatternURL=this.getClass().getResource(RESOURCE_IMAGE_TEST_PATTERN);
//        if (zTestPatternURL!=null) myTestPattern=new ImageIcon(zTestPatternURL);
    }
    
    /**
     * Draws static ("snow") on the back buffer, and paints the back buffer to the canvas.
     */
    this.doSnow = function() {
//        if (myBackBuffer!=null) {
//            snowBackBuffer();
//            if (getCanvas()!=null) getCanvas().paintCanvas(myBackBuffer, myBackBuffer.getWidth(), myBackBuffer.getHeight());
//        }//end : not null
    }
    
    /**
     * This sets out random grayscale pixels on the backbuffer to simulate television static
     */
    this.snowBackBuffer = function() {
/*        if (myBackBuffer!=null) {
            int zWidth=myBackBuffer.getWidth();
            int zHeight=myBackBuffer.getHeight();
            for (int iY=0; iY<zHeight; iY++) {
                for (int iX=0; iX<zWidth; iX++) {
                    int zRandomValue=Math.min((int)(myRandomGenerator.nextDouble() * 256.0),255);
                    
                    myBackBuffer.setRGB(iX, iY, PALETTE_GRAY_STANDARD[zRandomValue]);
                }//end : for iX
                
                
            }//end : for iY
        }//end : back buffer not null
				*/
    }
    
    /**
     * This method is a convenience method which fetches the Canvas object from the 
     * Console's client (i.e. the GUI).
     * @return the current canvas
     */
    this.getCanvas = function() {
        if (this.myConsole.getConsoleClient()!=null) return  this.myConsole.getConsoleClient().getCanvas();
        else return null;
    }
    
    
    
   
	 	function setRGB(a, x, y, color){
			a[x][y] = color;
		}

    /**
     * This method takes data from the TIA object and uses it to draw the back buffer.
     */
    this.prepareBackBuffer = function() {
      
            var zCurrentBuffer=this.getCurrentFrameBuffer();
            var zPrevBuffer=this.getPreviousFrameBuffer();
            if (this.myResidualColorBuffer==null) this.myResidualColorBuffer=new Array(zCurrentBuffer.length); //maybe a better way to set it
            var zWidth  = Math.min(this.getWidth()/*, myBackBuffer.getWidth()*/);
            var zHeight = Math.min(this.getHeight()/*, myBackBuffer.getHeight()*/);
            
            var zBufferIndexAtLineStart = 0;
          	
            for(var y = 0; y < zHeight; y++) {         //for each line
                
                for(var x = 0; x < zWidth; x++) {    //for each pixel on a given line
                    var zBufferIndex = zBufferIndexAtLineStart + x;  //determing the buffer index at this given x and y
                    
                    var zNewColorIndex = zCurrentBuffer[zBufferIndex];
                    var zOldColorIndex = zPrevBuffer[zBufferIndex];
                    
                    //TODO : make the following code more "elegant", and self-explanatory
                    var zOldPaintedColor= this.myResidualColorBuffer[zBufferIndex];
                    var zNewPaintedColor= this.myUsePhosphor ? this.getBlendedColorInt(zOldColorIndex, zNewColorIndex) : this.getColorInt(zNewColorIndex);
                  
                    if((zNewPaintedColor != zOldPaintedColor) || (this.myRedrawTIAIndicator) ) {   // either the color has changed, or we have been ordered to draw it regardless
                        this.myClipRect.addPoint(x,y);                   // expands the clip rectangle, telling it there is another part of the screen in need of update
                        
                        this.myResidualColorBuffer[zBufferIndex]=zNewPaintedColor;
                        
                        
                        
                  /*      if (this.myBackBufferData!=null) this.myBackBufferData[zBufferIndex]=zNewPaintedColor; //a quicker way if available */
                       /* else */ setRGB(this.myBackBuffer, x, y, zNewPaintedColor);     // the actual act of drawing
                        
                    }//end : pixel has changed
                }//end : for x to width loop
                
                zBufferIndexAtLineStart += zWidth;  //moving to next line
            }//end : for y to height loop
            this.myRedrawTIAIndicator=false;
       
    }//::
    
    
    
    
    
    
    
    /**
     * This method paints the back buffer to the previously specified canvas
     */
    this.paintBackBufferToCanvas = function() {
        
        if (this.getCanvas()!=null) {
            //Tells the canvas to call the paint command...the coordinates are very important...drawing the screen is incredibly slow, so you must only
            //draw a portion of it at a time.  The portion that has changed is contained in myClipRect
            //The calculations are there to scale, converting double into ints by rounding the correct direction
            
            this.getCanvas().paintCanvas(this.myBackBuffer, this.getWidth(), this.getHeight(), this.myClipRect);
            this.myClipRect.resetRect();
        }//end : canvas not null
       	else console.log("no canvas!"); 
    }
     /**
     * This method is one of the most important of the program.  It draws the pixels
     * on the back buffer and then tells the component that display the back buffer to
     * repaint itself immediately.
     */
    this.doFrameVideo = function() {
       
       // long zTimeA=System.nanoTime();
        this.prepareBackBuffer();
      //  long zTimeB=System.nanoTime();
     
        this.paintBackBufferToCanvas();
     //    long zTimeC=System.nanoTime();
   /*        if (JSConsole.DEBUG_MODE_ON==true)
        {
            //int zDeltaBA=(int)(zTimeB - zTimeA) / 1000;
           // System.out.println("debug JSVideo : prepareBackBuffer=" + zDeltaBA + " microseconds");
             int zDeltaCB=(int)(zTimeC - zTimeB) / 1000;
            System.out.println("debug JSVideo : paintBackBufferToCanvas=" + zDeltaCB + " microseconds");
        }//end : debug mode on
    */
       
        
    }
    
    /**
     * The "test pattern" is the image of colored bars that may be display when 
     * no ROM is loaded.  This method draws it to the canvas.
     */
    this.doTestPattern = function()
    {
			return;
/*         Graphics2D z2D=myBackBuffer.createGraphics();
            double zScaleX=(double)myBackBuffer.getWidth() / myTestPattern.getIconWidth();
            double zScaleY=(double)myBackBuffer.getHeight() / myTestPattern.getIconHeight();
            double zScale=Math.min(zScaleX, zScaleY);
            int zWidth  =(int)(myTestPattern.getIconWidth() * zScale);//Math.min(getWidth(), myBackBuffer.getWidth());
            int zHeight = (int)(myTestPattern.getIconHeight() * zScale); //Math.min(getHeight(), myBackBuffer.getHeight());
            z2D.drawImage(myTestPattern.getImage(), 0,0, zWidth, zHeight, 0,0, myTestPattern.getIconWidth(), myTestPattern.getIconHeight(), null);
            
            z2D.dispose();
            
            if (getCanvas()!=null) {
            //Tells the canvas to call the paint command...the coordinates are very important...drawing the screen is incredibly slow, so you must only
            //draw a portion of it at a time.  The portion that has changed is contained in myClipRect
            //The calculations are there to scale, converting double into ints by rounding the correct direction
            myClipRect.resetRect();
            getCanvas().paintCanvas(myBackBuffer, zWidth, zHeight, myClipRect);
            
            
          
        }//end : canvas not null
  */          
    }
    
    // ======================= COLOR STUFF ==================================
    
    
    
    
    
    /**
     * Returns true if phosphor mode is enabled
     * @return true if phosphor mode is enabled
     */
    this.getPhosphorEnabled = function() {
        return this.myUsePhosphor;
    }
    
    
    
    /**
     * Phosphor mode helps emulate the television a little better, and can be used as
     * an "anti-flicker" mode.  When the "pixels" on a traditional TV screen are illuminated,
     * they don't immediately fade when the next frame (and thus pixel) is set...instead,
     * there is somewhat of a blend of the old and the new.  Think "phosphorescence".
     * <p>
     *    Phosphor mode emulates this blend, and is useful for combatting flicker.
     *    Imagine a white background, and for every other frame, a black square is shown
     *    on that background.  Now imagine that there are 60 frames per second.
     *    Without phosphor mode, you are likely to see a flickering of a black square.
     *    With phosphor mode, you will likely see a steady gray square--it is a blend
     *    of white and black.
     *    
     * </p>
     * @param aEnable true to turn on phosphor mode
     */
   	this.setPhosphorEnabled = function(Enable) {
        this.myUsePhosphor=aEnable;
    }
    
   
    /**
     * Turns phosphor mode on/off, but also specifies a blend percentage value...(e.g. 77)
     * See the other setPhosphorEnabled(...) documentation.
     * @param aEnable true to enable
     * @param aBlendPercent percentage that the two colors should be blended
     */
    this.setPhosphorEnabled = function(aEnable, aBlendPercent) {
       this.setPhosphorEnabled(aEnable);
       this.myPhosphorBlendPercent=aBlendPercent;
        
    }
    
    
    /**
     * Returns the java color associated with the given array index
     * @param aIndex The color's index
     * @return the associated java color
     */
    //private Color getColor(int aIndex) {
    //     return new Color(myNormalPalette[aIndex]);
    // }
    
    /**
     * Retrieves the color integer from a certain array.
     * The integer stores color information in the ARGB format (I think)
     * @param aIndex The array index of the desired color
     * @return An integer representing the desired color
     */
    this.getColorInt = function(aIndex) {
        if (this.myGrayPaletteMode==true) return this.myGrayPalette[aIndex & 0xFF];
        else return this.myNormalPalette[aIndex & 0xFF];
    }
    
    /**
     * This is used in phosphor (aka anti-flicker) mode to get a blend
     * of the colors represented by the two indices
     * @param aOldIndex the old color index
     * @param aNewIndex the new color index
     * @return the color that represents the blend between the two indices
     */
    this.getBlendedColorInt = function(aOldIndex, aNewIndex) {
        return myBlendedPalette[aOldIndex & 0xFF][aNewIndex & 0xFF];
    }
    
    
    
    
    
    
    
    
    
    
    
    /**
     * Returns an integer version of a color based on its components.
     * @param r red component
     * @param g green component
     * @param b blue component
     * @return an integer version of the specified color
     */
    this.calculateNormalColor = function(r,  g, b) {
        assert((r>=0)&&(g>=0)&&(b>=0));
        return getRGB(r,g,b);
    }
    
    
    /**
     * Calculates a given phosphor blend based on the colors provided.  This is used 
     * when the palette is being set.
     * @param aColorComponentA the first component e.g. the red component (0-255) of the previous pixel
     * @param aColorComponentB the second component e.g. the red component (0-255) of the new pixel
     * @param aPhosphorBlend percentage to blend (e.g. 77)
     * @return new component value
     */
  	this.calculatePhosphorColor = function(aColorComponentA, aColorComponentB, aPhosphorBlend) {
        
        var zDifference=Math.abs(aColorComponentA - aColorComponentB);
        var zBlendFactor=aPhosphorBlend/100.0;
        
        var zPhosp=Math.min(aColorComponentA, aColorComponentB) + Math.floor(zBlendFactor * zDifference);
        assert((zPhosp>=0)&&(zPhosp<0x100)); //i.e. between 0 and 256 (a byte value)
        return zPhosp;
    }
    
    /**
     * Calculates a gray color based on the given components
     * @param aRed red component (0-255)
     * @param aGreen green component (0-255)
     * @param aBlue blue component (0-255)
     * @return the new gray color in integer RGB format
     */
    this.calculateGrayColor = function( aRed, aGreen, aBlue) {
        var zAverage=(aRed + aGreen + aBlue) / 3;
        return this.calculateNormalColor(zAverage, zAverage, zAverage);
    }
    
    
    
    
    
 
     
    
    /**
     * Sets the palette to be used.
     * The palettes are integer arrays of 256 values, in xRGB format, where x isn't used.
     * Thus, the lowest 8 bits of each value represent the blue value (0-255), the next 8 represent the green
     * value, and the next 8 represent the red value.
     * @param palette the palette to use
     */
   	this.setTIAPalette = function( palette) {
        
        var i, j;
        
        // Set palette for normal fill
        for(i = 0; i < 256; ++i) {
            var r = (palette[i] >> 16) & 0xff;
            var g = (palette[i] >> 8) & 0xff;
            var b = palette[i] & 0xff;
            
            
            this.myNormalPalette[i] = this.calculateNormalColor(r, g, b);
            this.myGrayPalette[i] = this.calculateGrayColor(r, g, b);
        }
        
        // Set palette for phosphor effect
        for(i = 0; i < 256; ++i) {
            for(j = 0; j < 256; ++j) {
                var ri = (palette[i] >> 16) & 0xff;
                var gi = (palette[i] >> 8) & 0xff;
                var bi = palette[i] & 0xff;
                var rj = (palette[j] >> 16) & 0xff;
                var gj = (palette[j] >> 8) & 0xff;
                var bj = palette[j] & 0xff;
                
                var r = this.calculatePhosphorColor(ri, rj, this.myPhosphorBlendPercent);
                var g =  this.calculatePhosphorColor(gi, gj, this.myPhosphorBlendPercent);
         	      var b = this.calculatePhosphorColor(bi, bj, this.myPhosphorBlendPercent);
                
                this.myBlendedPalette[i][j] = this.calculateNormalColor(r, g, b);
            }
        }
        
        
        
        this.myRedrawTIAIndicator = true;
    }
    
    
   /*    protected  void setColorLossPalette(boolean loss) {
           //TODO : document what this color loss thing is (I don't have a clue - JLA)
        // Look at all the palettes, since we don't know which one is
        // currently active
        int[][] palette= {
            ourNTSCPalette,    ourPALPalette,
            ourNTSCPalette11,  ourPALPalette11,
            ourNTSCPaletteZ26, ourPALPaletteZ26,
            null, null //ourUserNTSCPalette, ourUserPALPalette
        };
       // if(myUserPaletteDefined) {
         //   palette[6] = ourUserNTSCPalette;
         //   palette[7] = ourUserPALPalette;
      // }
    
        for(int i = 0; i < 8; ++i) {
            if(palette[i] == null)
                continue;
    
            // If color-loss is enabled, fill the odd numbered palette entries
            // with gray values (calculated using the standard RGB . grayscale
            // conversion formula)
            for(int j = 0; j < 128; ++j) {
                int[] zPixelArray=palette[i];
                int pixel = zPixelArray[(j<<1)];
                if(loss) {
                    int r = (int)(pixel >> 16) & 0xff;
                    int g = (int)(pixel >> 8)  & 0xff;
                    int b = (int)(pixel >> 0)  & 0xff;
                    int sum = (int) (((float)r * 0.2989) +
                            ((float)g * 0.5870) +
                            ((float)b * 0.1140));
                    pixel = (sum << 16) + (sum << 8) + sum;
                }
                palette[i][(j<<1)+1] = pixel;
            }//end : for int j
        }//for int i (palette)
    }
    */
   
    
  
    
    
    
    
    
    
    
    
//=============================================================================
//========================== INNER CLASSES ====================================
//=============================================================================
    
    
    //
    
    
    
    
    
    
    
    
//*****************************************************************************
//************************** DEBUG SECTION ************************************
//*****************************************************************************
    
    
 /*
      public void debugDrawMediaSource() {
        doFrameVideo();
    }
  
    public void debugPaintImmediately() {
        IfcCanvas zCanvas=getCanvas();
       // if (zCanvas!=null) zCanvas.paintCanvas(0,0,zCanvas.getCanvasWidth(), zCanvas.getCanvasHeight());
    }
  */
    

        this.myConsole=aConsole; //Construct
        this.myRedrawTIAIndicator=true;
        this.myUsePhosphor=false;
        this.myPhosphorBlendPercent=this.DEFAULT_PHOSPHOR_BLEND;
       
        // Allocate buffers for two frame buffers
        this.myCurrentFrameBuffer = new Array(CLOCKS_PER_LINE_VISIBLE * FRAME_Y_MAX); //new int[CLOCKS_PER_LINE_VISIBLE * FRAME_Y_MAX];
        this.myPreviousFrameBuffer = new Array(CLOCKS_PER_LINE_VISIBLE * FRAME_Y_MAX); //new int[CLOCKS_PER_LINE_VISIBLE * FRAME_Y_MAX];
        this.initBackBuffer(this.DEFAULT_WIDTH, this.DEFAULT_HEIGHT);

        this.initPalettes();
        this.loadImages();

        this.initialize();
    
}//CLASS END

function JSTIA(aConsole) {
    this.serialVersionUID = -1703217043035095708;
    //TODO : Maybe get rid of the old offset (0-3) system, as currently used in these masks
    //TODO : Get rid of disabled missile mask table...
    
    
    
    this.COSMICBUG_MOVEMENT = [18, 33, 0, 17];
    
    
    this.M0Disabled=false;
    this.M1Disabled=false;
    
    this.myCurrentM0Mask=[0,0,0,0];
    this.myCurrentM1Mask=[0,0,0,0];
    this.myCurrentP0Mask=[0,0,0,0];
    this.myCurrentP1Mask=[0,0,0,0];
    this.myCurrentBLMask=[0,0,0];
    
  
    
    
    this.myTIAPokeRegister=[]; // TIA_POKE_REGISTER_COUNT;
    for (var i=0;i<TIA_POKE_REGISTER_COUNT;i++) {
      this.myTIAPokeRegister[i] = 0;
    }
    
    
    
    this.myConsole=null;
    this.mySystem=null;
    
    
    this.myColorLossEnabled;  //No clue what this means, except it has something to do with PAL (-JLA)
    this.myPartialFrameFlag;
   // private int myFrameCounter=0;   // Number of frames displayed by this TIA
    this.myFramePointer=0;  // Index to the next pixel that will be drawn in the current frame buffer
    this.myFrameXStart=0;  // Indicates where the scanline should start being displayed
   
    
    

    this.myClockWhenFrameStarted=0;
    this.myClockStartDisplay=0; // Indicates color clocks when frame should begin to be drawn
    this.myClockStopDisplay=0;
    this.myClockAtLastUpdate=0;
    this.myClocksToEndOfScanLine=0;
    this.myScanlineCountForLastFrame=0;
    this.myCurrentScanline=0;  // Indicates the current scanline during a partial frame.
    this.myMaximumNumberOfScanlines=0;
    this.myVSYNCFinishClock=0;  // Color clock when VSYNC ending causes a new frame to be started
    
    this.myEnabledObjects=0;
    
    
    this.myPlayfieldPriorityAndScore=0;
    
    this.myVBlankOff=0;
    //private int myPreviousVBlankOff=0;
    this.myVBlankOn=0;
    this.myVSyncOn=0;
    this.myDetectedYStart=0;
    this.myDetectedYStop=0;
    
    
    
    
    // ---------- TIA register variables -----------
  
    
    
    
   
    
   
    
    this.myDGRP0=0;        // Player 0 delayed graphics register
    this.myDGRP1=0;        // Player 1 delayed graphics register
    

    this.myDENABL;        // Indicates if the vertically delayed ball is enabled
    
 

    
    
    this.myCollision=0;    // Collision register
    
    
    this.myPOSP0=0;         // Player 0 position register
    this.myPOSP1=0;         // Player 1 position register
    this.myPOSM0=0;         // Missile 0 position register
    this.myPOSM1=0;         // Missile 1 position register
    this.myPOSBL=0;         // Ball position register
    
    this.myCurrentGRP0=0;
    
    this.myCurrentGRP1=0;
    
    
    
    
    
    // Audio values. Only used by TIADebug.
 /*   private int myAUDV0;
    private int myAUDV1;
    private int myAUDC0;
    private int myAUDC1;
    private int myAUDF0;
    private int myAUDF1;
  */
    
    
    //------ Other variables --------
    
    this.myDumpDisabledCycle=0;  // Indicates when the dump for paddles was last set
    this.myDumpEnabled=false; // Indicates if the dump is current enabled for the paddles
    
    this.myLastHMOVEClock=0;  // Color clock when last HMOVE occured
    this.myHMOVEBlankEnabled=false; // Indicates if HMOVE blanks are currently enabled 
    this.myAllowHMOVEBlanks=false; // Indicates if we're allowing HMOVE blanks to be enabled (?-JLA)
    this.myM0CosmicArkMotionEnabled=true; // TIA M0 "bug" used for stars in Cosmic Ark flag
    this.myM0CosmicArkCounter=0;
   // private boolean[] myBitEnabled=new boolean[6];
    
    
    
    
    this.debugInstructionsExecuted=0;
    this.debugHasExecutionOverrun=false;
    
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.myConsole=aConsole;
        
    this.myColorLossEnabled=false;
    this.myMaximumNumberOfScanlines=LINES_PER_FRAME_TOTAL; //262 scanlines        
    
   
    
   
    
    
    this.writeObject = function(out) 
    {
      out.defaultWriteObject();
    } 
    
    this.readObject = function(inn) {
        inn.defaultReadObject();
    }

    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    //========================== SIMPLE ACCESSOR METHODS ===================================
    // Note : some of these may seem superfluous, especially for internal use, but they
    // can come in handy when debugging.  (One can put an assert() in the accessor methods to see
    // exactly what bad data comes in and what goes out, and when these things occur.)
    
    
    
    this.getCOLUBK = function(){  return this.myTIAPokeRegister[COLUBK];  }
    this.setCOLUBK = function(aValue)    {   this.myTIAPokeRegister[COLUBK]=aValue;     }
    this.getCOLUPF = function()    {  return this.myTIAPokeRegister[COLUPF];   }
    this.setCOLUPF = function(aValue)   {   this.myTIAPokeRegister[COLUPF]=aValue;    }
    this.getCOLUP0 = function()   {   return this.myTIAPokeRegister[COLUP0];   }
    this.setCOLUP0 = function(aValue)    {   this.myTIAPokeRegister[COLUP0]=aValue;    }
    this.getCOLUP1 = function()   {   return this.myTIAPokeRegister[COLUP1];    }
    this.setCOLUP1 = function(aValue)    {    this.myTIAPokeRegister[COLUP1]=aValue;     }
 
    this.getCurrentFrameBuffer = function() { return this.myConsole.getVideo().getCurrentFrameBuffer(); }
    
  
    
   // public int getVBlankOn() { return myVBlankOn; }
   // public int getVBlankOff() { return myVBlankOff; }
    this.getVSyncOn = function() { return this.myVSyncOn; }
    this.getDetectedYStart = function() { return this.myDetectedYStart; }
    this.getDetectedYStop = function() { return this.myDetectedYStop; }
            
    
    /**
     * Answers the total number of scanlines the media source generated
     * in producing the current frame buffer. For partial frames, this
     * will be the current scanline.
     * @return total number of scanlines generated
     */
    this.scanlines = function() { return Math.floor(((this.mySystem.getCycles() * CLOCKS_PER_CPU_CYCLE) - this.myClockWhenFrameStarted)/CLOCKS_PER_LINE_TOTAL);}
    this.getConsole = function() { return this.myConsole; }
    
    
    //The get and set accessors for the current masks were originally done to ease the change from C++ to Java...
    //i.e. it involved less typing for me. -JLA
    this.getCurrentP0Mask = function(aIndex) {
        return PLAYER_MASK_TABLE[this.myCurrentP0Mask[0]][this.myCurrentP0Mask[1]][this.myCurrentP0Mask[2]][this.myCurrentP0Mask[3]+aIndex];
        
    }
    
    this.getCurrentP1Mask = function(aIndex) {
        return PLAYER_MASK_TABLE[this.myCurrentP1Mask[0]][this.myCurrentP1Mask[1]][this.myCurrentP1Mask[2]][this.myCurrentP1Mask[3]+aIndex];
        
    }
    
    
    this.getCurrentM0Mask = function(aIndex) {
        if (this.M0Disabled==true) return this.bool(DISABLED_MASK_TABLE[aIndex]);
        else {
            assert(this.myCurrentM0Mask[3] + aIndex < 360);
            return MISSILE_MASK_TABLE[this.myCurrentM0Mask[0]][this.myCurrentM0Mask[1]][this.myCurrentM0Mask[2]][this.myCurrentM0Mask[3]+aIndex];
            //return getOMMT(myCurrentM0MaskIndex + aIndex);
        }//end : not disabled
    }
    
    this.getCurrentM1Mask = function(aIndex) {
        if (this.M1Disabled==true) return this.bool(DISABLED_MASK_TABLE[aIndex]);
        else {
            assert(this.myCurrentM1Mask[3] + aIndex < 360);
            return MISSILE_MASK_TABLE[this.myCurrentM1Mask[0]][this.myCurrentM1Mask[1]][this.myCurrentM1Mask[2]][this.myCurrentM1Mask[3]+aIndex];
            
        }//end : not disabled
    }
    
    this.setCurrentM1Mask = function(aA, aB, aC, aD) {
        this.myCurrentM1Mask[0]=aA;
        this.myCurrentM1Mask[1]=aB;
        this.myCurrentM1Mask[2]=aC;
        this.myCurrentM1Mask[3]=aD;
        this.M1Disabled=false;
    }
    
    this.setCurrentP0Mask = function(aA, aB, aC, aD) {
        if (this.debugLockP0Mask==false) {
            this.myCurrentP0Mask[0]=aA;
            this.myCurrentP0Mask[1]=aB;
            this.myCurrentP0Mask[2]=aC;
            this.myCurrentP0Mask[3]=aD;
        }//end : is false
    }
    
    this.setCurrentP1Mask = function(aA, aB, aC, aD) {
        if (this.debugLockP1Mask==false) {
            this.myCurrentP1Mask[0]=aA;
            this.myCurrentP1Mask[1]=aB;
            this.myCurrentP1Mask[2]=aC;
            this.myCurrentP1Mask[3]=aD;
        }//end : is false
    }
    
    
    
    
    this.setCurrentM0Mask = function(aA, aB, aC, aD) {
        this.myCurrentM0Mask[0]=aA;
        this.myCurrentM0Mask[1]=aB;
        this.myCurrentM0Mask[2]=aC;
        this.myCurrentM0Mask[3]=aD;
        
        //myCurrentM0MaskIndex=getMasterIndexOMMT(aA, aB, aC, aD);
        this.M0Disabled=false;
    }
    
    
    this.setCurrentM0MaskDisabled = function() {
        this.M0Disabled=true;
    }
    
    
    
    
    this.getCurrentBLMask = function(aIndex) {
        return BALL_MASK_TABLE[this.myCurrentBLMask[0]][this.myCurrentBLMask[1]][this.myCurrentBLMask[2]+aIndex];
        
    }
    
    this.setCurrentBLMask = function(aA, aB, aC) {
        this.myCurrentBLMask[0]=aA;
        this.myCurrentBLMask[1]=aB;
        this.myCurrentBLMask[2]=aC;
        
    }
    
    
    this.getYStart = function()    {    return this.myConsole.getYStart();   }
    this.getDisplayHeight = function() { return this.myConsole.getDisplayHeight(); }
 
    
    this.isBitOn = function(aBitNumber, aValue) {
        return ((aValue & (1<<aBitNumber))!=0);
    }
    
    
    
   this.getAudio = function() { console.log("NO AUDIO!! in JSTIA"); 
	 return null; } 
    
    
    
    
    
    
    this.getCurrentClockCount = function() { return this.mySystem.getCycles() * CLOCKS_PER_CPU_CYCLE;    }
    this.getCurrentXPos = function() { return ((this.getCurrentClockCount() - this.myClockWhenFrameStarted) % CLOCKS_PER_LINE_TOTAL); }
    this.getCurrentScanline = function() { return ((this.getCurrentClockCount() - this.myClockWhenFrameStarted) / CLOCKS_PER_LINE_TOTAL); }
    
    
    
    
    
    
    
    this.getColor = function(aIndex) {
        switch (aIndex) {
            case 0 : return this.getCOLUBK();//=myColor[0];
            case 1 : return this.myTIAPokeRegister[COLUPF]; //=myColor[1];
            case 2 : return this.myTIAPokeRegister[COLUP0]; //=myColor[2];
            case 3 : return this.myTIAPokeRegister[COLUP1]; //=myColor[3];
            default : assert(false); return 0;
            
        }//end : switch
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.name = function() {
        return "TIA";
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.reset = function() {
				console.log("JS TIA RESET!");
        // Reset the sound device
        // dbg.out("RESETTING TIA");
        //this.getAudio().reset(); //The TIA is in charge of the audio, at least as far as system is concerned
        
        for (var i=0; i<this.myTIAPokeRegister.length; i++) {
            this.myTIAPokeRegister[i]=0;
        }//end : for i loop
        
        // Currently no objects are enabled
        this.myEnabledObjects = 0;
        
        // Some default values for the registers
//   
        this.myPlayfieldPriorityAndScore = 0;
    
      //  myPF = 0;
       // myGRP0 = 0;
       // myGRP1 = 0;
        this.myDGRP0 = 0;
        this.myDGRP1 = 0;
    
        this.myDENABL = false;
    
        //myRESMP0 = false;
        //this.myRESMP1 = false;
        this.myCollision = 0;
        this.myPOSP0 = 0;
        this.myPOSP1 = 0;
        this.myPOSM0 = 0;
        this.myPOSM1 = 0;
        this.myPOSBL = 0;
        
        // Some default values for the "current" variables
        this.myCurrentGRP0 = 0;
        this.myCurrentGRP1 = 0;
        this.setCurrentBLMask(0,0,0);// = ourBallMaskTable[0][0];
        
        this.setCurrentM0Mask(0,0,0,0);
        this.setCurrentM1Mask(0,0,0,0);
        this.setCurrentP0Mask(0,0,0,0); //ourPlayerMaskTable[0][0][0];
        this.setCurrentP1Mask(0,0,0,0);
        //myCurrentP1Mask = ourPlayerMaskTable[0][0][0];
        //myCurrentPFMask = PLAYFIELD_TABLE[0];
        
        this.myLastHMOVEClock = 0;
        this.myHMOVEBlankEnabled = false;
        this.myM0CosmicArkMotionEnabled = false;
        this.myM0CosmicArkCounter = 0;
        
     
        
        this.myDumpEnabled = false;
        this.myDumpDisabledCycle = 0;
        
        this.myAllowHMOVEBlanks = true;
        
        if((this.myConsole.getDisplayFormat()==DisplayFormat.PAL)||(this.myConsole.getDisplayFormat()==DisplayFormat.PAL60)) {
            this.myColorLossEnabled = true;
            this.myMaximumNumberOfScanlines = 342;
        } else  // NTSC
        {
            this.myColorLossEnabled = false;
            this.myMaximumNumberOfScanlines = 290;
        }
        
        this.myVBlankOff=0;
        this.myVBlankOn=0;
        this.myVSyncOn=-1;
        this.myDetectedYStart=0;
        this.myDetectedYStop=0;
        
        
        this.debugHasExecutionOverrun=false;
        
        // Recalculate the size of the display
        this.frameReset();
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * Resets certain variables about the frame.
     * This is called by the TIA's reset method.  It is also called whenever the JSConsole
     * changes a relevant attribute about the frame (e.g. the DisplayHeight).
     */
    this.frameReset = function() {
        
        this.myConsole.getVideo().clearBuffers();   // Clear frame buffers
       
        this.myFramePointer = 0;    // Reset pixel pointer and drawing flag
        
        // Calculate color clock offsets for starting and stoping frame drawing
        //myStartDisplayOffset = CLOCKS_PER_LINE_TOTAL * getYStart();
       // myStopDisplayOffset = myStartDisplayOffset + (CLOCKS_PER_LINE_TOTAL * getDisplayHeight());
        
        // Reasonable values to start and stop the current frame drawing
        this.myClockWhenFrameStarted = this.mySystem.getCycles() * CLOCKS_PER_CPU_CYCLE; //now
        this.myClockStartDisplay = this.myClockWhenFrameStarted + (CLOCKS_PER_LINE_TOTAL * this.getYStart()); //what the clock will be when the visible part of the frame starts
        this.myClockStopDisplay = this.myClockWhenFrameStarted +  (CLOCKS_PER_LINE_TOTAL * (this.getYStart() + this.getDisplayHeight())); //when the visible part of the frame stops
        this.myClockAtLastUpdate = this.myClockWhenFrameStarted;  
        this.myClocksToEndOfScanLine = CLOCKS_PER_LINE_TOTAL;  //currently at beginning of a line
        this.myVSYNCFinishClock = 0x7FFFFFFF;
        this.myScanlineCountForLastFrame = 0;
        this.myCurrentScanline = 0; //currently on the first line
        
        this.myFrameXStart = 0;    // Hardcoded in preparation for new TIA class
        //this.myFrameWidth  = CLOCKS_PER_LINE_VISIBLE;  // Hardcoded in preparation for new TIA class
        
        
       
        
       
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * This is called by the JSSystem whenever it resets its cycle counter, which it 
     * is supposed to do every frame.  This method makes sure that all of the variables
     * in the TIA class (and those that it controls) compensate for this, mostly by
     * subtracting from all the relevant variables the same value that was subtracted
     * from the JSSystem's counter.
     */
    this.systemCyclesReset = function() {
        // Get the current system cycle
        var cycles = this.mySystem.getCycles();
        
        //If we reset the cycle number from x to zero (i.e. subtract x from cycle #), we should subtract the same number from the previousCycles variable in Audio.
        //This way, (currentCycles - previousCycles) will remain as it would have without the reset
        if (this.getAudio()!=null) this.getAudio().systemCyclesReset(cycles);   // Adjust the sound cycle counter
        
        
        this.myDumpDisabledCycle -= cycles;   // Adjust the dump cycle
        
        
        var clocks = cycles * CLOCKS_PER_CPU_CYCLE;    // Get the current color clock the system is using
        
        // Adjust the clocks by this amount since we're reseting the clock to zero
        this.myClockWhenFrameStarted -= clocks;
        this.myClockStartDisplay -= clocks;
        this.myClockStopDisplay -= clocks;
        this.myClockAtLastUpdate -= clocks;
        this.myVSYNCFinishClock -= clocks;
        this.myLastHMOVEClock -= clocks;
    }
    
    /**
     * This method existed originally for debugging.  Performs the obvious.
     * @param aIndex array index
     * @param aValue new value
     */
    this.setCurrentFrameBuffer = function(aIndex, aValue) {
        
        this.getCurrentFrameBuffer()[aIndex]=aValue;
        
    }
    
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.install = function(system) {
        // Remember which system I'm installed in
        this.mySystem = system;
        
        var shift = PAGE_SHIFT;
        this.mySystem.resetCycles();
        
        // All accesses are to this device
        var access=new PageAccess(this);
        access.setIndirectMode();
        
        // We're installing in a 2600 system
        for(var i = 0; i < 8192; i += (1 << shift)) {
            if((i & 0x1080) == 0x0000) {
                this.mySystem.setPageAccess((i >> shift) /*% 256*/, access);
            }
        }
        
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * This method is the one that causes the CPU to execute.  It should be run once per frame.
     */
    this.processFrame = function() {
        
     
        
        if (!this.myPartialFrameFlag) this.startFrame();
        this.myPartialFrameFlag=true;
        
        
        
        // Execute instructions until frame is finished, or a breakpoint/trap hits
        // 25000 is an arbitrary high number...this is called with the assumption that it will stop
        // before then (e.g. if the TIA is poked at VSYNC, depending on its state, it may halt the CPU,
        // thus completing the frame
        
        var zExecutions=0;
        var zInstructionsExecuted=0;
      //    long zTimeA=System.nanoTime();
        do{
            
            //A not very elegant work-around :
            //Some ROMs have a BRK instruction which terminates the execution before the frame is done...
            //this will keep calling executeCPU (up to 9 or 10 times) to see if it finishes the frame
            
           zInstructionsExecuted += this.mySystem.executeCPU(25000);
            zExecutions++;
            if (this.myPartialFrameFlag==false) break;
            
        }while (zExecutions<3);
        //todo : this execution do-while think may be unneeded-figure out
         if (zExecutions>=3) 
         {
            if (this.debugHasExecutionOverrun==false) console.log("debug: ********** Execution overrun in TIA *********");
            this.debugHasExecutionOverrun=true;
            //assert(false);  //california games sets this assertion off
         }//end : too many executions
        //  long zTimeB=System.nanoTime();  
        /* if (JSConsole.DEBUG_MODE_ON==true)
        {
            int zDeltaBA=(int)(zTimeB - zTimeA) / 1000;
             
            System.out.println("debug JSTIA execute CPU : " + zDeltaBA + " microsec");
        }//end : debug mode on
         */
          
       // if (JSConsole.DEBUG_MODE_ON==true) System.out.println("debug JSTIA - " + zInstructionsExecuted + " instructions executed");;
        var totalClocks = (this.mySystem.getCycles() * CLOCKS_PER_CPU_CYCLE) - this.myClockWhenFrameStarted;
        this.myCurrentScanline = totalClocks / CLOCKS_PER_LINE_TOTAL;
        
        if (!this.myPartialFrameFlag) this.endFrame();
       
        
    }
    
//----------
    
    /**
     * (A method that allowed me to type less when converting C++ to Java. It makes for
     * more readable code as well. -JLA)
     * @param aValue an integer
     * @return the boolean equivalent (in C++) of the integer
     */
    this.bool = function(aValue) {
        if (aValue==0) return false;
        else return true;
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * Called by update() at the start of a new frame.
     */
    this.startFrame = function() {
        // This stuff should only happen at the beginning of a new frame.
     
     
        this.myConsole.getVideo().swapFrameBuffers();
        // Remember the number of clocks which have passed on the current scanline
        // so that we can adjust the frame's starting clock by this amount.  This
        // is necessary since some games position objects during VSYNC and the
        // TIA's internal counters are not reset by VSYNC.
        var clocks = ((this.mySystem.getCycles() * CLOCKS_PER_CPU_CYCLE) - this.myClockWhenFrameStarted) % CLOCKS_PER_LINE_TOTAL;
        
        // Ask the system to reset the cycle count so it doesn't overflow
        this.mySystem.resetCycles();
        
        // Setup clocks that'll be used for drawing this frame
        this.myClockWhenFrameStarted = -1 * clocks;
        
        
        //this.myClockWhenFrameStarted=0;
        this.myClockStartDisplay = this.myClockWhenFrameStarted + (CLOCKS_PER_LINE_TOTAL * this.getYStart());
        this.myClockStopDisplay = this.myClockWhenFrameStarted + (CLOCKS_PER_LINE_TOTAL * (this.getYStart() + this.getDisplayHeight())); //myStopDisplayOffset;
        this.myClockAtLastUpdate = this.myClockStartDisplay;
        this.myClocksToEndOfScanLine = CLOCKS_PER_LINE_TOTAL;
        
        // Reset frame buffer pointer
        this.myFramePointer = 0;//myCurrentFrameBuffer;
        
        // If color loss is enabled then update the color registers based on
        // the number of scanlines in the last frame that was generated
        if(this.myColorLossEnabled) {
            if((this.myScanlineCountForLastFrame & 0x01)!=0) {
                this.myTIAPokeRegister[COLUP0] |= 0x01010101;
                this.myTIAPokeRegister[COLUP1] |= 0x01010101;
                this.myTIAPokeRegister[COLUPF] |= 0x01010101;
                this.myTIAPokeRegister[COLUBK] |= 0x01010101;
            } else {
                this.myTIAPokeRegister[COLUP0] &= 0xfefefefe;
                this.myTIAPokeRegister[COLUP1] &= 0xfefefefe;
                this.myTIAPokeRegister[COLUPF] &= 0xfefefefe;
                this.myTIAPokeRegister[COLUBK] &= 0xfefefefe;
            }
        }
        
        
        
      
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * Called by update() at the end of a frame.
     */
    this.endFrame = function() {
        // This stuff should only happen at the end of a frame
        // Compute the number of scanlines in the frame
        this.myScanlineCountForLastFrame = this.myCurrentScanline;
        
    
    }
    
    
    
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.clocksThisLine = function() {
        // calculate the current scanline
        var totalClocks = (this.mySystem.getCycles() * CLOCKS_PER_CPU_CYCLE) - this.myClockWhenFrameStarted;
        return totalClocks % CLOCKS_PER_LINE_TOTAL;
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    
    this.isPlayfieldPixelOn = function(aHPos)
    {
        var zPFBlock=aHPos / CLOCKS_PER_PLAYFIELD_BIT;
        if (zPFBlock >= 20)
        {
            if (this.isBitOn(0, this.myTIAPokeRegister[CTRLPF])==true) zPFBlock=39 - zPFBlock; //reflected
            else zPFBlock=zPFBlock - 20;
        }//end : right half of screen
        if (zPFBlock < 4) return this.isBitOn(4 + zPFBlock, this.myTIAPokeRegister[PF0]); //7 - zPFBlock, myTIAPokeRegister[PF0]);
        else if (zPFBlock < 12) return this.isBitOn(11 - zPFBlock, this.myTIAPokeRegister[PF1]);
        else return this.isBitOn(zPFBlock - 12, this.myTIAPokeRegister[PF2]); //(19 - zPFBlock, myTIAPokeRegister[PF2]);
    }
    
    this.isPlayer0PixelOn = function (aHPos) {   return ((this.myCurrentGRP0 & this.getCurrentP0Mask(aHPos))!=0);  }    
    this.isPlayer1PixelOn = function(aHPos) {   return ((this.myCurrentGRP1 & this.getCurrentP1Mask(aHPos))!=0);  }    
    this.isMissile0PixelOn = function(aHPos) {  return this.getCurrentM0Mask(aHPos);  }    
    this.isMissile1PixelOn = function(aHPos) {  return this.getCurrentM1Mask(aHPos);   }    
    this.isRESMP0 = function()  {    return ((this.myTIAPokeRegister[RESMP0] & BIT1) != 0);  }    
    this.isRESMP1 = function()  {    return ((this.myTIAPokeRegister[RESMP1] & BIT1) != 0);  }
            
    
    this.updatePlayfieldStatus = function()
    {
        if (((this.myTIAPokeRegister[PF0]&0xF0)==0)&&(this.myTIAPokeRegister[PF1]==0)&&(this.myTIAPokeRegister[PF2]==0)) this.myEnabledObjects &= ~BIT_PF;
        else this.myEnabledObjects |= BIT_PF;
         
        
    }
  
    
    this.memsetFrameBuffer = function(aIndex, aByteValue, aCount) {
        for (var i=0; i<aCount; i++) {   this.setCurrentFrameBuffer(aIndex+i,(aByteValue & 0xFF)); }//end : for i loop
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * This is the method that takes the values in the registers and uses them to 
     * create graphics (one horizontal line's worth) in JSVideo's FrameBuffer object.  
     * This is the very large version, which is slightly faster (although may not be 
     * significant on today's machines) than the smaller one (called updateFrameScanlineSimple at the moment.)
     * @param clocksToUpdate how many clocks to update
     * @param hpos current horizontal position
     */
    this.updateFrameScanline = function(clocksToUpdate, hpos) {
        // Calculate the zEnding frame pointer value
        var zEnding=this.myFramePointer + clocksToUpdate;
        
        
        // See if we're in the vertical blank region
        // if(bool(myVBLANK & 0x02)) {
        if (this.isBitOn(1, this.myTIAPokeRegister[VBLANK]))  {
            this.memsetFrameBuffer(this.myFramePointer, 0, clocksToUpdate);
        }
        // Handle all other possible combinations
        else {
            var zDebugSwitch=this.myEnabledObjects | this.myPlayfieldPriorityAndScore;
            if ((zDebugSwitch>=0)&&(zDebugSwitch<0x100)) this.debugRenderTypes[zDebugSwitch]=true;
            switch(this.myEnabledObjects | this.myPlayfieldPriorityAndScore) {
                // Background
                case 0x00:
                case 0x00 | BIT_SCORE:
                case 0x00 | BIT_PRIORITY:
                case 0x00 | BIT_PRIORITY | BIT_SCORE:
                {
                    this.memsetFrameBuffer(this.myFramePointer, this.myTIAPokeRegister[COLUBK], clocksToUpdate);
                    break;
                }
                
                // Playfield is enabled and the score bit is not set
                case BIT_PF:
                case BIT_PF | BIT_PRIORITY:
                {
                   // int mask = hpos; //this.myCurrentPFMask[hpos];
                    while (this.myFramePointer<zEnding) {
                       
                        this.setCurrentFrameBuffer(this.myFramePointer, this.isPlayfieldPixelOn(hpos) ? this.myTIAPokeRegister[COLUPF] : this.myTIAPokeRegister[COLUBK]);
                       
                        this.myFramePointer++;
                   
                        hpos++;
                    }//end : while loop
                    
                    break;
                }
                
                // Playfield is enabled and the score bit is set
                case BIT_PF | BIT_SCORE:
                case BIT_PF | BIT_SCORE | BIT_PRIORITY:
                {
                   // int mask = hpos;//&myCurrentPFMask[hpos];
                    while (this.myFramePointer<zEnding) {
                    
                        
                            this.setCurrentFrameBuffer(this.myFramePointer, this.isPlayfieldPixelOn(hpos) ?
                            (hpos < 80 ? this.myTIAPokeRegister[COLUP0] : this.myTIAPokeRegister[COLUP1]) : this.myTIAPokeRegister[COLUBK]);
                           
                        this.myFramePointer++;
                     
                        hpos++;
                    }//end : while loop
                    // Update a uInt8 at a time until reaching a int boundary
                    
                    break;
                }
                
                // Player 0 is enabled
                case BIT_P0:
                case BIT_P0 | BIT_SCORE:
                case BIT_P0 | BIT_PRIORITY:
                case BIT_P0 | BIT_SCORE | BIT_PRIORITY:
                {
                   // int mP0 = hpos;
                    
                    while(this.myFramePointer < zEnding) {
                        var zPlayer0Pixel=this.isPlayer0PixelOn(hpos);
                        
                         this.setCurrentFrameBuffer(this.myFramePointer, zPlayer0Pixel ? this.myTIAPokeRegister[COLUP0] : this.myTIAPokeRegister[COLUBK]);
                    
                         hpos++;
                        this.myFramePointer++;
                        
                    }
                    break;
                }
                
                // Player 1 is enabled
                case BIT_P1:
                case BIT_P1 | BIT_SCORE:
                case BIT_P1 | BIT_PRIORITY:
                case BIT_P1 | BIT_SCORE | BIT_PRIORITY:
                {
                 
                    
                    while(this.myFramePointer < zEnding) {
                       this.setCurrentFrameBuffer(this.myFramePointer, this.isPlayer1PixelOn(hpos) ? this.myTIAPokeRegister[COLUP1] : this.myTIAPokeRegister[COLUBK]);
                    
                       this.myFramePointer++;
                        hpos++;
                        
                    }
                    break;
                }
                
                // Player 0 and 1 are enabled
                case BIT_P0 | BIT_P1:
                case BIT_P0 | BIT_P1 | BIT_SCORE:
                case BIT_P0 | BIT_P1 | BIT_PRIORITY:
                case BIT_P0 | BIT_P1 | BIT_SCORE | BIT_PRIORITY:
                {
                  
                    
                    while(this.myFramePointer < zEnding) {
                        var zPlayer0Pixel=this.isPlayer0PixelOn(hpos);
                        var zPlayer1Pixel=this.isPlayer1PixelOn(hpos);
                        this.setCurrentFrameBuffer(this.myFramePointer, zPlayer0Pixel ?
                            this.myTIAPokeRegister[COLUP0] : (zPlayer1Pixel ? this.myTIAPokeRegister[COLUP1] : this.myTIAPokeRegister[COLUBK]));
                        
                        if(zPlayer0Pixel && zPlayer1Pixel) this.myCollision |= COLLISION_TABLE[BIT_P0 | BIT_P1];
                        
                       
                     
                        this.myFramePointer++;
                        hpos++;
                        
                        
                    }
                    break;
                }
                
                // Missile 0 is enabled
                case BIT_M0:
                case BIT_M0 | BIT_SCORE:
                case BIT_M0 | BIT_PRIORITY:
                case BIT_M0 | BIT_SCORE | BIT_PRIORITY:
                {
                    var mM0 = hpos;
                    
                    while(this.myFramePointer < zEnding) {
                        var zMMask=this.getCurrentM0Mask(mM0);
                        
                        this.setCurrentFrameBuffer(this.myFramePointer, zMMask ? this.myTIAPokeRegister[COLUP0] : this.myTIAPokeRegister[COLUBK]);
                        ++mM0; 
                        ++this.myFramePointer;
                          hpos++;
                        
                    }
                    break;
                }
                
                // Missile 1 is enabled
                case BIT_M1:
                case BIT_M1 | BIT_SCORE:
                case BIT_M1 | BIT_PRIORITY:
                case BIT_M1 | BIT_SCORE | BIT_PRIORITY:
                {
                    var mM1 = hpos;//this.myCurrentM1Mask[hpos];
                    
                    while(this.myFramePointer < zEnding) {
                        this.setCurrentFrameBuffer(this.myFramePointer, this.getCurrentM1Mask(mM1) ? this.myTIAPokeRegister[COLUP1] : this.myTIAPokeRegister[COLUBK]);
                        ++mM1;
                        ++this.myFramePointer;
                         hpos++; 
                        
                    }
                    break;
                }
                
                // Ball is enabled
                case BIT_BL:
                case BIT_BL | BIT_SCORE:
                case BIT_BL | BIT_PRIORITY:
                case BIT_BL | BIT_SCORE | BIT_PRIORITY:
                {
                    var mBL = hpos;// &this.myCurrentBLMask[hpos];
                    
                    while(this.myFramePointer < zEnding) {
                        this.setCurrentFrameBuffer(this.myFramePointer, this.getCurrentBLMask(mBL) ? this.myTIAPokeRegister[COLUPF] : this.myTIAPokeRegister[COLUBK]);
                        ++mBL; ++this.myFramePointer;
                          hpos++;
                        
                    }
                    break;
                }
                
                // Missile 0 and 1 are enabled
                case BIT_M0 | BIT_M1:
                case BIT_M0 | BIT_M1 | BIT_SCORE:
                case BIT_M0 | BIT_M1 | BIT_PRIORITY:
                case BIT_M0 | BIT_M1 | BIT_SCORE | BIT_PRIORITY:
                {
                    var mM0  = hpos;//this.myCurrentM0Mask[hpos];
                    var mM1  = hpos;//this.myCurrentM1Mask[hpos];
                    
                    while(this.myFramePointer < zEnding) {
                        this.setCurrentFrameBuffer(this.myFramePointer, this.getCurrentM0Mask(mM0) ? this.myTIAPokeRegister[COLUP0] : (this.getCurrentM1Mask(mM1) ? this.myTIAPokeRegister[COLUP1] : this.myTIAPokeRegister[COLUBK]));
                        
                        if(this.getCurrentM0Mask(mM0) && this.getCurrentM1Mask(mM1))
                            this.myCollision |= COLLISION_TABLE[BIT_M0 | BIT_M1];
                          hpos++;
                        ++mM0; ++mM1; ++this.myFramePointer;
                        
                    }
                    break;
                }
                
                // Ball and Missile 0 are enabled and playfield priority is not set
                case BIT_BL | BIT_M0:
                case BIT_BL | BIT_M0 | BIT_SCORE:
                {
                    var mBL = hpos;//this.myCurrentBLMask[hpos];
                    var mM0 = hpos;//this.myCurrentM0Mask[hpos];
                    
                    while(this.myFramePointer < zEnding) {
                        this.setCurrentFrameBuffer(this.myFramePointer, (this.getCurrentM0Mask(mM0) ? this.myTIAPokeRegister[COLUP0] : (this.getCurrentBLMask(mBL) ? this.myTIAPokeRegister[COLUPF] : this.myTIAPokeRegister[COLUBK])));
                        
                        if(this.getCurrentBLMask(mBL) && this.getCurrentM0Mask(mM0))
                            this.myCollision |= COLLISION_TABLE[BIT_BL | BIT_M0];
                        
                        ++mBL; ++mM0; ++this.myFramePointer;
                          hpos++;
                    }
                    break;
                }
                
                // Ball and Missile 0 are enabled and playfield priority is set
                case BIT_BL | BIT_M0 | BIT_PRIORITY:
                case BIT_BL | BIT_M0 | BIT_SCORE | BIT_PRIORITY:
                {
                    var mBL = hpos;//myCurrentBLMask[hpos];
                    var mM0 = hpos;//myCurrentM0Mask[hpos];
                    
                    while(this.myFramePointer < zEnding) {
                        this.setCurrentFrameBuffer(this.myFramePointer, (this.getCurrentBLMask(mBL) ? this.myTIAPokeRegister[COLUPF] : (this.getCurrentM0Mask(mM0) ? this.myTIAPokeRegister[COLUP0] : this.myTIAPokeRegister[COLUBK])));
                        
                        if(this.getCurrentBLMask(mBL) && this.getCurrentM0Mask(mM0))
                            this.myCollision |= COLLISION_TABLE[BIT_BL | BIT_M0];
                        
                        ++mBL; ++mM0; ++this.myFramePointer;
                          hpos++;
                    }
                    break;
                }
                
                // Ball and Missile 1 are enabled and playfield priority is not set
                case BIT_BL | BIT_M1:
                case BIT_BL | BIT_M1 | BIT_SCORE:
                {
                    var mBL = hpos;//this.myCurrentBLMask[hpos];
                    var mM1 = hpos;//this.myCurrentM1Mask[hpos];
                    
                    while(this.myFramePointer < zEnding) {
                        this.setCurrentFrameBuffer(this.myFramePointer, (this.getCurrentM1Mask(mM1) ? this.myTIAPokeRegister[COLUP1] : (this.getCurrentBLMask(mBL) ? this.myTIAPokeRegister[COLUPF] : this.myTIAPokeRegister[COLUBK])));
                        
                        if(this.getCurrentBLMask(mBL) && this.getCurrentM1Mask(mM1))
                            this.myCollision |= COLLISION_TABLE[BIT_BL | BIT_M1];
                        
                        ++mBL; ++mM1; ++this.myFramePointer;
                          hpos++;
                        
                    }
                    break;
                }
                
                // Ball and Missile 1 are enabled and playfield priority is set
                case BIT_BL | BIT_M1 | BIT_PRIORITY:
                case BIT_BL | BIT_M1 | BIT_SCORE | BIT_PRIORITY:
                {
                    var mBL = hpos;//this.myCurrentBLMask[hpos];
                    var mM1 = hpos;//this.myCurrentM1Mask[hpos];
                    
                    while(this.myFramePointer < zEnding) {
                        this.setCurrentFrameBuffer(this.myFramePointer, (this.getCurrentBLMask(mBL) ? this.myTIAPokeRegister[COLUPF] : (this.getCurrentM1Mask(mM1) ? this.myTIAPokeRegister[COLUP1] : this.myTIAPokeRegister[COLUBK])));
                        
                        if(this.getCurrentBLMask(mBL) && this.getCurrentM1Mask(mM1))
                            this.myCollision |= COLLISION_TABLE[BIT_BL | BIT_M1];
                        
                        ++mBL; ++mM1; ++this.myFramePointer;
                          hpos++;
                    }
                    break;
                }
                
                // Ball and Player 1 are enabled and playfield priority is not set
                case BIT_BL | BIT_P1:
                case BIT_BL | BIT_P1 | BIT_SCORE:
                {
                   var mBL = hpos;//this.myCurrentBLMask[hpos];
                   // int mP1 = hpos;//this.myCurrentP1Mask[hpos];
                    
                    while(this.myFramePointer < zEnding) {
                        var zPlayer1Pixel=this.isPlayer1PixelOn(hpos);
                        this.setCurrentFrameBuffer(this.myFramePointer, zPlayer1Pixel ? this.myTIAPokeRegister[COLUP1] :
                            (this.getCurrentBLMask(mBL) ? this.myTIAPokeRegister[COLUPF] : this.myTIAPokeRegister[COLUBK]));
                        
                        if(this.getCurrentBLMask(mBL) && zPlayer1Pixel)
                            this.myCollision |= COLLISION_TABLE[BIT_BL | BIT_P1];
                        
                        ++mBL; 
                        //++mP1; 
                        ++this.myFramePointer;
                          hpos++;
                        
                    }
                    break;
                }
                
                // Ball and Player 1 are enabled and playfield priority is set
                case BIT_BL | BIT_P1 | BIT_PRIORITY:
                case BIT_BL | BIT_P1 | BIT_PRIORITY | BIT_SCORE:
                {
                    var mBL = hpos;//this.myCurrentBLMask[hpos];
                 
                    
                    while(this.myFramePointer < zEnding) {
                        var zPlayer1Pixel=this.isPlayer1PixelOn(hpos);
                        this.setCurrentFrameBuffer(this.myFramePointer, this.getCurrentBLMask(mBL) ? this.myTIAPokeRegister[COLUPF] :
                            (zPlayer1Pixel ? this.myTIAPokeRegister[COLUP1] : this.myTIAPokeRegister[COLUBK]));
                        
                        if(this.getCurrentBLMask(mBL) && zPlayer1Pixel)
                            this.myCollision |= COLLISION_TABLE[BIT_BL | BIT_P1];
                        
                        ++mBL; 
                        //++mP1; 
                        ++this.myFramePointer;
                          hpos++;
                    }
                    break;
                }
                
                // Playfield and Player 0 are enabled and playfield priority is not set
                case BIT_PF | BIT_P0:
                {
                   // int mPF = hpos;// &this.myCurrentPFMask[hpos];
                   // int mP0 = hpos;//this.myCurrentP0Mask[hpos];
                    
                    while(this.myFramePointer < zEnding) {
                    
                         var zPlayfieldIsOn=this.isPlayfieldPixelOn(hpos);
                         var zPlayer0Pixel=this.isPlayer0PixelOn(hpos);
                         this.setCurrentFrameBuffer(this.myFramePointer, zPlayer0Pixel ?
                            this.myTIAPokeRegister[COLUP0] : (zPlayfieldIsOn ? this.myTIAPokeRegister[COLUPF] : this.myTIAPokeRegister[COLUBK]));
                        
                        if(zPlayfieldIsOn && zPlayer0Pixel)
                            this.myCollision |= COLLISION_TABLE[BIT_PF | BIT_P0];
                        
                        hpos++;
                        
                       
                        ++this.myFramePointer;
                        
                    }
                    
                    break;
                }
                
                // Playfield and Player 0 are enabled and playfield priority is set
                case BIT_PF | BIT_P0 | BIT_PRIORITY:
                {
                  //  int mPF = hpos; // &this.myCurrentPFMask[hpos];
                    //int mP0 = hpos;//this.myCurrentP0Mask[hpos];
                    
                    while(this.myFramePointer < zEnding) {
                      
                        var zPlayfieldIsOn=this.isPlayfieldPixelOn(hpos);
                        var zPlayer0Pixel=this.isPlayer0PixelOn(hpos);
                            this.setCurrentFrameBuffer(this.myFramePointer, zPlayfieldIsOn ? this.myTIAPokeRegister[COLUPF] :
                            (zPlayer0Pixel ? this.myTIAPokeRegister[COLUP0] : this.myTIAPokeRegister[COLUBK]));
                        if(zPlayfieldIsOn && zPlayer0Pixel)
                            this.myCollision |= COLLISION_TABLE[BIT_PF | BIT_P0];
                        
                        hpos++;
                      
                        ++this.myFramePointer;
                        
                        
                        
                    }
                    
                    break;
                }
                
                // Playfield and Player 1 are enabled and playfield priority is not set
                case BIT_PF | BIT_P1:
                {
                 
                    
                    while(this.myFramePointer < zEnding) {
                           var zPlayfieldIsOn=this.isPlayfieldPixelOn(hpos);
                           var zPlayer1Pixel=this.isPlayer1PixelOn(hpos);
                     
                          this.setCurrentFrameBuffer(this.myFramePointer, zPlayer1Pixel ?
                            this.myTIAPokeRegister[COLUP1] : (zPlayfieldIsOn ? this.myTIAPokeRegister[COLUPF] : this.myTIAPokeRegister[COLUBK]));
                        
                        if(zPlayfieldIsOn && zPlayer1Pixel)
                            this.myCollision |= COLLISION_TABLE[BIT_PF | BIT_P1];  
                           
                        hpos++;
                         //++mP1; 
                         ++this.myFramePointer;
                        
                    }
                    
                    break;
                }
                
                // Playfield and Player 1 are enabled and playfield priority is set
                case BIT_PF | BIT_P1 | BIT_PRIORITY:
                {
                   
                    
                    while(this.myFramePointer < zEnding) {
                            var zPlayfieldIsOn=this.isPlayfieldPixelOn(hpos);
                            var zPlayer1Pixel=this.isPlayer1PixelOn(hpos);
                       
                          this.setCurrentFrameBuffer(this.myFramePointer, zPlayfieldIsOn ? this.myTIAPokeRegister[COLUPF] :
                            (zPlayer1Pixel ? this.myTIAPokeRegister[COLUP1] : this.myTIAPokeRegister[COLUBK]));
                        if(zPlayfieldIsOn && zPlayer1Pixel)
                            this.myCollision |= COLLISION_TABLE[BIT_PF | BIT_P1];   
                            
                        hpos++;    
                         //++mP1; 
                         ++this.myFramePointer;
                        
                        
                    }
                    
                    break;
                }
                
                // Playfield and Ball are enabled
                case BIT_PF | BIT_BL:
                case BIT_PF | BIT_BL | BIT_PRIORITY:
                {
                 
                    var mBL = hpos;//this.myCurrentBLMask[hpos];
                    
                    while(this.myFramePointer < zEnding) {
                        var zPlayfieldIsOn=this.isPlayfieldPixelOn(hpos);
                    
                         this.setCurrentFrameBuffer(this.myFramePointer, (zPlayfieldIsOn || this.getCurrentBLMask(mBL)) ? this.myTIAPokeRegister[COLUPF] : this.myTIAPokeRegister[COLUBK]);
                        
                        if(zPlayfieldIsOn && this.getCurrentBLMask(mBL))
                            this.myCollision |= COLLISION_TABLE[BIT_PF | BIT_BL];
                        
                        hpos++;
                        ++mBL; ++this.myFramePointer;
                        
                    }
                    break;
                }
                
                // Handle all of the other cases
                default:
                {
                    for(; this.myFramePointer < zEnding; ++this.myFramePointer, ++hpos) {
                        var enabled = this.isPlayfieldPixelOn(hpos) ? BIT_PF : 0;            //bool(this.myPF  & this.myCurrentPFMask[hpos]) ? BIT_PF : 0;
                        
                        if(this.bool(this.myEnabledObjects & BIT_BL) && this.getCurrentBLMask(hpos))    enabled |= BIT_BL;
                        if (this.isPlayer1PixelOn(hpos))                 enabled |= BIT_P1;
                        if(this.bool(this.myEnabledObjects & BIT_M1) && this.getCurrentM1Mask(hpos))    enabled |= BIT_M1;
                        if (this.isPlayer0PixelOn(hpos))                 enabled |= BIT_P0;
                        if(this.bool(this.myEnabledObjects & BIT_M0) && this.getCurrentM0Mask(hpos))    enabled |= BIT_M0;
                        
                        this.myCollision |= COLLISION_TABLE[enabled];
                        this.setCurrentFrameBuffer(this.myFramePointer, this.getColor(PRIORITY_ENCODER[hpos < 80 ? 0 : 1][enabled | this.myPlayfieldPriorityAndScore]));
                    }//end : for loop
                    break;
                }//end : default case
            }//end : switch
        }
        this.myFramePointer = zEnding;
    }
    
    /**
     * This is a trimmed-up version of updateFrameScanline.  It is
     * much smaller, but takes a little more time to execute.  
     * This method perhaps should replace the 
     * updateFrameScanline method, for simplicity reasons.
     * (It needs to be worked on--some games (e.g. med. mayhem) shake with this method.
     * @param aClocksToUpdate How many clocks to update
     * @param aHPos Current horizontal position
     */
    this.updateFrameScanlineSimple = function(aClocksToUpdate, aHPos)
    {
        var zEnding=this.myFramePointer + aClocksToUpdate;       
        
        // See if we're in the vertical blank region
        // if(bool(this.myVBLANK & 0x02)) {
        if (this.isBitOn(1, this.myTIAPokeRegister[VBLANK]))  {
            this.memsetFrameBuffer(this.myFramePointer, 0, aClocksToUpdate);
        }
       
        else {
        var zBallEnabled=((this.myEnabledObjects & BIT_BL)!=0);
        var zPlayfieldEnabled=((this.myEnabledObjects & BIT_PF)!=0);
        var zPlayer0Enabled=((this.myEnabledObjects & BIT_P0)!=0);
        var zPlayer1Enabled=((this.myEnabledObjects & BIT_P1)!=0);
        var zMissile0Enabled=((this.myEnabledObjects & BIT_M0)!=0);
        var zMissile1Enabled=((this.myEnabledObjects & BIT_M1)!=0);
         
             
        for(; this.myFramePointer < zEnding; ++this.myFramePointer, ++aHPos) {
                        var enabled = 0;
                        
                        if (zPlayfieldEnabled && this.isPlayfieldPixelOn(aHPos)) enabled |= BIT_PF; // : 0;            //bool(this.myPF  & this.myCurrentPFMask[aHPos]) ? BIT_PF : 0;
                        
                        if(zBallEnabled && this.getCurrentBLMask(aHPos))    enabled |= BIT_BL;
                        if (zPlayer1Enabled && this.isPlayer1PixelOn(aHPos))                 enabled |= BIT_P1;
                        if(zMissile1Enabled && this.getCurrentM1Mask(aHPos))    enabled |= BIT_M1;
                        if (zPlayer0Enabled && this.isPlayer0PixelOn(aHPos))                 enabled |= BIT_P0;
                        if(zMissile0Enabled && this.getCurrentM0Mask(aHPos))    enabled |= BIT_M0;
                        
                        this.myCollision |= COLLISION_TABLE[enabled];
                        this.setCurrentFrameBuffer(this.myFramePointer, this.getColor(PRIORITY_ENCODER[aHPos < 80 ? 0 : 1][enabled | this.myPlayfieldPriorityAndScore]));
                    }//end : for loop 
        
        }//end : vblank not on
        
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.updateFrame = function(clock) {
        
        // See if we're in the nondisplayable portion of the screen or if
        // we've already updated this portion of the screen
        if((clock < this.myClockStartDisplay) ||  (clock <= this.myClockAtLastUpdate)|| (this.myClockAtLastUpdate >= this.myClockStopDisplay) ) {
            return;
        }
        
        // Truncate the number of cycles to update to the stop display point
        if(clock > this.myClockStopDisplay)  clock = this.myClockStopDisplay;
        
        // Update frame one scanline at a time
        do //START OF LOOP
        {
            // Compute the number of clocks we're going to update
            var clocksToUpdate = 0;
            
            // Remember how many clocks we are from the left side of the screen
            var clocksFromStartOfScanLine = CLOCKS_PER_LINE_TOTAL - this.myClocksToEndOfScanLine;
            
            // See if we're updating more than the current scanline
            if(clock > (this.myClockAtLastUpdate + this.myClocksToEndOfScanLine)) {
                // Yes, we have more than one scanline to update so finish current one
                clocksToUpdate = this.myClocksToEndOfScanLine;
                this.myClocksToEndOfScanLine = CLOCKS_PER_LINE_TOTAL;
                this.myClockAtLastUpdate += clocksToUpdate;
            } else {
                // No, so do as much of the current scanline as possible
                clocksToUpdate = clock - this.myClockAtLastUpdate;
                this.myClocksToEndOfScanLine -= clocksToUpdate;
                this.myClockAtLastUpdate = clock;
            }
            
            var startOfScanLine = CLOCKS_PER_LINE_BLANK + this.myFrameXStart;
            
            // Skip over as many horizontal blank clocks as we can
            if(clocksFromStartOfScanLine < startOfScanLine) {
                var tmp;
                
                if((startOfScanLine - clocksFromStartOfScanLine) < clocksToUpdate)
                    tmp = startOfScanLine - clocksFromStartOfScanLine;
                else
                    tmp = clocksToUpdate;
                
                clocksFromStartOfScanLine += tmp;
                clocksToUpdate -= tmp;
            }
            
            // Remember frame pointer in case HMOVE blanks need to be handled
            var oldFramePointer = this.myFramePointer;
            
            // Update as much of the scanline as we can
            if(clocksToUpdate != 0) {
                this.updateFrameScanline(clocksToUpdate, clocksFromStartOfScanLine - CLOCKS_PER_LINE_BLANK);
               //updateFrameScanlineSimple(clocksToUpdate, clocksFromStartOfScanLine - CLOCKS_PER_LINE_BLANK);
            }
            
            // Handle HMOVE blanks if they are enabled
            if(this.myHMOVEBlankEnabled && (startOfScanLine < CLOCKS_PER_LINE_BLANK + 8) &&(clocksFromStartOfScanLine < (CLOCKS_PER_LINE_BLANK + 8))) {
                var blanks = (CLOCKS_PER_LINE_BLANK + 8) - clocksFromStartOfScanLine;
                this.memsetFrameBuffer(oldFramePointer, 0, blanks);
                if((clocksToUpdate + clocksFromStartOfScanLine) >= (CLOCKS_PER_LINE_BLANK + 8))  this.myHMOVEBlankEnabled = false;
            }
            
            // See if we're at the end of a scanline
            if(this.myClocksToEndOfScanLine == CLOCKS_PER_LINE_TOTAL) {
                this.myFramePointer -= (CLOCKS_PER_LINE_VISIBLE - this.myConsole.getDisplayWidth() - this.myFrameXStart);
                
                // Yes, so set PF mask based on current CTRLPF reflection state
               // this.myCurrentPFMask = PLAYFIELD_TABLE[this.myTIAPokeRegister[CTRLPF] & 0x01];
                //TODO : figure out what this did exactly
                
                // TODO: These should be reset right after the first copy of the player
                // has passed.  However, for now we'll just reset at the end of the
                // scanline since the other way would be too slow (01/21/99).
                
                this.setCurrentP0Mask(this.myPOSP0 & 0x03,0,this.myTIAPokeRegister[NUSIZ0] & 0x07,CLOCKS_PER_LINE_VISIBLE - (this.myPOSP0 & 0xFC));
                this.setCurrentP1Mask(this.myPOSP1 & 0x03,0,this.myTIAPokeRegister[NUSIZ1] & 0x07,CLOCKS_PER_LINE_VISIBLE - (this.myPOSP1 & 0xFC));
                
                
                // Handle the "Cosmic Ark" TIA bug if it's enabled
                if(this.myM0CosmicArkMotionEnabled) this.emulateCosmicBug();
                
                
            }//end: clocks to end of scanline == CLOCKS_PER_LINE_TOTAL
        }
        while(this.myClockAtLastUpdate < clock);
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.emulateCosmicBug = function() {
        // Movement table associated with the bug
        
        this.myM0CosmicArkCounter = (this.myM0CosmicArkCounter + 1) & 3;
        this.myPOSM0 -= COSMICBUG_MOVEMENT[this.myM0CosmicArkCounter];
        
        if(this.myPOSM0 >= CLOCKS_PER_LINE_VISIBLE)
            this.myPOSM0 -= CLOCKS_PER_LINE_VISIBLE;
        else if(this.myPOSM0 < 0)
            this.myPOSM0 += CLOCKS_PER_LINE_VISIBLE;
        
        if(this.myM0CosmicArkCounter == 1) {
            // Stretch this missile so it's at least 2 pixels wide
            
            this.setCurrentM0Mask(this.myPOSM0 & 0x03, this.myTIAPokeRegister[NUSIZ0] & 0x07, ((this.myTIAPokeRegister[NUSIZ0] & 0x30) >> 4) | 0x01, CLOCKS_PER_LINE_VISIBLE - (this.myPOSM0 & 0xFC));
        } else if(this.myM0CosmicArkCounter == 2) {
            // Missile is disabled on this line
            
            this.setCurrentM0MaskDisabled();
        } else {
            
            this.setCurrentM0Mask(this.myPOSM0 & 0x03, this.myTIAPokeRegister[NUSIZ0] & 0x07, ((this.myTIAPokeRegister[NUSIZ0] & 0x30) >> 4), CLOCKS_PER_LINE_VISIBLE - (this.myPOSM0 & 0xFC));
            
        }
    }
    
    
    
    this.waitHorizontalSync = function() {
        var cyclesToEndOfLine = 76 - ((this.mySystem.getCycles() -
                (this.myClockWhenFrameStarted / CLOCKS_PER_CPU_CYCLE)) % 76);
        
        if(cyclesToEndOfLine < 76) {
            this.mySystem.incrementCycles(cyclesToEndOfLine);
        }
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 /*private void greyOutFrame() {
        int c = scanlines();
        if(c < this.myYStart) c = this.myYStart;
  
        for( int s = c; s < (this.myHeight + this.myYStart); s++)
            for( int i = 0; i < 160; i++) {
            int tmp = this.myCurrentFrameBuffer[ (s - this.myYStart) * 160 + i] & 0x0f;
            tmp >>= 1;
            setCurrentFrameBuffer((s - this.myYStart) * 160 + i, tmp);
            }
        System.out.println("debug: FRAME GREY : " + System.currentTimeMillis());
  
    }
  */
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   /* protected void clearBuffers() {
        for(int i = 0; i < CLOCKS_PER_LINE_VISIBLE * 300; ++i) {
            setCurrentFrameBuffer(i,  0);
            this.myPreviousFrameBuffer[i] = 0;
        }
        //  System.out.println("debug: CLEARING BUFFERS");
    }
    */
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * Returns a value associated with the given address.
     * The peekable addresses of the TIA are those that involve either a collision
     * register or an external input (e.g. paddles).
     * @param addr Address to peek
     * @return Byte value associated with the address
     */
    this.peek = function(addr) {
        var zReturn=0;
        // Update frame to current color clock before we look at anything!
        // dbg.out("Peek - TIA:", (int)addr);
        assert(addr>=0);
        this.updateFrame(this.mySystem.getCycles() * CLOCKS_PER_CPU_CYCLE);
        
        var noise = this.mySystem.getDataBusState() & 0x3F;
        
        switch(addr & 0x000f) {
            case CXM0P://0x00:    // CXM0P
                zReturn=(this.bool(this.myCollision & 0x0001) ? 0x80 : 0x00) |
                        (this.bool(this.myCollision & 0x0002) ? 0x40 : 0x00) | noise; break;
                        
            case CXM1P: //0x01:    // CXM1P
                zReturn=(this.bool(this.myCollision & 0x0004) ? 0x80 : 0x00) |
                        (this.bool(this.myCollision & 0x0008) ? 0x40 : 0x00) | noise; break;
                        
            case CXP0FB: //0x02:    // CXP0FB
                zReturn=(this.bool(this.myCollision & 0x0010) ? 0x80 : 0x00) |
                        (this.bool(this.myCollision & 0x0020) ? 0x40 : 0x00) | noise; break;
                        
            case CXP1FB: //0x03:    // CXP1FB
                zReturn=(this.bool(this.myCollision & 0x0040) ? 0x80 : 0x00) |
                        (this.bool(this.myCollision & 0x0080) ? 0x40 : 0x00) | noise; break;
                        
            case CXM0FB: //0x04:    // CXM0FB
                zReturn=(this.bool(this.myCollision & 0x0100) ? 0x80 : 0x00) |
                        (this.bool(this.myCollision & 0x0200) ? 0x40 : 0x00) | noise; break;
                        
            case CXM1FB: // 0x05:    // CXM1FB
                zReturn=(this.bool(this.myCollision & 0x0400) ? 0x80 : 0x00) |
                        (this.bool(this.myCollision & 0x0800) ? 0x40 : 0x00) | noise; break;
                        
            case CXBLPF: //0x06:    // CXBLPF
                zReturn=(this.bool(this.myCollision & 0x1000) ? 0x80 : 0x00) | noise; break;
                
            case CXPPMM: //0x07:    // CXPPMM
                zReturn=(this.bool(this.myCollision & 0x2000) ? 0x80 : 0x00) |
                        (this.bool(this.myCollision & 0x4000) ? 0x40 : 0x00) | noise; break;
                        
            case INPT0: //0x08:    // INPT0
            {
                var r = this.myConsole.getController(Jack.LEFT).read(AnalogPin.Nine);
                if(r == RESISTANCE_MIN) {
                    zReturn=0x80 | noise; break;
                } else if((r == RESISTANCE_MAX) || this.myDumpEnabled) {
                    zReturn=noise; break;
                } else {
                    var t = (1.6 * r * 0.01E-6);
                    var needed = Math.floor(t * 1.19E6);
                    if(this.mySystem.getCycles() > (this.myDumpDisabledCycle + needed)) {
                        zReturn=0x80 | noise; break;
                    } else {
                        zReturn=noise; break;
                    }
                }
            }
            
            case INPT1: //0x09:    // INPT1
            {
                var r = this.myConsole.getController(Jack.LEFT).read(AnalogPin.Five);
                if(r == RESISTANCE_MIN) {
                    zReturn=0x80 | noise; break;
                } else if((r == RESISTANCE_MAX) || this.myDumpEnabled) {
                    zReturn=noise; break;
                } else {
                    var t = (1.6 * r * 0.01E-6);
                    var needed = Math.floor(t * 1.19E6);
                    if(this.mySystem.getCycles() > (this.myDumpDisabledCycle + needed)) {
                        zReturn=0x80 | noise; break;
                    } else {
                        zReturn=noise; break;
                    }
                }
            }
            
            case INPT2: //0x0A:    // INPT2
            {
                var r = this.myConsole.getController(Jack.RIGHT).read(AnalogPin.Nine);
                if(r == RESISTANCE_MIN) {
                    zReturn=0x80 | noise; break;
                } else if((r == RESISTANCE_MAX) || this.myDumpEnabled) {
                    zReturn=noise; break;
                } else {
                    var t = (1.6 * r * 0.01E-6);
                    var needed = Math.floor(t * 1.19E6);
                    if(this.mySystem.getCycles() > (this.myDumpDisabledCycle + needed)) {
                        zReturn=0x80 | noise; break;
                    } else {
                        zReturn=noise; break;
                    }
                }
            }
            
            case INPT3: //0x0B:    // INPT3
            {
                var r = this.myConsole.getController(Jack.RIGHT).read(AnalogPin.Five);
                if(r == RESISTANCE_MIN) {
                    zReturn=0x80 | noise; break;
                } else if((r == RESISTANCE_MAX) || this.myDumpEnabled) {
                    zReturn=noise; break;
                } else {
                    var t = (1.6 * r * 0.01E-6);
                    var needed = Math.floor(t * 1.19E6);
                    if(this.mySystem.getCycles() > (this.myDumpDisabledCycle + needed)) {
                        zReturn=0x80 | noise; break;
                    } else {
                        zReturn=noise; break;
                    }
                }
            }
            
            case INPT4: //0x0C:    // INPT4
                zReturn=this.myConsole.getController(Jack.LEFT).read(DigitalPin.Six) ?
                    (0x80 | noise) : noise; break;
                    
            case INPT5: //0x0D:    // INPT5
                zReturn=this.myConsole.getController(Jack.RIGHT).read(DigitalPin.Six) ?
                    (0x80 | noise) : noise; break;
                    
            case 0x0E:
                zReturn=noise; break;
                
            default:
                zReturn=noise;
            
                break;
        }
        assert((zReturn>=0)&&(zReturn<0x100));
        return zReturn;
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * Writes a byte to the TIA chip.
     * Depending on the address supplied, either a byte is stored in a TIA register or
     * the TIA performs some function (i.e. STROBE registers), in this case ignoring the byte.
     * This TIA emulator class will outsource any poke of an audio register to the
     * JSAudio object of the console.
     * <p>
     * Note: the TIA will only look at the 6 lowest bits in the address supplied.  This
     * 6 bit number corresponds with the values found in the TIA guide found on the
     * Internet.
     * @param aAddress address to poke
     * @param aByteValue the byte to write to the TIA chip
     */
    this.poke = function (aAddress, aByteValue) {
        assert((aByteValue>=0)&&(aByteValue<0x100));
        
        var addr = aAddress & 0x003f;
        
        var clock = this.getCurrentClockCount(); //this.mySystem.getCycles() * 3;
        var delay = POKE_DELAY_TABLE[addr];
        
        // See if this is a poke to a PF register
        if(delay == -1) {
            var d = [4, 5, 2, 3];
            var x = this.getCurrentXPos();//((clock - this.myClockWhenFrameStarted) % CLOCKS_PER_LINE_TOTAL);
            delay = (d[(x / 3) & 3]);
        }
        
        // Update frame to current CPU cycle before we make any changes!
        this.updateFrame(clock + delay);
        
        // If a VSYNC hasn't been generated in time go ahead and end the frame
        if(this.getCurrentScanline() > this.myMaximumNumberOfScanlines) {
            this.mySystem.stopCPU();//.stop();
            this.myPartialFrameFlag = false;
        }
        
                
       
        
    
      if (addr < TIA_POKE_REGISTER_COUNT) // is the address is a pokable TIA register?
      {
       
        var zPreviousValue=this.myTIAPokeRegister[addr]; //remember what the previous value was, just in case someone below wants to know
       //ASDF 
        this.myTIAPokeRegister[addr]=aByteValue;  //SETS THE NEW VALUE!
             
        switch(addr) {
            case VSYNC:    // VSYNC (vertical sync set/clear)
            {
                // this.myVSYNC = aByteValue;
              	//console.log("Debug : VSYNC poked, value=" + aByteValue + ", scanlines()==" + this.scanlines()); 
                if (((aByteValue & BIT1) != 0) &&((zPreviousValue & BIT1)==0))
                {
                    
                    this.myVSyncOn=this.scanlines();
//                   	console.log("Debug : VSYNC ON, value=" + aByteValue + ", scanlines()==" + this.scanlines()); 
                }//end : turned VBlank ON
               
                
                
                if (this.bool(this.myTIAPokeRegister[VSYNC] & BIT1)) //is bit #1 on?
                {
                    // Indicate when VSYNC should be finished.  This should really
                    // be 3 * 228 according to Atari's documentation, however, some
                    // games don't supply the full 3 scanlines of VSYNC.
                    this.myVSYNCFinishClock = clock + CLOCKS_PER_LINE_TOTAL;
                } else if(!this.bool(this.myTIAPokeRegister[VSYNC] & BIT1) && (clock >= this.myVSYNCFinishClock)) {
                    // We're no longer interested in this.myVSYNCFinishClock
                    this.myVSYNCFinishClock = 0x7FFFFFFF;
                    
                    // Since we're finished with the frame tell the processor to halt
                    this.mySystem.stopCPU();
                    this.myPartialFrameFlag = false;
                }
                break;
            }
            
            case VBLANK:    // VBLANK (vertical blank set/clear)
            {
                // Is the dump to ground path being set for I0, I1, I2, and I3?
                if (((aByteValue & BIT1) != 0) &&((zPreviousValue & BIT1)==0)) //AUTO DETECT FRAME HEIGHT
                {
                    //TODO : have this done only when in detection mode
                    this.myVBlankOn=this.scanlines();
                    
                    var zHeight=this.myVBlankOn - this.myVBlankOff;
                    if (zHeight < 0) zHeight += this.myVSyncOn;
                    if (zHeight >= FRAME_Y_MIN)
                    {
                        this.myDetectedYStart=this.myVBlankOff;
                        if (this.myDetectedYStart>=this.myVSyncOn) this.myDetectedYStart -= this.myVSyncOn;
                        this.myDetectedYStop=this.myDetectedYStart + zHeight;
												console.log('YStart 대입' + this.myVBlankOff);
                    }
  //                	console.log("Debug : VBLANK ON, value=" + aByteValue + ", scanlines()==" + this.scanlines()); 
                }//end : turned VBlank ON
                else if (((aByteValue & BIT1) == 0) && ((zPreviousValue & BIT1)!=0)) 
                {
                    this.myVBlankOff=this.scanlines();
                    
    //              console.log("Debug : VBLANK OFF, value=" + aByteValue + ", scanlines()==" + this.scanlines()); 
                }//end : turned VBlank OFF
                
                
                if      ((this.bool(zPreviousValue & BIT7)==false) && (bool(this.myTIAPokeRegister[VBLANK] & BIT7)==true))  this.myDumpEnabled=true;            
                else if ((this.bool(zPreviousValue & BIT7)==true)  && (bool(this.myTIAPokeRegister[VBLANK] & BIT7)==false)) {
                    this.myDumpEnabled=false;
                    this.myDumpDisabledCycle = this.mySystem.getCycles();
                }          
                
             
                break;
            }
            
            case WSYNC:    // WSYNC : Wait for leading edge of HBLANK
            {
                // It appears that the 6507 only halts during a read cycle so
                // we test here for follow-on writes which should be ignored as
                // far as halting the processor is concerned.
                //
                // TODO - 08-30-2006: This halting isn't correct since it's
                // still halting on the original write.  The 6507 emulation
                // should be expanded to include a READY line.
                if(this.mySystem.getCPU().lastAccessWasRead()) {
                    // Tell the cpu to waste the necessary amount of time
                    this.waitHorizontalSync();
                }
                break;
            }
            
            case RSYNC:    // Reset horizontal sync counter
            {   //Not really supposed to be poked, except for during the initial memory clearing? - JLA
                 break;
            }
            
            case NUSIZ0:    // Number-size of player-missile 0
            {
                             
                // TODO: Technically the "enable" part, [0], should depend on the current
                // enabled or disabled state.  This mean we probably need a data member
                // to maintain that state (01/21/99).                
                this.setCurrentP0Mask(this.myPOSP0 & 0x03, 0, this.myTIAPokeRegister[NUSIZ0] & 0x07, CLOCKS_PER_LINE_VISIBLE - (this.myPOSP0 & 0xFC));
                this.setCurrentM0Mask(this.myPOSM0 & 0x03, this.myTIAPokeRegister[NUSIZ0] & 0x07, ((this.myTIAPokeRegister[NUSIZ0] & 0x30) >> 4) , CLOCKS_PER_LINE_VISIBLE - (this.myPOSM0 & 0xFC));
                                
                break;
            }
            
            case NUSIZ1:    // Number-size of player-missile 1
            {
               
                
                // TODO: Technically the "enable" part, [0], should depend on the current
                // enabled or disabled state.  This mean we probably need a data member
                // to maintain that state (01/21/99).
                
                this.setCurrentP1Mask(this.myPOSP1 & 0x03, 0, this.myTIAPokeRegister[NUSIZ1] & 0x07, CLOCKS_PER_LINE_VISIBLE - (this.myPOSP1 & 0xFC));                
                this.setCurrentM1Mask(this.myPOSM1 & 0x03, this.myTIAPokeRegister[NUSIZ1] & 0x07, ((this.myTIAPokeRegister[NUSIZ1] & 0x30) >> 4) , CLOCKS_PER_LINE_VISIBLE - (this.myPOSM1 & 0xFC));
                
                break;
            }
            
            case COLUP0:    // Color-Luminance Player 0
            case COLUP1:    // COLUM P1
            case COLUPF:    // COLUM PF
            case COLUBK:    // COLUM BK
            {
                var zColor = Math.floor(aByteValue & 0xfe);
                if(this.myColorLossEnabled && this.bool(this.myScanlineCountForLastFrame & BIT0))  zColor |= BIT0;
                this.myTIAPokeRegister[addr]=zColor;
                break;
            }
            
             
            
            case 0x0A:    // Control Playfield, Ball size, Collisions
            {
                //this.myCTRLPF = aByteValue;
                
                // The playfield priority and score bits from the control register
                // are accessed when the frame is being drawn.  We precompute the
                // necessary aByteValue here so we can save time while drawing.
                this.myPlayfieldPriorityAndScore = ((this.myTIAPokeRegister[CTRLPF] & 0x06) << 5);
                
                // Update the playfield mask based on reflection state if
                // we're still on the left hand side of the playfield
                if(((clock - this.myClockWhenFrameStarted) % CLOCKS_PER_LINE_TOTAL) < (68 + 79)) {
                  //  this.myCurrentPFMask = PLAYFIELD_TABLE[this.myTIAPokeRegister[CTRLPF] & 0x01];
                    //TODO : figure out what this did exactly
                }
                
                this.setCurrentBLMask(this.myPOSBL & 0x03,(this.myTIAPokeRegister[CTRLPF] & 0x30) >> 4,CLOCKS_PER_LINE_VISIBLE - (this.myPOSBL & 0xFC));
                
                
                break;
            }
            
            case REFP0:    // Reflect Player 0
            {
                // See if the reflection state of the player is being changed
                if ((zPreviousValue & BIT3) != (aByteValue & BIT3)) this.myCurrentGRP0 = PLAYER_REFLECT_TABLE[this.myCurrentGRP0];
                break;
            }
            
            case REFP1:    // Reflect Player 1
            {
                // See if the reflection state of the player is being changed
                if((zPreviousValue & BIT3) != (aByteValue & BIT3))  this.myCurrentGRP1 = PLAYER_REFLECT_TABLE[this.myCurrentGRP1];
                
                break;
            }
            
            case PF0 :    // Playfield register byte 0
            {
              
                
                this.updatePlayfieldStatus();
             
                break;
            }
            
            case PF1:    // Playfield register byte 1
            {
              //  this.myPF = (this.myPF & 0x000FF00F) | ((int)aByteValue << 4);
                
                this.updatePlayfieldStatus();
          
                
                break;
            }
            
            case PF2 :    // Playfield register byte 2
            {
               // this.myPF = (this.myPF & 0x00000FFF) | ((int)aByteValue << 12);
                
                this.updatePlayfieldStatus();
              
                
                break;
            }
            
            case RESP0:    // Reset Player 0
            {
                var hpos = (clock - this.myClockWhenFrameStarted) % CLOCKS_PER_LINE_TOTAL;
                var newx = hpos < CLOCKS_PER_LINE_BLANK ? 3 : (((hpos - CLOCKS_PER_LINE_BLANK) + 5) % CLOCKS_PER_LINE_VISIBLE);
                
                // Find out under what condition the player is being reset
                var when = PLAYER_POSITION_RESET_WHEN_TABLE[this.myTIAPokeRegister[NUSIZ0] & 7][this.myPOSP0][newx];
                
                // Player is being reset during the display of one of its copies
                if(when == 1) {
                    // So we go ahead and update the display before moving the player
                    // TODO: The 11 should depend on how much of the player has already
                    // been displayed.  Probably change table to return the amount to
                    // delay by instead of just 1 (01/21/99).
                    this.updateFrame(clock + 11);
                    
                    this.myPOSP0 = newx;
                    
                    // Setup the mask to skip the first copy of the player
                    
                    this.setCurrentP0Mask(this.myPOSP0 & 0x03,1,this.myTIAPokeRegister[NUSIZ0] & 0x07,CLOCKS_PER_LINE_VISIBLE - (this.myPOSP0 & 0xFC));
                }
                // Player is being reset in neither the delay nor display section
                else if(when == 0) {
                    this.myPOSP0 = newx;
                    
                    // So we setup the mask to skip the first copy of the player
                    this.setCurrentP0Mask(this.myPOSP0 & 0x03,1,this.myTIAPokeRegister[NUSIZ0] & 0x07,CLOCKS_PER_LINE_VISIBLE - (this.myPOSP0 & 0xFC));
                    
                }
                // Player is being reset during the delay section of one of its copies
                else if(when == -1) {
                    this.myPOSP0 = newx;
                    
                    // So we setup the mask to display all copies of the player
                    this.setCurrentP0Mask(this.myPOSP0 & 0x03,0,this.myTIAPokeRegister[NUSIZ0] & 0x07,CLOCKS_PER_LINE_VISIBLE - (this.myPOSP0 & 0xFC));
                    
                }
                break;
            }
            
            case RESP1:    // Reset Player 1
            {
                var hpos = (clock - this.myClockWhenFrameStarted) % CLOCKS_PER_LINE_TOTAL;
                var newx = hpos < CLOCKS_PER_LINE_BLANK ? 3 : (((hpos - CLOCKS_PER_LINE_BLANK) + 5) % CLOCKS_PER_LINE_VISIBLE);
                
                // Find out under what condition the player is being reset
                var when = PLAYER_POSITION_RESET_WHEN_TABLE[this.myTIAPokeRegister[NUSIZ1] & 7][this.myPOSP1][newx];
                
                // Player is being reset during the display of one of its copies
                if(when == 1) {
                    // So we go ahead and update the display before moving the player
                    // TODO: The 11 should depend on how much of the player has already
                    // been displayed.  Probably change table to return the amount to
                    // delay by instead of just 1 (01/21/99).
                    this.updateFrame(clock + 11);
                    
                    this.myPOSP1 = newx;
                    
                    // Setup the mask to skip the first copy of the player
                    
                    this.setCurrentP1Mask(this.myPOSP1 & 0x03, 1, this.myTIAPokeRegister[NUSIZ1] & 0x07, CLOCKS_PER_LINE_VISIBLE - (this.myPOSP1 & 0xFC));
                }
                // Player is being reset in neither the delay nor display section
                else if(when == 0) {
                    this.myPOSP1 = newx;
                    
                    // So we setup the mask to skip the first copy of the player
                    this.setCurrentP1Mask(this.myPOSP1 & 0x03, 1, this.myTIAPokeRegister[NUSIZ1] & 0x07, CLOCKS_PER_LINE_VISIBLE - (this.myPOSP1 & 0xFC));
                    
                }
                // Player is being reset during the delay section of one of its copies
                else if(when == -1) {
                    this.myPOSP1 = newx;
                    
                    // So we setup the mask to display all copies of the player
                    this.setCurrentP1Mask(this.myPOSP1 & 0x03, 0, this.myTIAPokeRegister[NUSIZ1] & 0x07, CLOCKS_PER_LINE_VISIBLE - (this.myPOSP1 & 0xFC));
                    
                }
                break;
            }
            
            case RESM0:    // Reset Missile 0
            {
                var hpos = (clock - this.myClockWhenFrameStarted) % CLOCKS_PER_LINE_TOTAL;
                this.myPOSM0 = hpos < CLOCKS_PER_LINE_BLANK ? 2 : (((hpos - CLOCKS_PER_LINE_BLANK) + 4) % CLOCKS_PER_LINE_VISIBLE);
                
                // TODO: Remove the following special hack for Dolphin by
                // figuring out what really happens when Reset Missile
                // occurs 20 cycles after an HMOVE (04/13/02).
                if(((clock - this.myLastHMOVEClock) == (20 * 3)) && (hpos == 69)) {
                    this.myPOSM0 = 8;
                }
                this.setCurrentM0Mask(this.myPOSM0 & 0x03, this.myTIAPokeRegister[NUSIZ0] & 0x07, ((this.myTIAPokeRegister[NUSIZ0] & 0x30) >> 4), CLOCKS_PER_LINE_VISIBLE - (this.myPOSM0 & 0xFC));
                break;
            }
            
            case RESM1:    // Reset Missile 1
            {
                var hpos = (clock - this.myClockWhenFrameStarted) % CLOCKS_PER_LINE_TOTAL;
                this.myPOSM1 = hpos < CLOCKS_PER_LINE_BLANK ? 2 : (((hpos - CLOCKS_PER_LINE_BLANK) + 4) % CLOCKS_PER_LINE_VISIBLE);
                
                // TODO: Remove the following special hack for Pitfall II by
                // figuring out what really happens when Reset Missile
                // occurs 3 cycles after an HMOVE (04/13/02).
                if(((clock - this.myLastHMOVEClock) == (3 * 3)) && (hpos == 18)) {
                    this.myPOSM1 = 3;
                }
                this.setCurrentM1Mask(this.myPOSM1 & 0x03, this.myTIAPokeRegister[NUSIZ1] & 0x07, ((this.myTIAPokeRegister[NUSIZ1] & 0x30) >> 4) , CLOCKS_PER_LINE_VISIBLE - (this.myPOSM1 & 0xFC));
                
                
                break;
            }
            
            case RESBL:    // Reset Ball
            {
                var hpos = (clock - this.myClockWhenFrameStarted) % CLOCKS_PER_LINE_TOTAL ;
                this.myPOSBL = hpos < CLOCKS_PER_LINE_BLANK ? 2 : (((hpos - CLOCKS_PER_LINE_BLANK) + 4) % CLOCKS_PER_LINE_VISIBLE);
                
                // TODO: Remove the following special hack for Escape from the
                // Mindmaster by figuring out what really happens when Reset Ball
                // occurs 18 cycles after an HMOVE (01/09/99).
                if(((clock - this.myLastHMOVEClock) == (18 * 3)) &&
                        ((hpos == 60) || (hpos == 69))) {
                    this.myPOSBL = 10;
                }
                // TODO: Remove the following special hack for Decathlon by
                // figuring out what really happens when Reset Ball
                // occurs 3 cycles after an HMOVE (04/13/02).
                else if(((clock - this.myLastHMOVEClock) == (3 * 3)) && (hpos == 18)) {
                    this.myPOSBL = 3;
                }
                // TODO: Remove the following special hack for Robot Tank by
                // figuring out what really happens when Reset Ball
                // occurs 7 cycles after an HMOVE (04/13/02).
                else if(((clock - this.myLastHMOVEClock) == (7 * 3)) && (hpos == 30)) {
                    this.myPOSBL = 6;
                }
                // TODO: Remove the following special hack for Hole Hunter by
                // figuring out what really happens when Reset Ball
                // occurs 6 cycles after an HMOVE (04/13/02).
                else if(((clock - this.myLastHMOVEClock) == (6 * 3)) && (hpos == 27)) {
                    this.myPOSBL = 5;
                }
                this.setCurrentBLMask(this.myPOSBL & 0x03,(this.myTIAPokeRegister[CTRLPF] & 0x30) >> 4, CLOCKS_PER_LINE_VISIBLE - (this.myPOSBL & 0xFC));
                
                break;
            }
            
            // AUDIO REGISTER POKE
            case AUDC0:    // Audio control 0
            case AUDC1:    // Audio control 1
            case AUDF0:    // Audio frequency 0
            case AUDF1:    // Audio frequency 1
            case AUDV0:    // Audio volume 0
            case AUDV1:    // Audio volume 1
//                this.getAudio().pokeAudioRegister(addr, aByteValue, this.mySystem.getCycles()); //outsource to JSAudio
                break;
                
                
            case GRP0: //0x1B:    // Graphics Player 0
            {
                // Set player 0 graphics
               // this.myGRP0 = aByteValue; //(this.myBitEnabled[TIABitP0] ? aByteValue : 0);
                
                // Copy player 1 graphics into its delayed register
                this.myDGRP1 = this.myTIAPokeRegister[GRP1];
                
                // Get the "current" data for GRP0 base on delay register and reflect
                var grp0 = this.bool(this.myTIAPokeRegister[VDELP0] & BIT0) ? this.myDGRP0 : this.myTIAPokeRegister[GRP0];
                this.myCurrentGRP0 = this.bool(this.myTIAPokeRegister[REFP0] & BIT3) ? PLAYER_REFLECT_TABLE[grp0] : grp0;
                
                // Get the "current" data for GRP1 base on delay register and reflect
                var grp1 = this.bool(this.myTIAPokeRegister[VDELP1] & BIT0) ? this.myDGRP1 : this.myTIAPokeRegister[GRP1];
                this.myCurrentGRP1 = this.bool(this.myTIAPokeRegister[REFP1] & BIT3) ? PLAYER_REFLECT_TABLE[grp1] : grp1;
                
                // Set enabled object bits
                if(this.myCurrentGRP0 != 0)
                    this.myEnabledObjects |= BIT_P0;
                else
                    this.myEnabledObjects &= ~BIT_P0;
                
                if(this.myCurrentGRP1 != 0)
                    this.myEnabledObjects |= BIT_P1;
                else
                    this.myEnabledObjects &= ~BIT_P1;
                
                break;
            }
            
            case GRP1: //0x1C:    // Graphics Player 1
            {
                // Set player 1 graphics
               // this.myGRP1 = aByteValue; //(this.myBitEnabled[TIABitP1] ? aByteValue : 0);
                
                // Copy player 0 graphics into its delayed register
                this.myDGRP0 = this.myTIAPokeRegister[GRP0];
                
                // Copy ball graphics into its delayed register
                this.myDENABL = this.bool(this.myTIAPokeRegister[ENABL] & BIT1);
                
                // Get the "current" data for GRP0 base on delay register
                var grp0 = this.bool(this.myTIAPokeRegister[VDELP0] & BIT0) ? this.myDGRP0 : this.myTIAPokeRegister[GRP0];
                this.myCurrentGRP0 = this.bool(this.myTIAPokeRegister[REFP0] & BIT3) ? PLAYER_REFLECT_TABLE[grp0] : grp0;
                
                // Get the "current" data for GRP1 base on delay register
                var grp1 = this.bool(this.myTIAPokeRegister[VDELP1] & BIT0) ? this.myDGRP1 : this.myTIAPokeRegister[GRP1];
                this.myCurrentGRP1 = this.bool(this.myTIAPokeRegister[REFP1] & BIT3) ? PLAYER_REFLECT_TABLE[grp1] : grp1;
                
                // Set enabled object bits
                if(this.myCurrentGRP0 != 0)
                    this.myEnabledObjects |= BIT_P0;
                else
                    this.myEnabledObjects &= ~BIT_P0;
                
                if(this.myCurrentGRP1 != 0)
                    this.myEnabledObjects |= BIT_P1;
                else
                    this.myEnabledObjects &= ~BIT_P1;
                
                if(this.bool(this.myTIAPokeRegister[VDELBL] & BIT0) ? this.myDENABL : this.bool(this.myTIAPokeRegister[ENABL] & BIT1))
                    this.myEnabledObjects |= BIT_BL;
                else
                    this.myEnabledObjects &= ~BIT_BL;
                
                break;
            }
            
            case ENAM0:    // Enable Missile 0 graphics
            {
               // this.myENAM0 = bool(this.myBitEnabled[TIABitM0] ? aByteValue & 0x02 : 0);
             //   if (this.myBitEnabled[TIABitM0] == false) this.myTIAPokeRegister[ENAM0]=0;
                if(this.bool(this.myTIAPokeRegister[ENAM0] & BIT1) && !this.isRESMP0())
                    this.myEnabledObjects |= BIT_M0;
                else
                    this.myEnabledObjects &= ~BIT_M0;
                break;
            }
            
            case ENAM1:    // Enable Missile 1 graphics
            {
                //this.myENAM1 = bool(this.myBitEnabled[TIABitM1] ? aByteValue & 0x02 : 0);
               //  if (this.myBitEnabled[TIABitM1] == false) this.myTIAPokeRegister[ENAM1]=0;
                if(this.bool(this.myTIAPokeRegister[ENAM1] & BIT1) && !this.isRESMP1())
                    this.myEnabledObjects |= BIT_M1;
                else
                    this.myEnabledObjects &= ~BIT_M1;
                break;
            }
            
            case ENABL:    // Enable Ball graphics
            {
              //  this.myENABL = bool(this.myBitEnabled[TIABitBL] ? aByteValue & 0x02 : 0);
               //    if (this.myBitEnabled[TIABitBL] == false) this.myTIAPokeRegister[ENABL]=0;
                if(this.bool(this.myTIAPokeRegister[VDELBL] & BIT0) ? this.myDENABL : this.bool(this.myTIAPokeRegister[ENABL] & BIT1))
                    this.myEnabledObjects |= BIT_BL;
                else
                    this.myEnabledObjects &= ~BIT_BL;
                
                break;
            }
            
            case HMP0:    // Horizontal Motion Player 0
            {
                //  int zSignedVal=com.mauvila.mvunsigned.MvUnsignedUtil.toSignedByteValue(aByteValue)
               // this.myHMP0 = aByteValue >> 4;
                break;
            }
            
            case HMP1:    // Horizontal Motion Player 1
            {
               // this.myHMP1 = aByteValue >> 4;
                break;
            }
            
            case HMM0:    // Horizontal Motion Missile 0
            {
                var tmp = aByteValue >> 4;
                
                // Should we enabled TIA M0 "bug" used for stars in Cosmic Ark?
                if((clock == (this.myLastHMOVEClock + 21 * 3)) && ((zPreviousValue >> 4)== 7) && (tmp == 6)) {
                    this.myM0CosmicArkMotionEnabled = true;
                    this.myM0CosmicArkCounter = 0;
                }
                
               // this.myHMM0 = tmp;
                break;
            }
            
            case HMM1:    // Horizontal Motion Missile 1
            {
               // this.myHMM1 = aByteValue >> 4;
                break;
            }
            
            case HMBL:    // Horizontal Motion Ball
            {
              //  this.myHMBL = aByteValue >> 4;
                break;
            }
            
            case VDELP0:    // Vertial Delay Player 0
            {
                //this.myVDELP0 = bool(aByteValue & 0x01);
                
                var grp0 = this.bool(this.myTIAPokeRegister[VDELP0] & BIT0) ? this.myDGRP0 : this.myTIAPokeRegister[GRP0];
                this.myCurrentGRP0 = this.bool(this.myTIAPokeRegister[REFP0] & BIT3) ? PLAYER_REFLECT_TABLE[grp0] : grp0;
                
                if(this.myCurrentGRP0 != 0)
                    this.myEnabledObjects |= BIT_P0;
                else
                    this.myEnabledObjects &= ~BIT_P0;
                break;
            }
            
            case VDELP1:    // Vertial Delay Player 1
            {
               // this.myVDELP1 = bool(aByteValue & 0x01);
                var grp1 = this.bool(this.myTIAPokeRegister[VDELP1] & BIT0) ? this.myDGRP1 : this.myTIAPokeRegister[GRP1];
                this.myCurrentGRP1 = this.bool(this.myTIAPokeRegister[REFP1] & BIT3) ? PLAYER_REFLECT_TABLE[grp1] : grp1;
                if(this.myCurrentGRP1 != 0) this.myEnabledObjects |= BIT_P1;
                else this.myEnabledObjects &= ~BIT_P1;
                break;
            }
            
            case VDELBL:    // Vertial Delay Ball
            {
              //  this.myVDELBL = bool(aByteValue & 0x01);
                
                if(this.bool(this.myTIAPokeRegister[VDELBL] & BIT0) ? this.myDENABL : this.bool(this.myTIAPokeRegister[ENABL] & BIT1))
                    this.myEnabledObjects |= BIT_BL;
                else
                    this.myEnabledObjects &= ~BIT_BL;
                break;
            }
            
            case RESMP0 :    // Reset missile 0 to player 0
            {
                if(((zPreviousValue & BIT1)!=0) && !this.bool(aByteValue & 0x02)) {
                    var middle;
                    
                    if((this.myTIAPokeRegister[NUSIZ0] & 0x07) == 0x05)
                        middle = 8;
                    else if((this.myTIAPokeRegister[NUSIZ0] & 0x07) == 0x07)
                        middle = 16;
                    else
                        middle = 4;
                    
                    this.myPOSM0 = (this.myPOSP0 + middle) % CLOCKS_PER_LINE_VISIBLE;
                    this.setCurrentM0Mask(this.myPOSM0 & 0x03, this.myTIAPokeRegister[NUSIZ0] & 0x07, ((this.myTIAPokeRegister[NUSIZ0] & 0x30) >> 4), CLOCKS_PER_LINE_VISIBLE - (this.myPOSM0 & 0xFC));
                    
                    
                }
                
                //this.myRESMP0 = bool(aByteValue & 0x02);
                
                if(this.bool(this.myTIAPokeRegister[ENAM0] & BIT1) && !this.isRESMP0())
                    this.myEnabledObjects |= BIT_M0;
                else
                    this.myEnabledObjects &= ~BIT_M0;
                
                break;
            }
            
            case RESMP1:    // Reset missile 1 to player 1
            {
                if(((zPreviousValue & BIT1)!=0) && !this.bool(aByteValue & 0x02)) {
                    var middle;
                    
                    if((this.myTIAPokeRegister[NUSIZ1] & 0x07) == 0x05)
                        middle = 8;
                    else if((this.myTIAPokeRegister[NUSIZ1] & 0x07) == 0x07)
                        middle = 16;
                    else
                        middle = 4;
                    
                    this.myPOSM1 = (this.myPOSP1 + middle) % CLOCKS_PER_LINE_VISIBLE;
                    
                    this.setCurrentM1Mask(this.myPOSM1 & 0x03, this.myTIAPokeRegister[NUSIZ1] & 0x07, ((this.myTIAPokeRegister[NUSIZ1] & 0x30) >> 4) , CLOCKS_PER_LINE_VISIBLE - (this.myPOSM1 & 0xFC));
                    
                }
                
                //this.myRESMP1 = bool(aByteValue & 0x02);
                
                if(this.bool(this.myTIAPokeRegister[ENAM1] & BIT1) && !this.isRESMP1())
                    this.myEnabledObjects |= BIT_M1;
                else
                    this.myEnabledObjects &= ~BIT_M1;
                break;
            }
            
            case HMOVE: //0x2A:    // Apply horizontal motion HMOVE
            {
                // Figure out what cycle we're at
                var x = ((clock - this.myClockWhenFrameStarted) % CLOCKS_PER_LINE_TOTAL) / 3;
                
                // See if we need to enable the HMOVE blank bug
                if(this.myAllowHMOVEBlanks && HMOVE_BLANK_ENABLE_CYCLES[x]) {
                    // TODO: Allow this to be turned off using properties...
                    this.myHMOVEBlankEnabled = true;
                }
                
                this.myPOSP0 += COMPLETE_MOTION_TABLE[x][this.myTIAPokeRegister[HMP0]  >> 4];
                this.myPOSP1 += COMPLETE_MOTION_TABLE[x][this.myTIAPokeRegister[HMP1] >> 4];
                this.myPOSM0 += COMPLETE_MOTION_TABLE[x][this.myTIAPokeRegister[HMM0] >> 4];
                this.myPOSM1 += COMPLETE_MOTION_TABLE[x][this.myTIAPokeRegister[HMM1] >> 4];
                this.myPOSBL += COMPLETE_MOTION_TABLE[x][this.myTIAPokeRegister[HMBL] >> 4];
                
                if(this.myPOSP0 >= CLOCKS_PER_LINE_VISIBLE)
                    this.myPOSP0 -= CLOCKS_PER_LINE_VISIBLE;
                else if(this.myPOSP0 < 0)
                    this.myPOSP0 += CLOCKS_PER_LINE_VISIBLE;
                
                if(this.myPOSP1 >= CLOCKS_PER_LINE_VISIBLE)
                    this.myPOSP1 -= CLOCKS_PER_LINE_VISIBLE;
                else if(this.myPOSP1 < 0)
                    this.myPOSP1 += CLOCKS_PER_LINE_VISIBLE;
                
                if(this.myPOSM0 >= CLOCKS_PER_LINE_VISIBLE)
                    this.myPOSM0 -= CLOCKS_PER_LINE_VISIBLE;
                else if(this.myPOSM0 < 0)
                    this.myPOSM0 += CLOCKS_PER_LINE_VISIBLE;
                
                if(this.myPOSM1 >= CLOCKS_PER_LINE_VISIBLE)
                    this.myPOSM1 -= CLOCKS_PER_LINE_VISIBLE;
                else if(this.myPOSM1 < 0)
                    this.myPOSM1 += CLOCKS_PER_LINE_VISIBLE;
                
                if(this.myPOSBL >= CLOCKS_PER_LINE_VISIBLE)
                    this.myPOSBL -= CLOCKS_PER_LINE_VISIBLE;
                else if(this.myPOSBL < 0)
                    this.myPOSBL += CLOCKS_PER_LINE_VISIBLE;
                this.setCurrentBLMask(this.myPOSBL & 0x03,(this.myTIAPokeRegister[CTRLPF] & 0x30) >> 4,CLOCKS_PER_LINE_VISIBLE - (this.myPOSBL & 0xFC));
                
                this.setCurrentP0Mask(this.myPOSP0 & 0x03,0,this.myTIAPokeRegister[NUSIZ0] & 0x07,CLOCKS_PER_LINE_VISIBLE - (this.myPOSP0 & 0xFC));
                
                this.setCurrentP1Mask(this.myPOSP1 & 0x03, 0, this.myTIAPokeRegister[NUSIZ1] & 0x07, CLOCKS_PER_LINE_VISIBLE - (this.myPOSP1 & 0xFC));
                
                
                this.setCurrentM0Mask(this.myPOSM0 & 0x03, this.myTIAPokeRegister[NUSIZ0] & 0x07, ((this.myTIAPokeRegister[NUSIZ0] & 0x30) >> 4) /*| 0x01*/, CLOCKS_PER_LINE_VISIBLE - (this.myPOSM0 & 0xFC));
                this.setCurrentM1Mask(this.myPOSM1 & 0x03, this.myTIAPokeRegister[NUSIZ1] & 0x07, ((this.myTIAPokeRegister[NUSIZ1] & 0x30) >> 4) , CLOCKS_PER_LINE_VISIBLE - (this.myPOSM1 & 0xFC));
                
                
                
                // Remember what clock HMOVE occured at
                this.myLastHMOVEClock = clock;
                
                // Disable TIA M0 "bug" used for stars in Cosmic ark
                this.myM0CosmicArkMotionEnabled = false;
                break;
            }
            
            case HMCLR: //0x2b:    // Clear horizontal motion registers
            {
                this.myTIAPokeRegister[HMP0]  = 0;
                this.myTIAPokeRegister[HMP1] = 0;
                this.myTIAPokeRegister[HMM0] = 0;
                this.myTIAPokeRegister[HMM1] = 0;
                this.myTIAPokeRegister[HMBL] = 0;
                break;
            }
            
            case CXCLR: //0x2c:    // Clear collision latches
            {
                this.myCollision = 0;
                break;
            }
            
            default:
            {
                
                break;
            }
        }//end : switch (address)
      }//end : addr is a pokable TIA register
        // }//end : if reg is not locked
        
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    
    
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    
//
    //TODO : fix bug with "electrophoresis ladder" looking thing on left side of screen
    //             -maybe a TIA bug, or maybe a CPU bug
    
    
    
    
    
    
    
    
    //------- DEBUG START ------------
    
    
    this.debugRenderTypes= []; // boolean 256
    
    this.debugStraightPoke=false;
    this.debugLockP0Mask=false;
    this.debugLockP1Mask=false;
    
    
    
    this.debugRegLocked= []; // boolean 0x2c
    
    
    this.debugResetRenderTypes = function () {this.debugRenderTypes= [];}
    this.debugGetRenderTypes = function() {return debugRenderTypes;}
    this.setDebugLockRegister = function(aItem, aValue) {this.debugRegLocked[aItem]=aValue;}
    this.getDebugLockRegister = function(aItem) {return this.debugRegLocked[aItem];}
    this.debugUnlockAllRegisters = function() {
        this.debugRegLocked=[];
        this.debugLockP0Mask=false;
        this.debugLockP1Mask=false;
    }
    this.debugGetNUSIZ0 = function() {return this.myTIAPokeRegister[NUSIZ0];}
    this.debugGetNUSIZ1 = function() {return this.myTIAPokeRegister[NUSIZ1];}
    
    this.debugSetP0Mask = function(aA,aB,aC,aD) {
        this.setCurrentP0Mask(aA, aB, aC, aD);
        this.debugLockP0Mask=true;
    }
    
    this.debugSetP1Mask = function(aA, aB,  aC, aD) {
        this.setCurrentP1Mask(aA, aB, aC, aD);
        this.debugLockP1Mask=true;
    }
    
    this.debugDumpRegs = function() {
    /*
        var zSB=new StringBuffer();
        zSB.append("ENAM0=" + bool(this.myTIAPokeRegister[ENAM0] & BIT1) + "; NUSIZ0=" + dbgHex(this.myTIAPokeRegister[NUSIZ0]) + "; ENAM1=" + bool(this.myTIAPokeRegister[ENAM1] & BIT1) + "; NUSIZ1=" + dbgHex(this.myTIAPokeRegister[NUSIZ1]) + "\n");
        // zSB.append("ENAM0=" + bool(this.myTIAPokeRegister[ENAM0] & BIT1) + "\n");
        zSB.append("CurrentM0Mask : alignment=" + this.myCurrentM0Mask[0] + ", num=" + this.myCurrentM0Mask[1] + ", size=" + this.myCurrentM0Mask[2] + ", x=" + this.myCurrentM0Mask[3] + "\n");
        zSB.append("CurrentM1Mask : alignment=" + this.myCurrentM1Mask[0] + ", num=" + this.myCurrentM1Mask[1] + ", size=" + this.myCurrentM1Mask[2] + ", x=" + this.myCurrentM1Mask[3] + "\n");
        zSB.append("CurrentP0Mask : alignment=" + this.myCurrentP0Mask[0] + ", num=" + this.myCurrentP0Mask[1] + ", size=" + this.myCurrentP0Mask[2] + ", x=" + this.myCurrentP0Mask[3] + "\n");
        zSB.append("CurrentP1Mask : alignment=" + this.myCurrentP1Mask[0] + ", num=" + this.myCurrentP1Mask[1] + ", size=" + this.myCurrentP1Mask[2] + ", x=" + this.myCurrentP1Mask[3] + "\n");
        
        zSB.append("M0Pos=" + this.myPOSM0 + "; M1Pos=" + this.myPOSM1 + "\n");
        zSB.append("P0Pos=" + this.myPOSP0 + "; P1Pos=" + this.myPOSP1 + "\n");
        zSB.append("COLUBK=0x" + Integer.toHexString(this.myTIAPokeRegister[COLUBK]) + "\n");
        return zSB.toString();
    */
    }
    this.debugPoke = function(aAddr, aValue) {
        this.debugStraightPoke=true;
        this.poke(aAddr, aValue);
        this.debugStraightPoke=false;}
    
    this.dbgHex = function(aNum) {
        return "0x"+ Num.toString(16);
    }
    
    //^^^^^^^^^^ DEBUG STOP ^^^^^^^^^^^^^^^^^^^^
    
    
    
    
    
    
    
    
    
    
    
    
}




function JSRiot(console) {
  
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * Resets the RIOT chip
     */

  this.name = function() {
    return "6532";
  }

  this.reset = function() {
    this.myTimer = 25 + Math.floor(Math.random()*75);
    this.myIntervalShift = 6;
    this.myCyclesWhenTimerSet = 0;
    this.myCyclesWhenInterruptReset = 0;
    this.myTimerReadAfterInterrupt = false;

    this.myDDRA = 0x00;
    this.myDDRB = 0x00;
  }

   
    this.systemCyclesReset = function() {
        // JSSystem cycles are being reset to zero so we need to adjust
        // the cycle count we remembered when the timer was last set
        this.myCyclesWhenTimerSet -= this.mySystem.getCycles(); // TODO : MYSYSTEM
        this.myCyclesWhenInterruptReset -= this.mySystem.getCycles();
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.install = function(system) {
        // Remember which system I'm installed in
        this.mySystem = system;
        
        var shift = PAGE_SHIFT;
        var mask = PAGE_MASK;
        
        assert((0x1080 & mask) == 0);
        // We're installing in a 2600 system
        for(var address = 0; address < 8192; address += (1 << shift)) {
            if((address & 0x1080) == 0x0080) {
                if((address & 0x0200) == 0x0000) {
                    var access= new PageAccess(this); //TODO
                    access.setDirectPeekMemory(this.myRAM, address & 0x007f);
                    access.setDirectPokeMemory(this.myRAM, address & 0x007f);
                    
                    this.mySystem.setPageAccess((address >> shift), access);
                } else {
                    var access= new PageAccess(this);
                    access.setIndirectMode();//Bases(0,0);//directPeekBase = 0;
                    
                    this.mySystem.setPageAccess((address >> shift), access);
                }
            }
        }
    }
    
    
    /**
     * Returns the hex string equivalent.
     * Because I'm lazy
     */
    this.toHexStr = function(addr) {
        return "0x" + addr.toString(16);
    }

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.peek = function(addr) {
        var zReturn=0;
      
        switch(addr & 0x07) {
            
            case 0x00:    // Port A I/O Register (Joystick)
            {
           
                var value = 0x00;
                
                if(this.myConsole.getController(Jack.LEFT).read(DigitalPin.One))      value |= 0x10;
                if(this.myConsole.getController(Jack.LEFT).read(DigitalPin.Two))      value |= 0x20;
                if(this.myConsole.getController(Jack.LEFT).read(DigitalPin.Three))    value |= 0x40;
                if(this.myConsole.getController(Jack.LEFT).read(DigitalPin.Four))     value |= 0x80;                
                if(this.myConsole.getController(Jack.RIGHT).read(DigitalPin.One))     value |= 0x01;
                if(this.myConsole.getController(Jack.RIGHT).read(DigitalPin.Two))     value |= 0x02;
                if(this.myConsole.getController(Jack.RIGHT).read(DigitalPin.Three))   value |= 0x04;
                if(this.myConsole.getController(Jack.RIGHT).read(DigitalPin.Four))    value |= 0x08;                
                zReturn=value; break;
            }
            
            case 0x01:    // Port A Data Direction Register
            {
                zReturn=this.myDDRA; break;
            }
            
            case 0x02:    // Port B I/O Register (JSConsole switches)
            {
               
                zReturn=this.myConsole.readSwitches(); break;
            }
            
            case 0x03:    // Port B Data Direction Register
            {
                zReturn=this.myDDRB; break;
            }
            
            case 0x04:    // Timer Output
            case 0x06:
            {
               
                var zCurrentCycle = this.mySystem.getCycles() - 1;
                var zCyclesElapsed = zCurrentCycle - this.myCyclesWhenTimerSet;
                var zCurrentIntervalCount = this.myTimer - (zCyclesElapsed >> this.myIntervalShift) - 1;
                
                // See if the zCurrentIntervalCount has expired yet?
                if(zCurrentIntervalCount >= 0) {
                    zReturn=zCurrentIntervalCount;  break;
                } else {
                    zCurrentIntervalCount = (this.myTimer << this.myIntervalShift) - zCyclesElapsed - 1;
                    
                    if((zCurrentIntervalCount <= -2) && !this.myTimerReadAfterInterrupt) {
                        // Indicate that zCurrentIntervalCount has been read after interrupt occured
                        this.myTimerReadAfterInterrupt = true;
                        this.myCyclesWhenInterruptReset = this.mySystem.getCycles();
                    }
                    
                    if(this.myTimerReadAfterInterrupt) {
                        var zOffset = this.myCyclesWhenInterruptReset -  (this.myCyclesWhenTimerSet + (this.myTimer << this.myIntervalShift));
                        
                        zCurrentIntervalCount = this.myTimer - (zCyclesElapsed >> this.myIntervalShift) - zOffset;
                    }
                    
                    zReturn=zCurrentIntervalCount & 0xff; break;
                }
            }
            
            case 0x05:    // Interrupt Flag
            case 0x07:
            {
               
                var cycles = this.mySystem.getCycles() - 1;
                var delta = cycles - this.myCyclesWhenTimerSet;
                var timer = this.myTimer - (delta >> this.myIntervalShift) - 1;
                
                if((timer >= 0) || this.myTimerReadAfterInterrupt)
                    zReturn=0x00;
                else zReturn=0x80;
                break;
            }
            
            default:
            {
             
                zReturn=0; break;
            }
        }
        assert((zReturn>=0)&&(zReturn<0x100));
        return zReturn;
    }
    
    this.bool = function(aValue) {
        return (aValue!=0);
    }
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    this.poke = function(addr, value) {
        
        if((addr & 0x07) == 0x00)         // Port A I/O Register (Joystick)
        {
            var a = value & this.myDDRA;
            
            this.myConsole.getController(Jack.LEFT).write(DigitalPin.One, this.bool(a & 0x10));
            this.myConsole.getController(Jack.LEFT).write(DigitalPin.Two, this.bool(a & 0x20));
            this.myConsole.getController(Jack.LEFT).write(DigitalPin.Three, this.bool(a & 0x40));
            this.myConsole.getController(Jack.LEFT).write(DigitalPin.Four, this.bool(a & 0x80));
            
            this.myConsole.getController(Jack.RIGHT).write(DigitalPin.One, this.bool(a & 0x01));
            this.myConsole.getController(Jack.RIGHT).write(DigitalPin.Two, this.bool(a & 0x02));
            this.myConsole.getController(Jack.RIGHT).write(DigitalPin.Three, this.bool(a & 0x04));
            this.myConsole.getController(Jack.RIGHT).write(DigitalPin.Four, this.bool(a & 0x08));
        } else if((addr & 0x07) == 0x01)    // Port A Data Direction Register
        {
            this.myDDRA = value;
            
            
        } else if((addr & 0x07) == 0x02)    // Port B I/O Register (JSConsole switches)
        {
            return;
        } else if((addr & 0x07) == 0x03)    // Port B Data Direction Register
        {
//        myDDRB = value;
            return;
        } else if((addr & 0x17) == 0x14)    // TIM1T - Write timer divide by 1
        {
            this.myTimer = value;
            this.myIntervalShift = 0;
            this.myCyclesWhenTimerSet = this.mySystem.getCycles();
            this.myTimerReadAfterInterrupt = false;
        } else if((addr & 0x17) == 0x15)    // TIM8T - Write timer divide by 8
        {
            this.myTimer = value;
            this.myIntervalShift = 3;
            this.myCyclesWhenTimerSet = this.mySystem.getCycles();
            this.myTimerReadAfterInterrupt = false;
        } else if((addr & 0x17) == 0x16)    // TIM64T - Write timer divide by 64
        {
            this.myTimer = value;
            this.myIntervalShift = 6;
            this.myCyclesWhenTimerSet = this.mySystem.getCycles();
            this.myTimerReadAfterInterrupt = false;
        } else if((addr & 0x17) == 0x17)    // TIM1024T - Write timer divide by 1024
        {
            this.myTimer = value;
            this.myIntervalShift = 10;
            this.myCyclesWhenTimerSet = this.mySystem.getCycles();
            this.myTimerReadAfterInterrupt = false;
        } else if((addr & 0x14) == 0x04)    // Write Edge Detect Control
        {
            
        } else {
            
        }
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  this.serialVersionID = 7428490123154878165;
  this.mvRandom = Math.random();

  this.myConsole = null;
  this.mySystem = null;
  this.myRAM = [];
  for (var i=0;i<128;i++) {
    this.myRAM[i] = 0;//Math.floor(Math.random()*255);
  }
  this.myTimer = 0;
  this.myIntervalShift = 0;
  this.myCyclesWhenTimerSet = 0;
  this.myCyclesWhenInterruptReset = 0;
  this.myTimerReadAfterInterrupt = false;

  this.myDDRA = 0;
  this.myDDRB = 0;

  // Constructor
  this.myConsole = console;
  this.reset();

    
}


//============================================================================
//
// MM     MM  6666  555555  0000   2222
// MMMM MMMM 66  66 55     00  00 22  22
// MM MMM MM 66     55     00  00     22
// MM  M  MM 66666  55555  00  00  22222  --  "A 6502 Microprocessor Emulator"
// MM     MM 66  66     55 00  00 22
// MM     MM 66  66 55  55 00  00 22
// MM     MM  6666   5555   0000  222222
//
// Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: NullDevice.java,v 1.3 2007/08/18 09:10:37 mauvila Exp $
//============================================================================

/**
 * Class that represents a "null" device.  The basic idea is that a
 * null device is installed in a 6502 based system anywhere there are
 * holes in the address space (i.e. no real device attached).
 *
 * @author  Bradford W. Mott
 * @version $Id: NullDevice.java,v 1.3 2007/08/18 09:10:37 mauvila Exp $
 */
function NullDevice ()
{    
		this.serialVersionUID = 2224011782042263586;
    this.name = function(){  return "NULL";}
    this.reset = function(){}
    this.install= function(system){}
    this.peek = function(address){ 
        console.log("DEBUG:ERROR - peek at null device address : " + address);   
   /*     assert(false);*/  return 0; }
    this.poke = function(address, aByteValue){ console.log("ERRRR in nUlldevice"); /* throw and error message*/}
    this.save = function(out){ return true;}
    this.load = function(tt){ return true;}
    this.systemCyclesReset = function() { }
    
    
}


function PageAccess(aDevice) {
  this.serialVersionUID = -6487146100140974640;
  this.myDirectPeekBaseIndex = 0;
  this.myDirectPokeBaseIndex = 0;
  this.myDirectPeekMemory = null;
  this.myDirectPokeMemory = null;
  this.myDevice = null;

  this.writeObject = function (out) {
    out.defaultWriteObject();
  }
  this.readObject = function (inn) {
    inn.defaultReadObject();
  }
  this.createDirectPeekAccess = function (aDevice, aDirectPeekMemory, aDirectPeekBaseIndex) {
    var zReturn = new PageAccess(aDevice);
    zReturn.setDirectPeekMemory(aDirectPeekMemory, aDirectPeekBaseIndex);
    return zReturn;
  }
  this.createDirectPokeAccess = function (aDevice, aDirectPokeMemory, aDirectPokeBaseIndex) {
    var zReturn = new PageAccess(aDevice);
    zReturn.setDirectPokeMemory(aDirectPokeMemory, aDirectPokeBaseIndex);
    return zReturn;
  }
  this.createIndirectAccess = function (aDevice) {
    var zReturn = new PageAccess(aDevice);
    zReturn.setIndirectMode();
    return zReturn;
  }
  this.copyDataFrom = function (aPA) {
    this.myDevice = aPA.myDevice;
    this.myDirectPeekMemory = aPA.myDirectPeekMemory;
    this.myDirectPokeMemory = aPA.myDirectPokeMemory;
    this.myDirectPeekBaseIndex = aPA.myDirectPeekBaseIndex;
    this.myDirectPokeBaseIndex = aPA.myDirectPokeBaseIndex;
  }
  this.usesDirectPeek = function () {
    return (this.myDirectPeekMemory != null);
  }
  this.usesDirectPoke = function() {
    return (this.myDirectPokeMemory != null);
  }
  this.directPoke = function(aPageOffset, aByteValue) {
    this.myDirectPokeMemory[this.myDirectPokeBaseIndex + aPageOffset] = aByteValue;
  }
  this.directPeek = function (aPageOffset) {
    var zReturn = 0;
    zReturn = this.myDirectPeekMemory[this.myDirectPeekBaseIndex + aPageOffset];
    return zReturn;
  }
  this.setDevice = function (aDevice){
    this.myDevice = aDevice;
  }
  this.getDevice = function () {
    return this.myDevice;
  }

  this.pagePoke = function(aAddress, aValue) {
    this.directPoke(aAddress, aValue);
  }
  this.pagePeek = function(aAddress) {
    return this.directPoke(aAddress);
  }
  this.peek = function(aAddress) {
    if (this.usesDirectPeek() == true) return this.directPeek(aAddress & PAGE_MASK);
    else return this.getDevice().peek(aAddress);
  }
  this.poke = function (aAddress, aByteValue) {
    if (this.usesDirectPoke() == true) return this.directPoke((aAddress & PAGE_MAGE), aByteValue);
    else this.getDevice().poke(aAddress, aByteValue);
  }
  this.setIndirectMode = function () {
    this.setDirectPeekMemory(null, 0);
    this.setDirectPokeMemory(null, 0);
  }
  this.getDirectPeekMemory = function () {
    return this.myDirectPeekMemory;
  }

  this.setDirectPeekMemory = function (aDirectPeekMemory, aDirectPeekBaseIndex) {
    this.myDirectPeekMemory = aDirectPeekMemory;
    this.myDirectPeekBaseIndex = aDirectPeekBaseIndex;
  }
  this.getDirectPokeMemory = function () {
    return this.myDirectPokeMemory;
  }
  this.setDirectPokeMemory = function (aDirectPokeMemory, aDirectPokeBaseIndex) {
    this.myDirectPockMemory = aDirectPokeMemory;
    this.myDirectPokeBaseIndex = aDirectPokeBaseIndex;
  }

   this.setDevice(aDevice);
}

//============================================================================
//
// MM     MM  6666  555555  0000   2222
// MMMM MMMM 66  66 55     00  00 22  22
// MM MMM MM 66     55     00  00     22
// MM  M  MM 66666  55555  00  00  22222  --  "A 6502 Microprocessor Emulator"
// MM     MM 66  66     55 00  00 22
// MM     MM 66  66 55  55 00  00 22
// MM     MM  6666   5555   0000  222222
//
// Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: JSSystem.java,v 1.8 2007/09/08 05:47:50 mauvila Exp $
//============================================================================

/**
 * This class is the intermediary between the CPU (J6507) and the rest of the
 * emulator - it is the "CPU's secretary".  Unlike the J6507 class, this class is specifically tailored for
 * the JStella system.
 * <p> 
 * This class implements the IfcSystem interface in the J6507 package, which enables
 * a J6507 object (the CPU) to interact with it.  Each instruction cycle goes roughly like
 * this: <br>
 * The CPU, when it is executed, will ask the JSSystem object for the next instruction.  The
 * JSSystem will forward that request to the ROM (game).  So the ROM returns the instruction,
 * and based on what that instruction was, the CPU may do various things...if that instruction
 * was to change the sound a note, the CPU sends the JSSystem a poke() (a write command)...
 * the JSSystem matches the given address up and sees that the TIA is the intended target, and thus
 * forwards it to that object.  Or if the instruction was to see if the joystick is pointing left,
 * the CPU sends a peek() (a read command) to the JSSystem, which forwards that peek to the RIOT
 * object.
 *     
 * </p>
 * <p>
 *     The JSSystem knows which object to forward a peek/poke to by looking at the address.
 *     Each possible recipient ("device") has previously specified ranges of addresses which it looks
 *     at ("maps to"), and the JSSystem object keeps a list of what device covers what address. (See
 *     the IfcDevice interface.)  If you are curious about what device maps to what range of addresses,
 *     consult the Internet for a memory map for the Atari 2600.
 * </p>
 * @author Bradford W. Mott and the Stella team (original)
 * J.L. Allen (Java translation)
 */
function JSSystem(aConsole){
    this.serialVersionUID = "258470027807684384L";
    
    /**
     * The log(base2) of the size of the memory (addressable space).
     * In other words, 2 to the power of LOG_MEMSIZE equals the size of the addressable
     * space, in bytes.
     */
    
    this.pageOffset = function(aAddress) { return (aAddress & PAGE_MASK) /*% 256 */;  }
    this.myPageAccessTable=(function(){
			var t = [];
			for(var i =0; i< PAGE_COUNT;i++){
				t[i] = (new PageAccess());
			}
			return t;})();
    
    
    this.myDeviceList= [];
    this.myNumberOfDevices=0;
    this.myCPU=null;
    this.myConsole=null;
    
    this.myCycles=0;
    this.myNullDevice=new NullDevice();
    this.myDataBusState=0;
    this.myDataBusLocked=false;
    
    this.readObject = function(inn){
        inn.defaultReadObject();
    }
    
    
    
    //public void lockDataBus() { myDataBusLocked = true; }
    //public void unlockDataBus() { myDataBusLocked = false;  }
    /**
     * This does the same exact thing as processorCycle().<br>
     * (I'm can't remember why there are two different methods... JLA Sep 7 2007)
     * @param amount The number of cycles to add to the growing count
     */
    this.incrementCycles = function( amount)  {   this.myCycles += amount;    }
    /**
     * This method is called by the CPU to tell the system that a specified number of cycles have
     * elapsed. See the documentation under the IfcSystem class.
     * @param aCyclesElapsed the number of processor cycles that have elapsed
     */
    this.processorCycle = function(aCyclesElapsed) {this.incrementCycles(aCyclesElapsed); }
    /**
     * Returns the number of processor cycles that have elapsed since the last reset.
     * Don't confuse processor cycles with "instruction cycles"...a given instruction will
     * last multiple processor cycles.
     * @return the number of processor cycles that have elapsed
     */
    this.getCycles = function()    {  return this.myCycles;    }

    /**
     * (Sep 7 2007 - JLA: I don't know what this does...originally from Stella code)
     * @return ?
     */
    this.getDataBusState = function() { return this.myDataBusState; }
    /**
     * Returns the CPU object (although it's probably better for objects to go
     * through the JSSystem--the secretary--than go directly to the CPU, just for
     * encapsulation's sake, not for performance reasons.
     * @return the CPU object
     */
    this.getCPU = function() { return this.myCPU; }
    
    /**
     * Halts the CPU.  When the TIA encounters the signal that tells it a visual frame 
     * is complete, it will call this method, and the CPU will not execute any more 
     * instructions until it is instructed to do so again.
     */
    this.stopCPU = function() {  this.getCPU().stop();  }
   // public PageAccess[] getPages() {  return myPageAccessTable;  }

    
    this.getNullDevice = function()  {   return this.myNullDevice;  }
    
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * Assigns the PageAccess to the given page. <br>
     * <p>
     *     PageAccess objects are used to register what device has claimed a given chunk ("page") of
     *     memory.  Each chunck is 64 bytes of memory.   
     * </p>
     * Rather than use the PaceAccess object
     * passed as an argument, it only makes a copy of the data.  Therefore, later changes
     * to the object that is passed as an argument will not be reflected in the PageAccess
     * that is stored in this JSSystem class.
     * @param page Page number to associate this PageAccess information with
     * @param access a PageAccess class containing the information that will be copied to the
     * PageAccess object at the specified page number
     */
    this.setPageAccess = function(page, access) {
        assert(page <= PAGE_COUNT);  // Make sure the page is within range
        assert(access.getDevice() != null);   // Make sure the access methods make sense
        
        this.myPageAccessTable[page].copyDataFrom(access);
        
        //System.out.println("DEBUG - assigning page " + page + " to " + access.getDevice().name());
    }
    
    /**
     * This erases all the the PageAccess objects from the list...it essentially
     * clears all the "claims" that devices have on ranges of memory
     */
    this.clearPageAccesses = function() {
        // Initialize page access table
        var access=new PageAccess(this.myNullDevice);
        for(var page = 0; page < PAGE_COUNT; page++) {
            this.myPageAccessTable[page]=new PageAccess(this.myNullDevice);
            this.setPageAccess(page /*% 256 */, access);
        } //end : for page loop
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * This will cause the CPU to execute instructions, up to the number supplied.  If the 
     * CPU signals another device which, in turn, stops the CPU, this method will exit before
     * the specified number of instructions have been executed.
     * @param aInstructionCount the (maximum) number of instructions that will be executed
     * @throws jstella.core.JSException if an instruction is not recognized
     * @return the number of CPU instructions executed
     */
    this.executeCPU = function(aInstructionCount){
        var zReturn=0; 
        //try{
            zReturn=this.myCPU.execute(aInstructionCount);
        //}//end : try
        /*catch (J6507Exception e) {
            if (e.myExceptionType==J6507Exception.ExceptionType.INSTRUCTION_NOT_RECOGNIZED) {
                throw new JSException(JSException.ExceptionType.INSTRUCTION_NOT_RECOGNIZED, e.myMessage);
            }//end : inst not recog
        }*///end : catch
        return zReturn; 
    }
  
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * This will do two things:<br>
     * 1. It will add the device to a list of devices that it maintains
     * 2. It will tell the device to "install" itself...that is, to register a claim
     * over certain addresses by calling the setPageAccess(...) method.
     * @param aDevice the device which should be installed
     */
    this.attach = function(aDevice) {
				if(aDevice instanceof J6507){
					console.log("a CPU attached!");
		     	this.myCPU = aDevice;  // Remember the processor
    	    this.myCPU.install(this);   // Ask the processor to install itself
				}
				else {
					console.log("a Device attached!");
        assert(this.myNumberOfDevices < 100);
       	
				var flag = false;
				var length = this.myDeviceList.length;
				for(var i=0;i<length;i++){
					if(this.myDeviceList[i] == aDevice) flag=true;
				}
				if(!flag)
					this.myDeviceList.push(aDevice);
   //     if (this.myDeviceList.contains(aDevice)==false) myDeviceList.add(aDevice);   // Add device to my collection of devices
        aDevice.install(this);// Ask the device to install itself
				}
    }
    
    /**
     * This does the opposite of attach(...)
     * @param aDevice device to uninstall
     */
    this.unattach = function(aDevice) {
        //PART 1 : remove the device from the device list
        var zFound=false;
        do{
					zFound = false;
					t = this.myDeviceList.length;
					for(var i=0;i<t;i++){
						if(this.myDeviceList[i] == aDevice)
						{
							this.myDeviceList.remove(i);
							zFound = true;
							break;
						}
					}
           // zFound=this.myDeviceList.remove(aDevice);
        }while (zFound==true);
        
        //PART 2 : replace the page accesses of the device with those of the null device
        var zPA=new PageAccess(this.getNullDevice());
        for (var i=0; i<this.myPageAccessTable.length; i++) {
            if (aDevice == this.myPageAccessTable[i].getDevice()) {
                //System.out.println("DEBUG - unattaching/replacing page " + i + " with null device");
                this.setPageAccess(i,zPA);
            }//end : found page access
        }//end : for i loop
        
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * This sets the CPU object that the system will use.  There should be no reason
     * for outside classes to call this method... (but it will remain public for the time
     * being).
     * @param a6507 the CPU
     */
   	//this.attach= function(a6507) {
    //   }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * This resets the cycle count that the JSSystem object maintains...it is generally 
     * called by the TIA at the start of a new visual frame.
     */
    this.resetCycles = function(){
				length = this.myDeviceList.length;

        for (var i=0;i<length;i++) {  this.myDeviceList[i].systemCyclesReset();  } // First we let all of the device attached to me know about the reset
       // if (myCycles!=JSTIA.CPU_CYCLES_PER_FRAME) System.out.println("JSSystem warning: resetting cycles at " + myCycles);
        this.myCycles = 0;  // Now, we reset cycle count to zero
    }
    
  
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * Resets the CPU, and then resets all of the devices currently installed
     * in this JSSystem object.
     */
    this.reset = function() {
        this.resetCycles();  // Reset system cycle counter
        for (var zDev=0;zDev<this.myDeviceList.length;zDev++) { this.myDeviceList[zDev].reset();   } //resets every device
        if(this.myCPU != null)  this.myCPU.reset();  // Now we reset the processor if it exists
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    /**
     * Retrieves the PageAccess for a given page.
     * @param page the page number
     * @return the corresponding PageAccess
     */
    this.getPageAccess = function(page) {
        assert(page <= PAGE_COUNT);  // Make sure the page is within range
        return this.myPageAccessTable[page];
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 
    
    
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
    
    this.peek = function( addr) {
        assert(addr>=0);
        var result=0;
        result=this.pageAccessAtAddress(addr).peek(addr);
        
        this.myDataBusState = result;
        return result;
    }
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
    
    /**
     * This is called by the CPU to write to an address.  The system is responsible for
     * routing this request to the appropriate device.
     * @param addr the address to poke
     * @param aByteValue the byte to associate with that address
     */
    this.poke = function(addr, aByteValue) {
        assert((aByteValue>=0)&&(aByteValue<0x100));
      
        this.pageAccessAtAddress(addr).poke(addr, aByteValue);
        this.myDataBusState = aByteValue;
    }
    
    this.pageAccessAtAddress = function(aAddress) {
        return this.myPageAccessTable[(aAddress & ADDRESS_MASK) >>> PAGE_SHIFT];
    }
    
    
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    
   
    
    
    /**
     * This is called by the CPU to determine what address it should start with after
     * the CPU has been reset.
     * @return the address that the CPU should start with
     */
    this.getResetPC = function() {
        
        var zReturn= ((this.peek(0xfffc)) | (this.peek(0xfffd) << 8));
        //  dbg.out("getResetPC()", zReturn);
        return zReturn;
    }
    
    
    
 
    
    
    
    
    
    
    
    /**
     * Creates a new JSSystem object.  This will automatically create a J6507 (CPU) object.
     * The other JStella classes should not concern themselves with interacting directly with 
     * the CPU, but instead should act through this class, the CPU's secretary.
     * @param aConsole The 2600 console that this JSSystem belongs to
     */

	   if(!((1 <= LOG_PAGESIZE) && (LOG_PAGESIZE <= LOG_MEMSIZE) && (LOG_MEMSIZE <= 16)))
				{
					console.log("ASSERT ERROR");
				}
        this.myConsole=aConsole;

        this.clearPageAccesses(); // Installs null devices for every page

        this.myDataBusLocked = false;  // Bus starts out unlocked (in other words, peek() changes myDataBusState)
        this.attach	(new J6507(this)); //creates the CPU and installs it
}

function JSConsole (aConsoleClient) {
  this.serialVersionUID = 1;
  this.DEFAULT_YSTART = 34;
  this.DEFAULT_DISPLAY_HEIGHT = 210;
  this.DEFAULT_DISPLAY_WIDTH = CLOCKS_PER_LINE_VISIBLE;
  this.TRASH_FRAMES =60;

  this.myFrameRate = 60;
 
 	this.myDisplayFormat=DisplayFormat.NTSC;
    
    
  this.myDisplayHeight=this.DEFAULT_DISPLAY_HEIGHT;
  this.myDisplayWidth=this.DEFAULT_DISPLAY_WIDTH;
  this.myYStart=this.DEFAULT_YSTART;
	(function(t){console.log(t);})(this);
    
  this.myConsoleClient=null;
    
  this.myControllers= [];
    
    
 
  this.mySwitches = 0xFF;
  this.mySystem = null; // TODO
  this.myCart = null; // TODO
  this.myRiot = null; // TODO
  this.myVideo = null; // TODO
  this.myAudio = null; // TODO

  this.myTelevisionMode = TELEVISION_MODE_OFF;

 // this.JSConsole = function (aConsoleClient) {
//    this.setConsoleClient(aConsoleClient);
//    this.initializeAudio();
//    this.initializeVideo();
    // ... 
  //}


    /**
     *
     * @param in This is a method called by the JVM system whenever this object
     * is deserialized.  It serves as sort of an alternate constructor,
     * one that is used in place of the normal one.
    * @throws java.io.IOException
     * @throws java.lang.ClassNotFoundException
     */
//    private void readObject(java.io.ObjectInputStream in)  throws IOException, ClassNotFoundException {
//        double zVersion=in.readDouble(); //Read the manually written JStella version number from stream
//       //TODO : make sure version being read is not GREATER than version being used
//        in.defaultReadObject();
//        
//        Object zAudioArrayObj=in.readUnshared();
//       
//        
//        initializeAudio(); //myAudio is transient, so this must create a new one when it loads
//         if (zAudioArrayObj instanceof int[])
//         {
//            int[] zAudioRegisters=(int[])zAudioArrayObj;
//            myAudio.setAudioRegisterData(zAudioRegisters);
//           // System.out.println("debug : reading audio data- " + zAudioRegisters[1] + ", " + zAudioRegisters[3] + "," + zAudioRegisters[5] );
//     
//         }//end : is int[]
//        adjustBackBuffer();
//    }
//    
//     private void writeObject(ObjectOutputStream out) throws IOException
//    {
//      out.writeDouble(JSConstants.JSTELLA_VERSION_NUMBER);   //First, manually write JStella version number to stream
//      out.defaultWriteObject();
//      int[] zAudioRegisters=myAudio.getAudioRegisterData();
//      out.writeUnshared(zAudioRegisters);
//    //  System.out.println("debug : writing audio data- " + zAudioRegisters[1] + ", " + zAudioRegisters[3] + "," + zAudioRegisters[5] );
//     } 
//    
//    
//    
//    
//    /**
//     * The console should (must) be destroyed right before the object is no longer used,
//     * e.g. when loading a serialized console from a stream.  Destroying the console
//     * will free up the audio resources that the audio object has reserved.
//     */
//    public void destroy() {
//        if (myAudio!=null) {
//            myAudio.close();
//            myAudio=null;
//        }//end : not null
//    }
//    
//    
//// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   	this.detectDisplayHeight = function()
    {
  	    this.mySystem.reset();
        for (var i=0; i<this.TRASH_FRAMES; i++)
        {           
            this.myTIA.processFrame();          
        }
        
        console.log("debug : myDetectedYStop=" + this.myTIA.getDetectedYStop() + ", myDetectedYStart=" + this.myTIA.getDetectedYStart());
        this.myDisplayHeight=this.myTIA.getDetectedYStop() - this.myTIA.getDetectedYStart(); //getVBlankOn() - myTIA.getVBlankOff();
        if (this.myDisplayHeight<=0) this.myDisplayHeight += this.myTIA.getVSyncOn();
        this.myDisplayHeight=Math.min(this.myDisplayHeight, FRAME_Y_MAX);
        
        if (this.myDisplayHeight < FRAME_Y_MIN)
        {
            //TODO : make sure this doesn't happen
            this.myDisplayHeight=220;
            this.myYStart=34;
            
            console.log("Warning: JStella was unable to detect the proper frame height");
           // assert(false);
        }//end : less than the min
        
        this.myYStart=this.myTIA.getDetectedYStart();
       // System.out.println("Detected display dimensions: yStart=" + myYStart + ", display height=" + myDisplayHeight);
        
        
        if ((this.myDisplayFormat == DisplayFormat.PAL) && (this.myDisplayHeight ==210)) this.myDisplayHeight=250;
        
        this.adjustBackBuffer(); 
    }
//    
    this.detectDisplayFormat = function() {
        // Run the system for 60 frames, looking for PAL scanline patterns
        // We assume the first 30 frames are garbage, and only consider
        // the second 30 (useful to get past SuperCharger BIOS)
        // Unfortunately, this means we have to always enable 'fastscbios',
        // since otherwise the BIOS loading will take over 250 frames!
        this.mySystem.reset();
        
        var zPalCount = 0;
        
        
        for (var i=0; i<this.TRASH_FRAMES; i++)
        {
            this.myTIA.processFrame();
        }
        
        for (var i=0; i<30; i++)
        {           
            this.myTIA.processFrame();
           //  System.out.println("Debug : scan lines=" + myTIA.scanlines());
            if(this.myTIA.scanlines() > 285) 
            {
                ++zPalCount;
               
            }//end : >285 lines
        }
        
        if (zPalCount >= 15) this.setDisplayFormat(DisplayFormat.PAL);
        else this.setDisplayFormat(DisplayFormat.NTSC);
       
        
       console.log("Display format = " + this.myDisplayFormat + ", display height=" + this.myDisplayHeight);
        
    }
//    
//    public void changeYStart(int aNewYStart)
//    {
//       if (aNewYStart!=myYStart)
//       {
//           myYStart=aNewYStart;
//           myTIA.frameReset();
//       }//end : new value
//    }
//    
//    public void changeDisplayHeight(int aNewHeight)
//    {
//         if (aNewHeight!=myDisplayHeight)
//       {
//           myDisplayHeight=aNewHeight;
//           adjustBackBuffer();
//           myVideo.refresh();
//           myTIA.frameReset();
//       }//end : new value
//    }
//    
			this.adjustBackBuffer = function()
    {
				var t = this.getVideo();
        t.adjustBackBuffer(t.DEFAULT_WIDTH, this.myDisplayHeight);
    }
//    
//   
//    
	    this.getDisplayWidth = function() { return this.myDisplayWidth; }	
	   	this.getDisplayHeight = function() { return this.myDisplayHeight; }
	    this.getYStart = function() {    return this.myYStart; }
//    
    	this.setConsoleClient = function(aConsoleClient) { this.myConsoleClient=aConsoleClient; }
			this.getConsoleClient = function() { return this.myConsoleClient;}
    	this.getController = function(jack) {return (jack == Jack.LEFT) ? this.myControllers[0] : this.myControllers[1];}
//    
			this.getTIA = function() { return this.myTIA; }
			this.getVideo = function() {    return this.myVideo;  }
//    public JSAudio getAudio()   {   return myAudio;  }
//    public jstella.core.JSSystem getSystem()  { return mySystem; }
//    public Cartridge getCartridge()  { return myCart; }
//    public JSRiot getRiot() { return myRiot; }
//    
//    public   int getNominalFrameRate() {
//        // Set the correct framerate based on the format of the ROM
//        // This can be overridden by changing the framerate in the
//        // VideoDialog box or on the commandline, but it can't be saved
//        // (ie, framerate is now solely determined based on ROM format).
//        // int framerate = myOSystem.settings().getInt("framerate");
//        // if(framerate == -1) {
//        return myFrameRate;
//                
//    }
//    
    this.setNominalFrameRate = function( aFrameRate)
    {
        this.myFrameRate=aFrameRate;
  //      getAudio().setNominalDisplayFrameRate(aFrameRate);
    }
//    
//    
  	this.getDisplayFormat = function()
  {
      return this.myDisplayFormat;
  }
//    
  	this.setDisplayFormat = function(aDisplayFormat) {
        this.myDisplayFormat=aDisplayFormat;
        this.setNominalFrameRate(aDisplayFormat.getDisplayRate());
        this.getVideo().setTIAPalette(aDisplayFormat.getDisplayPalette());
      
        this.mySystem.reset();
    }
//
//   private void reinstallCore()
//   {
//        mySystem.attach(myRiot);
//        mySystem.attach(myTIA);
//   }
//    
//// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//    
    	this.initializeVideo = function() {
        if(this.myVideo==null) this.myVideo = new JSVideo(this);
	        this.getVideo().initialize();
      }
//    
//// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//    private  void initializeAudio() {
//        if (myAudio==null) myAudio = new JSAudio(this);
//        else myAudio.close(); //Closes any open audio resources
//        
//        getAudio().setNominalDisplayFrameRate(getNominalFrameRate());
//        getAudio().initialize();
//    }
//    
//    
//    
//    
    this.setTelevisionMode = function(aTelevisionMode)
    {
			this.myTelevisionMode=aTelevisionMode;
    }
    
    this.getTelevisionMode = function()
    {
        return this.myTelevisionMode;
    }
//    
//    // ===================== Cartridge related methods ============================
//    
	    
    
    this.insertCartridge2 = function(aCart, aDisplayHeight){
        if ((this.myCart!=null)&&(this.myCart!=aCart)) {
	            this.mySystem.unattach(myCart);
	            this.reinstallCore();
        }//end : previous cartridge is being replaced
        
        this.myVideo.clearBackBuffer();
       	this.myVideo.clearBuffers();
 	      this.myCart=aCart;
 	      this.myCart.setConsole(this);
        
 	      this.mySystem.attach(this.myCart);
 				this.mySystem.reset();
        this.detectDisplayFormat();
        
  	    if (aDisplayHeight<=0) this.detectDisplayHeight();
        else this.myDisplayHeight=aDisplayHeight;
      	this.adjustBackBuffer();
        
        
        // Make sure height is set properly for PAL ROM
       
        this.setTelevisionMode(TELEVISION_MODE_GAME);
        // Reset, the system to its power-on state
        this.mySystem.reset();
       	console.log("JStella display: YStart=" + this.myYStart + ", DisplayHeight=" + this.myDisplayHeight);
    }
    
    
		this.insertCartridge = function (aCart)
  	  {
	        this.insertCartridge2(aCart, -1);
	    }

    this.createCartridge = function(aInputStream, aCartridgeType) {
        var zCart=null;
				//try
				{
            if (aInputStream!=null) {
                //zROMData = readByteArrayFromStream(aInputStream);
								zROMData = aInputStream;

                if (zROMData!=null) {
                    
										cart = new Cartridge();

                    if (aCartridgeType==null) zCart=cart.create(zROMData);
                    else zCart=cart.create(zROMData, aCartridgeType);
                    
                }//end : ROMData not null
                else {
                    console.log("Could not read stream");
                    
                }//end : ROMData is null
                
            }//end : stream not null
            else {
                console.log("JSTELLA ERROR : attempting to read from a null stream");
            }//end : stream is null
        }//end : try
//        catch (e) {
//            console.log("Could not load ROM");
//        }
        
			  return zCart;
    }
    
    /*public static Cartridge createCartridge(java.io.InputStream aInputStream) throws JSException {
       return createCartridge(aInputStream, null);
        
    }*/
//    
//    
//// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//    
//    
//    
//    
//    
//    private static byte[] readByteArrayFromStream(java.io.InputStream aStream) throws IOException {
//        byte[] zReturn=null;
//        java.io.ByteArrayOutputStream zBAOS=new java.io.ByteArrayOutputStream();
//        int zInt=0;
//        while ((zInt = aStream.read()) != -1) {
//            zBAOS.write(zInt);
//        }//end : while loop
//        zBAOS.close();
//        zReturn=zBAOS.toByteArray();
//        return zReturn;
//    }//::
//    
//    
//    // ====================== MAIN METHOD ========================
//    
//    
//    /**
//     * This is the main method of the class.  This method should be called
//     * by the "outside" GUI object for every intended frame...that is,
//     * the runner object should call this 50-60 times/sec, depending on
//     * what the designated frame rate is.
//     * @throws jstella.core.JSException
//     */
    this.doFrame = function(){
        //profiling note - Sep 3 2007 - it seems that a lot of times, whenever doFrame() lasts long (e.g. 59 milliseconds), that 
        //  the processFrame is taking up most of the time
        
        if (this.myVideo!=null)
        {   
         
        if (this.getTelevisionMode()==TELEVISION_MODE_GAME)
        {
            if (this.myCart!=null) 
            {
            this.myTIA.processFrame();    
            this.myVideo.doFrameVideo();
//            myAudio.doFrameAudio(mySystem.getCycles(), getNominalFrameRate());
            }//end : cartridge loaded
						else
							console.log("no cartridege in doFrame JSConsole")
           
        }
        else if (this.getTelevisionMode()==TELEVISION_MODE_SNOW)
        {
            myVideo.doSnow();
        }//end : not snow
        else if (this.getTelevisionMode()==TELEVISION_MODE_TEST_PATTERN)
        {
           myVideo.doTestPattern();  
        }//end : test pattern
        
        }//end : video not null
        else  {
            console.log("JStella Error : cannot animate");
        }//end : myVideo is null
        
    }
//    
//    public synchronized void updateVideoFrame()
//    {
//        if (myVideo!=null)
//        {
//            myVideo.updateVideoFrame();  
//            
//        }
//        
//    }
//   
//    
//    
//    
//    
//    
//    
//    
//    
//    //================= JSConsole Switches =====================
//    
//    
    	this.readSwitches = function() {
	        return this.mySwitches;	
					}
//    
//    
//    
//    
//    /**
//     * Flips a console switch.
//     * Switch down is equivalent to setting the bit to zero.
//     * See the SWITCH constants in the JSConsole class.
//     * <p>
//     * RESET - down to reset
//     * SELECT - down to select
//     * BW - down to change into black and white mode
//     * DIFFICULTY P0 - down to set player 0 to easy
//     * DIFFICULTY P1 - down to set player 1 to easy
//     *
//     * </p>
//     * @param aSwitchType what switch to flip (see SWITCH constants in JSConstants)
//     * @param aSwitchDown true if the switch should be down (see method description for details)
//     */
    this.flipSwitch = function(aSwitchType, aSwitchDown) {
        if (aSwitchDown) this.mySwitches &= ~aSwitchType.getBitMask();
        else this.mySwitches |= aSwitchType.getBitMask();
    }
    
    this.isSwitchOn = function(aSwitch)
    {
        return ((this.mySwitches & aSwitch.getBitMask())==0); //in this case, a bit value of zero means 'on'
    }
//    
//    
//    
//    //================ GUI Options ==================================================
//    
//    public void setPhosphorEnabled(boolean aEnable)
//    {
//        getVideo().setPhosphorEnabled(aEnable);
//    }
//    
//    public boolean isPhosphorEnabled()
//    {
//        return getVideo().getPhosphorEnabled();
//    }
//    
//    public void setStereoSound(boolean aEnable)
//    {
//        if (aEnable==true) getAudio().setChannelNumber(2);
//        else getAudio().setChannelNumber(1);
//        
//    }
//    
//    public boolean isStereoSound()
//    {
//        return (getAudio().getChannelNumber()==2);
//    }
//    
//    public void setSoundEnabled(boolean aEnabled)
//    {
//        getAudio().setSoundEnabled(aEnabled);
//    }
//    
//    public boolean isSoundEnabled()
//    {
//        return getAudio().isSoundEnabled();
//    }
//    
//    public void grayCurrentFrame()
//    {
//        getVideo().grayCurrentFrame();
//    }
//    
//    public void pauseAudio() { getAudio().pauseAudio(); }
//    
//    
// 
//    
//    //Misc tasks
//    
//    //TODO : Figure out if this setup (using java.util.Timer) is thread safe
//    //TODO : Fix letter box mode...junk keeps appearing on margins (Sep 7 2007)
//    
//   //TODO : find out what causes the processFrame() to occasionally last about 60 ms (seen during slowdown)
//                     //Update : possibly the processFrame() is blocking when accessing the back buffer because of draw
//    
//    //TODO : Make Berenstein bears work, assuming the flaw is with the emulator
//    //TODO : Fix flaws in emulator that cause AIR-RAID to act funny
//    
//    
//    //Misc bugs
//  
//    
//    
//    
//    
//    
//    public void debugDoFrame()
//    {
//        try{
//        doFrame();
//        }//end : try
//        catch (Exception e)
//        {
//            e.printStackTrace();
//        }        
//    }
//    
//    public void debugProcessFrame()
//    {
//        try{
//        myTIA.processFrame();
//        }//end : try
//        catch (Exception e)
//        {
//            e.printStackTrace();
//        }        
//    }
//    
//     public void debugDoFrameVideo()
//    {
//        try{
//        myVideo.doFrameVideo();//.processFrame();
//        }//end : try
//        catch (Exception e)
//        {
//            e.printStackTrace();
//        }        
//    }
//     
//     
//     //========================================================================
//    
//     
//    
//   
        this.setConsoleClient(aConsoleClient);
        //   myUserPaletteDefined=false;
        
        
        
       // this.initializeAudio();

        this.initializeVideo();
        this.flipSwitch(ConsoleSwitch.SWITCH_RESET, false);
        this.flipSwitch(ConsoleSwitch.SWITCH_SELECT, false);
        this.flipSwitch(ConsoleSwitch.SWITCH_BW, false);
        this.flipSwitch(ConsoleSwitch.SWITCH_DIFFICULTY_P0, false); //amateur setting
        this.flipSwitch(ConsoleSwitch.SWITCH_DIFFICULTY_P1, false); //amateur setting
        
				this.myControllers = [];
        this.myControllers[0] = new JSController(Jack.LEFT);
        this.myControllers[1] = new JSController(Jack.RIGHT); 
        
        this.mySystem = new JSSystem(this);
        this.myRiot = new JSRiot(this);
        this.myTIA = new JSTIA(this);
        
        this.mySystem.attach(this.myRiot);
        this.mySystem.attach(this.myTIA);
				console.log(this);
}


/*
 * Intercessor.java
 *
 * Created on August 13, 2007, 7:38 PM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */

/*package jstella.runner;

import java.awt.event.*;
import java.awt.*;
import javax.swing.*;
import java.io.*;
import jstella.core.*;
import jstella.cart.*;



import static jstella.core.JSConstants.*;
*/


/**
 * A go-between for the GUI classes and JSConsole.  It is mostly a way of
 * centralizing commonly used methods for the various GUI classes (JStellaMain,
 * JStellaApplet, etc.)
 * It is also a way of letting those who work strictly with the GUI be free from
 * a lot of the behind-the-scenes stuff.
 * <p>
 * It handles the timers, etc.
 * </p>
 * 
 * This class is optional--GUI classes are free to interact directly with the JSConsole.
 * @author Sysop
 */
function Intercessor(aClient){

    //NTSC and PAL are television formats...NTSC is used the U.S.
    // -NTSC televisions update the screen 60 times/sec (i.e. 60 Hertz).  To emulate this,
    // a util timer is used, with a delay of 17 milliseconds.  Thus, there are (1000 ms /17 ms) or about 58.8 cycles
    // per second using this delay.
    
    this.TIMER_DELAY_NTSC= 17;
    this.TIMER_DELAY_PAL=20;
    this.TIMER_DELAY_SNOW=100;
    
		this.myUtilTimer=null; 
//    this.myInputMaster=new InputMaster(this);
    this.myCanvas=null;
    
    
    this.myIntercessorClient=null;
    this.myConsole=null;
    
    this.myVirtualJoystickDialog=null;
    
    this.myCurrentTimerDelay=this.TIMER_DELAY_NTSC;
    this.myAutoPauseMode=false;
    this.myPausedByPlayer=false;
    this.myPausedByFocusLoss=false;
   
//    this.myCanvasFocusListener=new IntercessorKeyboardFocusListener();
    
    /**
     * Creates a new instance of Intercessor.  GUI classes should implement the interface
     * IfcIntercessorClient, which contains methods telling the GUI to update this-and-that.
     * @param aClient the client (i.e. GUI class) of the intercessor.
     */
    
		this.createCanvas = function()
    {
        if (this.myCanvas==null) 
        {
           this.myCanvas=new JStellaCanvas();
       //    myCanvas.addKeyListener(myInputMaster.getKeyListener());
       //    myCanvas.addFocusListener(myCanvasFocusListener);
           
       //    myInputMaster.addPaddleToComponent(0, myCanvas);
         //  if (myIntercessorClient!=null) myIntercessorClient.displayCanvas(myCanvas);
        }
    };

    this.updateTimerDelay = function() {
        if (this.myConsole.getTelevisionMode()==TELEVISION_MODE_SNOW) this.myCurrentTimerDelay=this.TIMER_DELAY_SNOW;
        else if (this.myConsole.getDisplayFormat()==DisplayFormat.PAL) this.myCurrentTimerDelay=this.TIMER_DELAY_PAL;
        else this.myCurrentTimerDelay=this.TIMER_DELAY_NTSC;
//       	this.myConsole.getAudio().setRealDisplayFrameRate(1000.0 / myCurrentTimerDelay);
    };
    
    
    
    this.initConsole = function(aConsole) {
        if ((this.myConsole!=null)&&(this.myConsole!=aConsole)) {
            myConsole.destroy();
        }//end : destroy old console
        this.myConsole=aConsole;
        this.myConsole.setConsoleClient(this);
    		
       //this.updateTelevisionMode();
       
			 //myCanvas.requestFocusInWindow(); TODO
       this.updateTimerDelay();
    };
    
		this.myIntercessorClient=aClient; /* Constructor */
		this.createCanvas();
		tempConsole = new JSConsole(this);
		console.log(tempConsole);
		this.initConsole(tempConsole);
    

    /**
     * Returns the cartridge object.  Will return NULL if no cartridge has been loaded.
     * @return the cartridge object
     */
    this.getCartridge = function() {
        return myConsole.getCartridge();
    };
    
    this.getInputMaster = function()
    {
        return myInputMaster;
    };
    
    /**
     * Changes the television mode (game, tv test pattern, snow/static) based
     * on whether a cartridge is loaded, and if not, what the configuration specifies.
     */
    this.updateTelevisionMode = function()
    {/*
        if (this.myConsole.getCartridge()!=null) this.myConsole.setTelevisionMode(TELEVISION_MODE_GAME);
        else
        {
           zDefaultScreen=myIntercessorClient.getConfiguration().get(JStellaMain.CONFIG_KEY_DEFAULT_SCREEN);
           if (JStellaMain.CONFIG_VALUE_DEFAULT_SCREEN_SNOW.equals(zDefaultScreen)) myConsole.setTelevisionMode(TELEVISION_MODE_SNOW);
           else myConsole.setTelevisionMode(TELEVISION_MODE_TEST_PATTERN);
        }//end : no cartridge loaded
       myConsole.updateVideoFrame();
        
        updateTimerDelay();
				*/
    };
    
    this.isVirtualJoystickEnabled = function() {
        if ((myVirtualJoystickDialog==null)||(myVirtualJoystickDialog.isVisible()==false)) return false;
        else return true;
    };
    
    /**
     * The virtual joystick is a separate window with a graphical representation of a 
     * 2600 joystick that allows the user to use the mouse to emulate joystick movement.
     * @param aParent the parent window of which the virtual joystick window will be a child (sort-of)
     */
    this.enableVirtualJoystick = function(aParent) {
        /* TODO DODO no Virtual Joystick support */

/*				if (myVirtualJoystickDialog==null) {
            myVirtualJoystickDialog=new VirtualJoystickDialog(aParent, myInputMaster);
        }//end : is null
        myVirtualJoystickDialog.setVisible(true);*/
        // this.setAutoPauseMode(false);
        
    };
    
    this.disableVirtualJoystick = function() {
        if (myVirtualJoystickDialog!=null) myVirtualJoystickDialog.setVisible(false);
       
    };
    
    this.toggleVirtualJoystick = function(aParent) {
			/* TODO DODO no Virtual Joystick support */

				//if (isVirtualJoystickEnabled()==false) enableVirtualJoystick(aParent);
        //else disableVirtualJoystick();
    };
    
    
    
    /**
     * Starts the timer.  The timer is used to actually "run" the 2600 emulator.  
     * This method is often called from other Intercessor methods, so it may be 
     * unnecessary for the GUI class to call it.
     */
    this.startTimer = function() {
//TODO        myIntercessorClient.informUserOfPause(false);
        if (this.myUtilTimer!=null) {
          killTimer(this.myUtilTimer);
        }//end : resetting timer

				//TODO DODO CONVERT THIS CODE TO JS TIMER
//        myUtilTimer=new java.util.Timer(true);
//        myUtilTimer = scheduleAtFixedRate(new MainTimerTask(), myCurrentTimerDelay, myCurrentTimerDelay);
					this.myUtilTimer = setInterval(
					(function(self){
						return function(){
							self.MainTimerTask(self);
						};
					}
					)(this)
						 ,this.myCurrentTimerDelay);
      //  }//end : use java.util.Timer
      /*  else {
            
            if (mySwingTimer==null) mySwingTimer=new javax.swing.Timer(myCurrentTimerDelay, new MainTimerTask());
            mySwingTimer.start();
            
        }//end : use javax.swing.timer
       */
    };
    
    /**
     * Stop the "running" of the 2600 emulator...is called during pauses.
     */
    this.stopTimer = function() {
     //   if (USE_UTIL_TIMER==true) {
            if (this.myUtilTimer!=null) {
                killTimer(this.myUtilTimer);
               	this.myUtilTimer=null;
                
            }
      //  }//end : use java.util.Timer
  /*      else {
            if (mySwingTimer!=null) {
                mySwingTimer.stop();
            }//end : not null
        }//end : use javax.swing.Timer
   */
        //this.myIntercessorClient.informUserOfPause(true);
    };
    
    
    /**
     * Destroys the console, which is necessary to do so when the program is complete,
     * because the destroy method frees up any system audio resources that have been
     * reserved.
     */
    this.destroy = function() {
        myConsole.destroy();
    };
    
    
    
    /**
     * Used to load a saved game.  The GUI class is responsible for opening
     * an input stream that contains the saved game, and this method will handle
     * the rest.
     * @param aInputStream Stream containing a previously saved game
     * @throws java.io.IOException 
     * @throws java.lang.ClassNotFoundException 
     */

		//TODO DODO no loadState From Stream support
    this.loadStateFromStream = function(aInputStream) {
/*        try{
            //setPausedByPlayer(true);
            stopTimer();
            ObjectInputStream zOIS=new ObjectInputStream(aInputStream);
            Object zObj=zOIS.readObject();
            zOIS.close();
            
            if (zObj instanceof JSConsole) {
                JSConsole zNewConsole=(JSConsole)zObj;
                
                initConsole(zNewConsole);
                
                //myConsole.setTelevisionMode(TELEVISION_MODE_GAME);
                myConsole.doFrame();
                updatePause();
                refocusKeyboard();
                
                //myIntercessorClient.informUserOfPause(true);
                
                
            }//end : is a console
        }//end : try
        catch (JSException e) {
            e.printStackTrace();
        }*/
    };
    
    /**
     * Save the current "game" to the stream.  The GUI class is responsible
     * for creating a writable stream, and this method does the rest.
     * @param aOutputStream Stream that the saved game will be written to.
     * @throws java.io.IOException 
     */
    this.saveStateToStream = function(aOutputStream){
/*        boolean zIsPaused=isPausedByPlayer();
        setPausedByPlayer(true);
        ObjectOutputStream zOOS=new ObjectOutputStream(aOutputStream);
        zOOS.writeObject(myConsole);
        zOOS.close();
        setPausedByPlayer(zIsPaused);*/
        
    };
    
    /**
     * This can be called by a GUI class if it doesn't wish to implement any special
     * behavior.  This method mostly displays a dialog indicating that there was error.
     * @param e Exception to communicate to user
     * @param aDialogParent Parent in which an error-message dialog can open under
     */
    this.showDefaultExceptionResponse = function(e) {
				console.log(e);
        /*System.out.println("" + e.getMessage());
        if (e.getExceptionType()==JSException.ExceptionType.INSTRUCTION_NOT_RECOGNIZED) {
            JOptionPane.showMessageDialog(aDialogParent, "There was an error running the ROM.", "JSTELLA ERROR", JOptionPane.ERROR_MESSAGE);
            
        } else {
            JOptionPane.showMessageDialog(aDialogParent, e.getJStellaMessage(), "JSTELLA ERROR", JOptionPane.ERROR_MESSAGE);
        }*///end : other 
    }
    
    
    /**
     * To receive keyboard input, the canvas needs to have the keyboard focus.
     * If the focus is lost, this method can attempt to transfer the keyboard focus
     * back to the canvas (or whatever else is appropriate) object
     */
    /*public void refocusKeyboard() {
        if ((myCanvas!=null) && (myCanvas.isVisible()==true)) 
        {
            myCanvas.requestFocus();
            myCanvas.requestFocusInWindow();
            
        }//end : visible
    }*/
    
    this.updatePause = function() { 
			/* TODO DODO NO Pause Support
        if ((myPausedByFocusLoss==false)&&(myPausedByPlayer==false)) {
            startTimer();
        }//end : unpaused
        else {
            
            stopTimer();
            myConsole.pauseAudio();
            myConsole.grayCurrentFrame();
        }//end : is paused
				*/
    }
    
    /**
     * Since the pressing of reset is a two event process (switch down for a brief time,
     * and then switch back up), this method is needed to emulate both events with a 
     * single action.
     */

    /*public void emulateResetPress() {
        new SwitchToButtonAdapter(ConsoleSwitch.SWITCH_RESET);
    }*/
    
    /**
     * Since the pressing of select is a two event process (switch down for a brief time,
     * and then switch back up), this method is needed to emulate both events with a 
     * single action.
     */
    /*public void emulateSelectPress() {
        new SwitchToButtonAdapter(ConsoleSwitch.SWITCH_SELECT);
    }*/
    
    /**
     * When auto-pause mode is enabled, the emulator will pause whenever the appropriate object
     * (probably the canvas object) loses keyboard focus.
     * @param aEnable true to enable auto-pause mode
     */
    /*public void setAutoPauseMode(boolean aEnable) {
        myAutoPauseMode=aEnable;
        updatePause();
    }
    
    public boolean getAutoPauseMode()
    {
        return myAutoPauseMode;
    }*/
    
    /**
     * This "manually" pauses the emulator, as opposed to an automatic pause such as that
     * associated with loss of keyboard focus (see auto-pause mode methods).
     * @param aPause true to manually pause the emulator, false to unpause
     */
    /*public void setPausedByPlayer(boolean aPause) {
        myPausedByPlayer=aPause;
        updatePause();
    }*/
    
    /**
     * See setPausedByPlayer.
     * @return Returns true if the emulator is manually paused.
     */
    /*public boolean isPausedByPlayer() {
        return myPausedByPlayer;
    }*/
    
    /**
     * If paddle mode is locked, then pressing the right mouse button (or whatever else)
     * will not automatically result in the toggling of paddle mode on/off.  Thus,
     * if paddle mode is locked when paddle mode is off, paddle mode will remain off.
     * If locked when paddle mode is on, paddle mode will remain on.  This is useful for
     * applets that don't want the user accidentally exiting paddle mode, and not being
     * able to figure out what happened.
     */
    /*public void lockPaddleMode()
    {
       myInputMaster.setPaddleModeLock(false);
       myInputMaster.setPaddleMode(true);
       myInputMaster.setPaddleModeLock(true);
    }*/
    
    
    /*public void setControls(java.util.Map<String, String> aConfigMap) {
        myInputMaster.setControls(aConfigMap);
    }*/
    
		/**
     * This loads the ROM from the given stream, and starts its execution by the 
     * emulator.
     * 
     * This method allows the GUI to manually specify the cartridge type.  If the 
     * cartridge type specified is null, then the emulator will auto-detect the type.
     * 
     * This method also allows the GUI class to manually specify the display height.
     * If the display height specified is -1, the display height will be auto-detected.
     * @param aROMStream the previously opened stream containing the ROM to open
     * @param aCartridgeType manually specified cartridge type.
     * @param aDisplayHeight the display height for the ROM.  If -1, emulator will auto-detect height.
     */
    this.playROM3 = function(aROMStream, aCartridgeType, aDisplayHeight) {   
        this.stopTimer();
        zCart = this.myConsole.createCartridge(aROMStream, aCartridgeType);
          
        if (zCart!=null) {
            this.myConsole.insertCartridge(zCart, aDisplayHeight);
            this.updateTimerDelay();
                
            this.myCanvas.refreshCanvas();
            this.startTimer(); 
        }//end : not null
    };

    /**
     * This loads the ROM from the given stream, and starts its execution by the 
     * emulator.
     * 
     * This method will auto-detect the cartridge type (RECOMMENDED)
     * @param aROMStream the previously opened stream containing the ROM to open
     */
    this.playROM = function(aROMStream)  {   this.playROM3(aROMStream, null, -1);   }    
    /**
     * This loads the ROM from the given stream, and starts its execution by the 
     * emulator.
     * 
     * This method allows the GUI to manually specify the cartridge type.  If the 
     * cartridge type specified is null, then the emulator will auto-detect the type.
     * @param aROMStream the previously opened stream containing the ROM to open
     * @param aCartridgeType manually specified cartridge type.
     */
    this.playROM2 = function(aROMStream, aCartridgeType) { this.playROM3(aROMStream, aCartridgeType, -1); }
    
    
    
    /**
     * Enables/disables the audio in the core emulator classes.  GUI classes should call
     * this method whenever the user changes the configuration to enable/disable the 
     * sound.
     * @param aEnabled true to turn sound on.
     */
   // public void setSoundEnabled(boolean aEnabled) {  myConsole.setSoundEnabled(aEnabled);   }
    /**
     * Returns whether the sound is enabled (in the core emulator classes, as opposed to
     * the GUI menu).
     * @return true if the sound is enabled (in the core emulator objects)
     */
    //public boolean isSoundEnabled() { return myConsole.isSoundEnabled(); }
    
    /**
     * Phosphor mode is essentially an anti-flicker mode.  When enabled,
     * the new color put on the screen is averaged with the old color.  
     * See JSConsole/JSVideo for details.
     * @param aEnable true to turn phoshpor mode on
     */
    //public void setPhosphorEnabled(boolean aEnable)  { myConsole.setPhosphorEnabled(aEnable); }
    /**
     * Returns true if phosphor mode is enabled in the core emulator classes.
     * @return true if the emulator is currently using phosphor mode
     */
    //public boolean isPhosphorEnabled() { return myConsole.isPhosphorEnabled(); }
    //public void setStereoSound(boolean aEnable) {myConsole.setStereoSound(aEnable); }
    //public boolean isStereoSound()  { return myConsole.isStereoSound(); }
    
    /**
     * Corresponds to the TV Type switch on the 2600 console.  This reports the variable
     * from the core emulator's point of view, not any GUI implementation.
     */
    //public boolean isTVTypeBW() { return myConsole.isSwitchOn(ConsoleSwitch.SWITCH_BW); }
    //public void setTVTypeBW(boolean aBW) { myConsole.flipSwitch(ConsoleSwitch.SWITCH_BW, aBW); }
    
    //public boolean isPlayer0Amateur() { return myConsole.isSwitchOn(ConsoleSwitch.SWITCH_DIFFICULTY_P0);  }
    //public void setPlayer0Amateur(boolean aAmateur) { myConsole.flipSwitch(ConsoleSwitch.SWITCH_DIFFICULTY_P0, aAmateur); }
    
    
    //public boolean isPlayer1Amateur() { return myConsole.isSwitchOn(ConsoleSwitch.SWITCH_DIFFICULTY_P1); }
    //public void setPlayer1Amateur(boolean aAmateur) { myConsole.flipSwitch(ConsoleSwitch.SWITCH_DIFFICULTY_P1, aAmateur); }

    /**
     * This method is called to inform the Intercessor client class (i.e. the GUI) that a console
     * switch has been flipped, and that the GUI may want to update the positions 
     * of any graphical representation of the switches.
     */
    //public void switchFlipped() {
    //    if (myIntercessorClient!=null) myIntercessorClient.updateSwitches();
    //}

    this.getConsole = function() {
        return this.myConsole;
    };

    this.getCanvas = function() {
        return this.myCanvas;
    };
    
    
    /**
     * Does the same thing as getCanvas(), but the returned object is already declared
     * as a JStellaCanvas, instead of the more generic IfcCanvas...thus, no casting
     * is necessary to run JStellaCanvas specific methods.
     * @return the current canvas
     */
    this.getJStellaCanvas = function()
    {
        return this.myCanvas;
    };
    
    /**
     * Letter box mode essentially locks the screen into a fixed dimension ratio,
     * i.e. if the emulator canvas doesn't have the same width/height ratio as the 
     * emulator intends, black bars are used to make up the difference.
     * @param aEnable true to enable letter-box mode
     */
    //public void setLetterBoxMode(boolean aEnable) { if (myCanvas!=null) myCanvas.setLetterBoxMode(aEnable); }
    /**
     * 
     * @return 
     */
    //public boolean getLetterBoxMode() {  return ((myCanvas!=null) ? myCanvas.getLetterBoxMode() : false); }
  
    

    
    this.runMainLoop = function() {
        if (this.myConsole!=null) {
        	this.myConsole.doFrame();
        }//end : my console == false
    };
    
    
    //==============================================
    
    this.MainTimerTask = function(self) {
        /**
         * This is called by a java.util.Timer
         */
//        this.run = function() {
            self.runMainLoop();
  //      };
        
        
        /**
         * This is called by a javax.swing.Timer
         * @param e
         */
    //    this.actionPerformed = function(e) {
    //      runMainLoop();
    //    };
        
    };//END INNER CLASS
    
    //========================================================
    /**
     * This is the Intercessor client interface that GUI classes should implement
     * to allow the Intercessor to fully communicate with it.
     */
    //public interface IfcIntercessorClient  {
        /**
         * The GUI class should have this method add the specified canvas to wherever it
         * intends the emulator screen to be in the GUI.
         * e.g. the class may add the canvas to the content pane in a border layout, setting the 
         * canvas to CENTER.
         * @param aCanvas the canvas that the GUI class should add and display
         */
     //   public void displayCanvas(JPanel aCanvas);
        /**
         * This method is called whenever the intercessor receives an exception.
         * If the GUI class doesn't want to deal with this, it can simply have this method
         * call the Intercessor's showDefaultExceptionResponse method.
         * @param e the exception to deal with
         * @return return variable does nothing as of yet
         */
      //  public boolean respondToException(JSException e);
        /**
         * This method is called whenever the intercessor pauses the emulator, and it
         * allows the GUI to implement some sort of pause-notification scheme, so that the 
         * user doesn't think the emulator is locked-up.
         * @param aIsPaused true if paused, false if no longer paused
         */
      //  public void informUserOfPause(boolean aIsPaused);
        /**
         * This method is called whenever one of the console switches has been changed,
         * and it allows the GUI class to make any graphics/menu changes to reflect this.
         */
     //   public void updateSwitches();
        /**
         * This method should return the current user configuration object.
         * @return the configuration map
         */
     //   public java.util.Map<String, String> getConfiguration();
        
      //  public boolean isOkayToAutoPause();
        
   // }
    
    
    //===============================
    
    /**
     * This converts a single-action (e.g. a button click) into the two actions needed
     * for certain switches (reset and select).
     */
    /*private class SwitchToButtonAdapter implements ActionListener {
        
        ConsoleSwitch mySwitchType=null;
        javax.swing.Timer mySwitchTimer=new javax.swing.Timer(50, this);
        
        public SwitchToButtonAdapter(ConsoleSwitch aSwitchType) {
            mySwitchType=aSwitchType;
            myConsole.flipSwitch(aSwitchType, true);
            
            mySwitchTimer.setRepeats(false);
            mySwitchTimer.start();
        }
        
        public void actionPerformed(ActionEvent e) {
            myConsole.flipSwitch(mySwitchType, false);
            mySwitchTimer.stop();
            mySwitchTimer=null;
            //mySTBA=null;
        }
    }
    
    */
    //================================================================================
    
   /* private class IntercessorKeyboardFocusListener implements java.awt.event.FocusListener {
        public void focusLost(FocusEvent e) {
           // System.out.println("Debug : focus lost, new owner is " + e.getOppositeComponent());
            if (myAutoPauseMode==true)
            {
            //if (e.getOppositeComponent()==null) myPausedByFocusLoss=true;
           // else if (e.isTemporary()==false) myPausedByFocusLoss=true;
                if (!(e.getOppositeComponent() instanceof JButton))  myPausedByFocusLoss=true;
            }//end : autopause is on
             updatePause();
            
        }
        
        public void focusGained(FocusEvent e) {
            
            myPausedByFocusLoss=false;
            updatePause();
            
        }
        
    }
   */ 
    
    //=================================================
    
    /*private class IntercessorInputVerifier extends javax.swing.InputVerifier
    {
        public boolean verify(JComponent jComponent) {
            return false;
        }
        
    }*/
    
    
}

$(function(){
	var intercessor = new Intercessor(this);
	intercessor.playROM(Pacman);
});
